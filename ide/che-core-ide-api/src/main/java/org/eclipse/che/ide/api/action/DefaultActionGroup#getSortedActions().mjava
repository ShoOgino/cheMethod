  /**
   * Sorts actions depending on their constraints and their input order.
   *
   * @return An array of sorted actions
   */
  //TODO: to complicate
  private Action[] getSortedActions() {
    List<Action> result = new ArrayList<>();
    Map<Action, Constraints> unsortedMap = new LinkedHashMap<>();

    for (int i = 0; i < actionList.size(); i++) {

      Action action = actionList.get(i);
      Constraints constraints = constraintsList.get(i);

      // if action is added to result list, it needs to call
      // checkUnsorted method to look for another actions, that must be
      // before or after this action
      if (constraints.myAnchor.equals(Anchor.FIRST)) {
        result.add(0, action);
        checkUnsorted(unsortedMap, action, result);
      } else if (constraints.myAnchor.equals(Anchor.LAST)) {
        result.add(action);
        checkUnsorted(unsortedMap, action, result);
      } else {
        // find related action in result list, if found, add action
        // before or after it. If not, add to unsorted map
        int index = findIndex(constraints.relativeId, result, actionManager);
        if (index == -1) {
          unsortedMap.put(action, constraints);
        } else {
          if (constraints.myAnchor.equals(Anchor.BEFORE)) {
            result.add(index, action);
            checkUnsorted(unsortedMap, action, result);
          } else if (constraints.myAnchor.equals(Anchor.AFTER)) {
            result.add(index + 1, action);
            checkUnsorted(unsortedMap, action, result);
          }
        }
      }
    }
    // append left unsorted actions to the end
    result.addAll(unsortedMap.keySet());
    return result.toArray(new Action[result.size()]);
  }

