    @Test
    public void shouldResolveAutoSave() {
        EditorPartPresenter openedEditor1 = mock(EditorPartPresenter.class, withSettings().extraInterfaces(EditorWithAutoSave.class));
        EditorPartPresenter openedEditor2 = mock(EditorPartPresenter.class, withSettings().extraInterfaces(EditorWithAutoSave.class));
        when(openedEditor1.getEditorInput()).thenReturn(editorInput);
        when(openedEditor2.getEditorInput()).thenReturn(editorInput);
        when(((EditorWithAutoSave)openedEditor1).isAutoSaveEnabled()).thenReturn(true);
        when(((EditorWithAutoSave)openedEditor2).isAutoSaveEnabled()).thenReturn(true);
        List<EditorPartPresenter> openedFiles = new ArrayList<>(1);
        openedFiles.add(openedEditor1);
        openedFiles.add(openedEditor2);
        Set<EditorPartPresenter> setSyncEditors = new HashSet<>(2);
        setSyncEditors.add(openedEditor1);
        setSyncEditors.add(openedEditor2);
        setSyncEditors.add(activeEditor);
        when(editorAgent.getOpenedEditors()).thenReturn(openedFiles);
        when(editorGroupSynchronization.getSynchronizedEditors()).thenReturn(setSyncEditors);
        when(activePartChangedEvent.getActivePart()).thenReturn(activeEditor);
        editorContentSynchronizer.trackEditor(openedEditor1);
        editorContentSynchronizer.trackEditor(openedEditor2);
        editorContentSynchronizer.trackEditor(activeEditor);

        editorContentSynchronizer.onActivePartChanged(activePartChangedEvent);

        // AutoSave for active editor should always be enabled,
        // but AutoSave for other editors with the same path should be disabled
        verify(((EditorWithAutoSave)activeEditor), times(2)).enableAutoSave();
        verify(((EditorWithAutoSave)openedEditor1), times(2)).disableAutoSave();
        verify(((EditorWithAutoSave)openedEditor2), times(2)).disableAutoSave();
    }

