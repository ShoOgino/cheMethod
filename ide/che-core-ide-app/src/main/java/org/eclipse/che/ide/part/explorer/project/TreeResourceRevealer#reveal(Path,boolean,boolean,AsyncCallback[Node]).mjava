  protected void reveal(
      final Path path,
      final boolean select,
      final boolean isFocusRequired,
      final AsyncCallback<Node> callback) {
    if (path == null) {
      callback.onFailure(new IllegalArgumentException("Invalid search path"));
    }

    Scheduler.get()
        .scheduleFixedDelay(
            () -> {
              if (tree.getNodeLoader().isBusy()) {
                return true;
              }

              ResourceNode nodeByPath = getNodeByPath(path);
              if (nodeByPath != null) {

                if (select) {
                  TreeResourceRevealer.this.isFocusRequired = isFocusRequired;

                  if (toSelect == null) {
                    toSelect = new Node[] {nodeByPath};
                  } else {
                    final int index = toSelect.length;
                    toSelect = copyOf(toSelect, index + 1);
                    toSelect[index] = nodeByPath;
                  }

                  selectTask.delay(200);
                }

                callback.onSuccess(nodeByPath);
                return false;
              }

              ResourceNode root = getRootResourceNode(path);

              if (root == null) {
                callback.onFailure(new IllegalStateException());
                return false;
              }

              if (root.getData().getLocation().equals(path)) {
                callback.onSuccess(root);
                return false;
              }

              expandToPath(root, path, select, isFocusRequired)
                  .then(callback::onSuccess)
                  .catchError(
                      arg -> {
                        callback.onFailure(arg.getCause());
                      });

              return false;
            },
            500);
  }

