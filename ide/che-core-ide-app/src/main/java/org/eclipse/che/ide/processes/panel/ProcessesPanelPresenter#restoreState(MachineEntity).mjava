    private void restoreState(final MachineEntity machine) {
        execAgentCommandManager.getProcesses(machine.getId(), false).then(new Operation<List<GetProcessesResponseDto>>() {
            @Override
            public void apply(List<GetProcessesResponseDto> processes) throws OperationException {
                for (GetProcessesResponseDto process : processes) {
                    final int pid = process.getPid();
                    final String type = process.getType();

                    /*
                     * Do not show the process if the command line has prefix #hidden
                     */
                    if (!isNullOrEmpty(process.getCommandLine()) &&
                        process.getCommandLine().startsWith("#hidden")) {
                        continue;
                    }

                    /*
                     * Hide the processes which are launched by command of unknown type
                     */
                    if (isProcessLaunchedByCommandOfKnownType(type)) {
                        final String processName = process.getName();
                        final CommandImpl commandByName = getWorkspaceCommandByName(processName);

                        if (commandByName == null) {
                            final String commandLine = process.getCommandLine();
                            final CommandImpl command = new CommandImpl(processName, commandLine, type);
                            final CommandOutputConsole console = commandConsoleFactory.create(command, machine);

                            getAndPrintProcessLogs(console, pid);
                            subscribeToProcess(console, pid);

                            addCommandOutput(machine.getId(), console);
                        } else {
                            macroProcessor.expandMacros(commandByName.getCommandLine()).then(new Operation<String>() {
                                @Override
                                public void apply(String expandedCommandLine) throws OperationException {
                                    final CommandImpl command = new CommandImpl(commandByName.getName(),
                                                                                expandedCommandLine,
                                                                                commandByName.getType(),
                                                                                commandByName.getAttributes());

                                    final CommandOutputConsole console = commandConsoleFactory.create(command, machine);

                                    getAndPrintProcessLogs(console, pid);
                                    subscribeToProcess(console, pid);

                                    addCommandOutput(machine.getId(), console);
                                }
                            });
                        }
                    }
                }
            }

            private void getAndPrintProcessLogs(final CommandOutputConsole console, final int pid) {
                String from = null;
                String till = null;
                int limit = 50;
                int skip = 0;
                execAgentCommandManager.getProcessLogs(machine.getId(), pid, from, till, limit, skip)
                                       .then(new Operation<List<GetProcessLogsResponseDto>>() {
                                           @Override
                                           public void apply(List<GetProcessLogsResponseDto> logs) throws OperationException {
                                               for (GetProcessLogsResponseDto log : logs) {
                                                   String text = log.getText();
                                                   console.printOutput(text);
                                               }
                                           }
                                       })
                                       .catchError(new Operation<PromiseError>() {
                                           @Override
                                           public void apply(PromiseError arg) throws OperationException {
                                               String error = "Error trying to get process log with pid: " + pid + ". " + arg.getMessage();
                                               Log.error(getClass(), error);
                                           }
                                       });
            }

            private void subscribeToProcess(CommandOutputConsole console, int pid) {
                String stderr = "stderr";
                String stdout = "stdout";
                String processStatus = "process_status";
                String after = null;
                execAgentCommandManager.subscribe(machine.getId(), pid, asList(stderr, stdout, processStatus), after)
                                       .thenIfProcessStartedEvent(console.getProcessStartedOperation())
                                       .thenIfProcessDiedEvent(console.getProcessDiedOperation())
                                       .thenIfProcessStdOutEvent(console.getStdOutOperation())
                                       .thenIfProcessStdErrEvent(console.getStdErrOperation())
                                       .then(console.getProcessSubscribeOperation());
            }
        }).catchError(new Operation<PromiseError>() {
            @Override
            public void apply(PromiseError arg) throws OperationException {
                notificationManager.notify(localizationConstant.failedToGetProcesses(machine.getId()));
            }
        });
    }

