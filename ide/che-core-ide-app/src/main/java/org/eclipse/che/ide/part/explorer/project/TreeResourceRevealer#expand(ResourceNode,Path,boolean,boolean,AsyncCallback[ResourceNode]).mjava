  protected void expand(
      final ResourceNode parent,
      final Path segment,
      final boolean select,
      final boolean isFocusRequired,
      final AsyncCallback<ResourceNode> callback) {

    if (parent.getData().getLocation().equals(segment)) {
      if (select) {
        this.isFocusRequired = isFocusRequired;

        if (toSelect == null) {
          toSelect = new Node[] {parent};
        } else {
          final int index = toSelect.length;
          toSelect = copyOf(toSelect, index + 1);
          toSelect[index] = parent;
        }

        selectTask.delay(200);
      }

      callback.onSuccess(parent);
      return;
    }

    final HandlerRegistration[] handler = new HandlerRegistration[1];

    handler[0] =
        tree.getNodeLoader()
            .addPostLoadHandler(
                event -> {
                  if (!event.getRequestedNode().equals(parent)) {
                    return;
                  }

                  if (handler[0] != null) {
                    // Do not remove the handler immediately to not to lose 'loadChildren' events
                    // that were fired after the children request.
                    Scheduler.get()
                        .scheduleFixedDelay(
                            () -> {
                              handler[0].removeHandler();
                              return false;
                            },
                            1000);
                  }

                  final List<Node> children =
                      tree.getNodeStorage().getChildren(event.getRequestedNode());

                  for (Node child : children) {
                    if (child instanceof ResourceNode
                        && ((ResourceNode) child).getData().getLocation().isPrefixOf(segment)) {
                      expand((ResourceNode) child, segment, select, isFocusRequired, callback);
                      return;
                    }
                  }

                  callback.onFailure(new IllegalStateException("Not found"));
                });

    tree.getNodeLoader().loadChildren(parent);
  }

