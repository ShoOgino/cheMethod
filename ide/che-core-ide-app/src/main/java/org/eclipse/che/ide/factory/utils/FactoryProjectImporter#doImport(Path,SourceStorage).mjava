    private Promise<Project> doImport(@NotNull final Path pathToProject,
                                      @NotNull final SourceStorage sourceStorage) {
        final String projectName = pathToProject.lastSegment();
        final StatusNotification notification = notificationManager.notify(locale.cloningSource(projectName), null, PROGRESS, FLOAT_MODE);
        final ProjectNotificationSubscriber subscriber = subscriberFactory.createSubscriber();
        subscriber.subscribe(projectName, notification);
        String location = sourceStorage.getLocation();
        // it's needed for extract repository name from repository url e.g https://github.com/codenvy/che-core.git
        // lastIndexOf('/') + 1 for not to capture slash and length - 4 for trim .git
        final String repository = location.substring(location.lastIndexOf('/') + 1).replace(".git", "");
        final Map<String, String> parameters = firstNonNull(sourceStorage.getParameters(), Collections.<String, String>emptyMap());
        final String branch = parameters.get("branch");
        final String startPoint = parameters.get("startPoint");
        final MessageBus messageBus = messageBusProvider.getMachineMessageBus();
        final String channel = CHANNEL + appContext.getWorkspaceId() + ':' + projectName;
        final SubscriptionHandler<GitCheckoutEvent> successImportHandler = new SubscriptionHandler<GitCheckoutEvent>(
                dtoUnmarshallerFactory.newWSUnmarshaller(GitCheckoutEvent.class)) {
            @Override
            protected void onMessageReceived(GitCheckoutEvent result) {
                if (result.isCheckoutOnly()) {
                    notificationManager.notify(locale.clonedSource(projectName),
                                               locale.clonedSourceWithCheckout(projectName, repository, result.getBranchRef(), branch),
                                               SUCCESS,
                                               FLOAT_MODE);
                } else {
                    notificationManager.notify(locale.clonedSource(projectName),
                                               locale.clonedWithCheckoutOnStartPoint(projectName, repository, startPoint, branch),
                                               SUCCESS,
                                               FLOAT_MODE);
                }
            }

            @Override
            protected void onErrorReceived(Throwable e) {
                try {
                    messageBus.unsubscribe(channel, this);
                } catch (WebSocketException ignore) {
                }
            }
        };
        try {
            messageBus.subscribe(channel, successImportHandler);
        } catch (WebSocketException ignore) {
        }

        MutableProjectConfig importConfig = new MutableProjectConfig();
        importConfig.setPath(pathToProject.toString());
        importConfig.setSource(sourceStorage);

        return appContext.getWorkspaceRoot()
                         .importProject()
                         .withBody(importConfig)
                         .send()
                         .then(new Function<Project, Project>() {
                             @Override
                             public Project apply(Project project) throws FunctionException {
                                 subscriber.onSuccess();
                                 notification.setContent(locale.clonedSource(projectName));
                                 notification.setStatus(SUCCESS);

                                 return project;
                             }
                         })
                         .catchErrorPromise(new Function<PromiseError, Promise<Project>>() {
                             @Override
                             public Promise<Project> apply(PromiseError err) throws FunctionException {
                                 final int errorCode = ExceptionUtils.getErrorCode(err.getCause());
                                 switch (errorCode) {
                                     case UNAUTHORIZED_GIT_OPERATION:
                                         subscriber.onFailure(err.getMessage());
                                         final Map<String, String> attributes = ExceptionUtils.getAttributes(err.getCause());
                                         final String providerName = attributes.get(PROVIDER_NAME);
                                         final String authenticateUrl = attributes.get(AUTHENTICATE_URL);
                                         final boolean authenticated = Boolean.parseBoolean(attributes.get("authenticated"));
                                         if (!StringUtils.isNullOrEmpty(providerName) && !StringUtils.isNullOrEmpty(authenticateUrl)) {
                                             if (!authenticated) {
                                                 return tryAuthenticateAndRepeatImport(providerName,
                                                                                       authenticateUrl,
                                                                                       pathToProject,
                                                                                       sourceStorage,
                                                                                       subscriber);
                                             } else {
                                                 dialogFactory.createMessageDialog(locale.cloningSourceSshKeyUploadFailedTitle(),
                                                                                   locale.cloningSourcesSshKeyUploadFailedText(), null)
                                                              .show();
                                             }
                                         } else {
                                             dialogFactory.createMessageDialog(locale.oauthFailedToGetAuthenticatorTitle(),
                                                                               locale.oauthFailedToGetAuthenticatorText(), null).show();
                                         }

                                         break;
                                     case UNAUTHORIZED_SVN_OPERATION:
                                         subscriber.onFailure(err.getMessage());
                                         return recallSubversionImportWithCredentials(pathToProject, sourceStorage);
                                     case UNABLE_GET_PRIVATE_SSH_KEY:
                                         subscriber.onFailure(locale.acceptSshNotFoundText());
                                         break;
                                     case FAILED_CHECKOUT:
                                         subscriber.onFailure(locale.cloningSourceWithCheckoutFailed(branch, repository));
                                         notification.setTitle(locale.cloningSourceFailedTitle(projectName));
                                         break;
                                     case FAILED_CHECKOUT_WITH_START_POINT:
                                         subscriber.onFailure(locale.cloningSourceCheckoutFailed(branch, startPoint));
                                         notification.setTitle(locale.cloningSourceFailedTitle(projectName));
                                         break;
                                     default:
                                         subscriber.onFailure(err.getMessage());
                                         notification.setTitle(locale.cloningSourceFailedTitle(projectName));
                                         notification.setStatus(FAIL);
                                 }

                                 return Promises.resolve(null);
                             }
                         });
    }

