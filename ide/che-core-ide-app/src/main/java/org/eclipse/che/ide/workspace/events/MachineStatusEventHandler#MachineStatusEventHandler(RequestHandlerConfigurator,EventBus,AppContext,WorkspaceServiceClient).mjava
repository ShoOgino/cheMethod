    @Inject
    MachineStatusEventHandler(RequestHandlerConfigurator configurator,
                              EventBus eventBus,
                              AppContext appContext,
                              WorkspaceServiceClient workspaceServiceClient) {
        this.appContext = appContext;

        BiConsumer<String, MachineStatusEvent> operation = (String endpointId, MachineStatusEvent event) -> {
            Log.debug(getClass(), "Received notification from endpoint: " + endpointId);

            final String machineName = event.getMachineName();
            final String workspaceId = event.getIdentity().getWorkspaceId();

            workspaceServiceClient.getWorkspace(workspaceId).then(workspace -> {
                RuntimeDto workspaceRuntime = workspace.getRuntime();
                if (workspaceRuntime == null) {
                    return;
                }

                // Update workspace model returned by AppContext before firing an event.
                // Because AppContext always must return an actual workspace model.
                ((AppContextImpl)appContext).setWorkspace(workspace);

                switch (event.getEventType()) {
                    case STARTING:
                        getMachineByName(machineName).ifPresent(m -> {
                            eventBus.fireEvent(new MachineStartingEvent(m));

                            // fire deprecated MachineStateEvent for backward compatibility with IDE 5.x
                            eventBus.fireEvent(new MachineStateEvent(new MachineEntityImpl(machineName, m), CREATING));
                        });
                        break;
                    case RUNNING:
                        getMachineByName(machineName).ifPresent(m -> {
                            eventBus.fireEvent(new MachineRunningEvent(m));

                            // fire deprecated MachineStateEvent for backward compatibility with IDE 5.x
                            eventBus.fireEvent(new MachineStateEvent(new MachineEntityImpl(machineName, m), RUNNING));
                        });
                        break;
                    case STOPPED:
                        getMachineByName(machineName).ifPresent(m -> {
                            eventBus.fireEvent(new MachineStoppedEvent(m));

                            // fire deprecated MachineStateEvent for backward compatibility with IDE 5.x
                            eventBus.fireEvent(new MachineStateEvent(new MachineEntityImpl(machineName, m), DESTROYED));
                        });
                        break;
                    case FAILED:
                        getMachineByName(machineName).ifPresent(m -> {
                            eventBus.fireEvent(new MachineFailedEvent(m, event.getError()));

                            // fire deprecated MachineStateEvent for backward compatibility with IDE 5.x
                            eventBus.fireEvent(new MachineStateEvent(new MachineEntityImpl(machineName, m), DESTROYED));
                        });
                        break;
                }
            });
        };

        configurator.newConfiguration()
                    .methodName("machine/statusChanged")
                    .paramsAsDto(MachineStatusEvent.class)
                    .noResult()
                    .withBiConsumer(operation);
    }

