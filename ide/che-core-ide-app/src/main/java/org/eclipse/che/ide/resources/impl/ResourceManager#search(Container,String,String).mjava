    protected Promise<Resource[]> search(final Container container, String fileMask, String contentMask) {
        QueryExpression queryExpression = new QueryExpression();
        if (!isNullOrEmpty(contentMask)) {
            queryExpression.setText(contentMask + '*');
        }
        if (!isNullOrEmpty(fileMask)) {
            queryExpression.setName(fileMask);
        }
        if (!container.getLocation().isRoot()) {
            queryExpression.setPath(container.getLocation().toString());
        }

        return ps.search(queryExpression).thenPromise(new Function<List<ItemReference>, Promise<Resource[]>>() {
            @Override
            public Promise<Resource[]> apply(final List<ItemReference> references) throws FunctionException {
                if (references.isEmpty()) {
                    return promises.resolve(NO_RESOURCES);
                }

                int maxDepth = 0;

                final Path[] paths = new Path[references.size()];

                for (int i = 0; i < paths.length; i++) {
                    final Path path = Path.valueOf(references.get(i).getPath());
                    paths[i] = path;

                    if (path.segmentCount() > maxDepth) {
                        maxDepth = path.segmentCount();
                    }
                }

                return getRemoteResources(container, maxDepth, true).then(new Function<Resource[], Resource[]>() {
                    @Override
                    public Resource[] apply(Resource[] resources) throws FunctionException {

                        Resource[] filtered = NO_RESOURCES;
                        Path[] mutablePaths = paths;

                        outer:
                        for (Resource resource : resources) {
                            if (resource.getResourceType() != FILE) {
                                continue;
                            }

                            for (int i = 0; i < mutablePaths.length; i++) {
                                Path path = mutablePaths[i];

                                if (path.segmentCount() == resource.getLocation().segmentCount() && path.equals(resource.getLocation())) {
                                    Resource[] tmpFiltered = copyOf(filtered, filtered.length + 1);
                                    tmpFiltered[filtered.length] = resource;
                                    filtered = tmpFiltered;

                                    //reduce the size of mutablePaths by removing already checked item
                                    int size = mutablePaths.length;
                                    int numMoved = mutablePaths.length - i - 1;
                                    if (numMoved > 0) {
                                        arraycopy(mutablePaths, i + 1, mutablePaths, i, numMoved);
                                    }
                                    mutablePaths = copyOf(mutablePaths, --size);

                                    continue outer;
                                }
                            }
                        }

                        return filtered;
                    }
                });
            }
        });
    }

