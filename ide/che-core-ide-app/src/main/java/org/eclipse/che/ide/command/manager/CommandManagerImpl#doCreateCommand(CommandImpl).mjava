  /** Does the actual work for command creation. Doesn't notify listeners. */
  private Promise<CommandImpl> doCreateCommand(CommandImpl command) {
    final ApplicableContext context = command.getApplicableContext();
    if (!context.isWorkspaceApplicable() && context.getApplicableProjects().isEmpty()) {
      return promiseProvider.reject(
          new Exception("Command has to be applicable to the workspace or at least one project"));
    }

    final CommandImpl newCommand = new CommandImpl(command);
    newCommand.setName(commandNameGenerator.generate(command.getType(), command.getName()));

    final ArrayOf<Promise<?>> commandPromises = Collections.arrayOf();

    if (context.isWorkspaceApplicable()) {
      Promise<CommandImpl> p =
          workspaceCommandManager
              .createCommand(newCommand)
              .then(
                  (Function<Void, CommandImpl>)
                      aVoid -> {
                        newCommand.getApplicableContext().setWorkspaceApplicable(true);
                        return newCommand;
                      });

      commandPromises.push(p);
    }

    for (final String projectPath : context.getApplicableProjects()) {
      final Project project = getProjectByPath(projectPath);

      if (project == null) {
        continue;
      }

      Promise<CommandImpl> p =
          projectCommandManager
              .createCommand(project, newCommand)
              .then(
                  (Function<CommandImpl, CommandImpl>)
                      arg -> {
                        newCommand.getApplicableContext().addProject(projectPath);
                        return newCommand;
                      });

      commandPromises.push(p);
    }

    return promiseProvider
        .all2(commandPromises)
        .then(
            (Function<ArrayOf<?>, CommandImpl>)
                ignore -> {
                  commands.put(newCommand.getName(), newCommand);
                  return newCommand;
                });
  }

