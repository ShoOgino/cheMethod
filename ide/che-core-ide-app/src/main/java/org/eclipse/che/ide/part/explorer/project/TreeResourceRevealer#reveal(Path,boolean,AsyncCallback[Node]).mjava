  protected void reveal(final Path path, final boolean select, final AsyncCallback<Node> callback) {
    if (path == null) {
      callback.onFailure(new IllegalArgumentException("Invalid search path"));
    }

    Scheduler.get()
        .scheduleFixedDelay(
            new Scheduler.RepeatingCommand() {
              @Override
              public boolean execute() {
                if (tree.getNodeLoader().isBusy()) {
                  return true;
                }

                final Optional<ResourceNode> optRoot = getRootResourceNode(path);

                if (!optRoot.isPresent()) {
                  callback.onFailure(new IllegalStateException());
                  return false;
                }

                final ResourceNode root = optRoot.get();

                if (root.getData().getLocation().equals(path)) {
                  callback.onSuccess(root);
                  return false;
                }

                expandToPath(root, path, select)
                    .then(
                        new Operation<ResourceNode>() {
                          @Override
                          public void apply(ResourceNode node) throws OperationException {
                            callback.onSuccess(node);
                          }
                        })
                    .catchError(
                        new Operation<PromiseError>() {
                          @Override
                          public void apply(PromiseError arg) throws OperationException {
                            callback.onFailure(arg.getCause());
                          }
                        });

                return false;
              }
            },
            500);
  }

