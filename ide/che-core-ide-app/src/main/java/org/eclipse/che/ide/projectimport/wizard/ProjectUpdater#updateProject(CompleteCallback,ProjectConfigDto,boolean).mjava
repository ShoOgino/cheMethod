    /**
     * The method updates project and take resolution should project be configured or not.
     *
     * @param callback
     *         callback which is necessary to inform that resolving completed
     * @param projectConfig
     *         project which will be resolved
     * @param isConfigurationRequired
     *         special flag which defines will project be configured or not.<code>true</code> project will be configured,
     *         <code>false</code> project will not be configured
     */
    public void updateProject(@NotNull final CompleteCallback callback,
                              @NotNull ProjectConfigDto projectConfig,
                              final boolean isConfigurationRequired) {
        final String projectPath = projectConfig.getPath();

        projectService.updateProject(appContext.getDevMachine(),
                                     projectPath == null ? '/' + projectConfig.getName() : projectPath,
                                     projectConfig)
                      .then(new Operation<ProjectConfigDto>() {
                          @Override
                          public void apply(final ProjectConfigDto updated) throws OperationException {

                              //dirty hack. here we have to load from server new list of projects, because after project configuring
                              //they may appear, so we need to have actual projects configuration state, need to find better way to
                              //process it
                              projectService.getProjects(appContext.getDevMachine()).then(new Operation<List<ProjectConfigDto>>() {
                                  @Override
                                  public void apply(List<ProjectConfigDto> projects) throws OperationException {

                                      appContext.getWorkspace().getConfig().withProjects(projects);

                                      if (updated.getProblems().isEmpty() && !isConfigurationRequired) {
                                          eventBus.fireEvent(new CreateProjectEvent(updated));
                                          projectNotificationSubscriber.onSuccess();
                                          callback.onCompleted();
                                          return;
                                      }
                                      eventBus.fireEvent(new CreateProjectEvent(updated));
                                      eventBus.fireEvent(new ConfigureProjectEvent(updated));
                                      projectNotificationSubscriber.onSuccess();
                                      callback.onCompleted();
                                  }
                              }).catchError(new Operation<PromiseError>() {
                                  @Override
                                  public void apply(PromiseError arg) throws OperationException {
                                      projectNotificationSubscriber.onFailure(arg.getMessage());
                                      callback.onFailure(new Exception(arg.getMessage()));
                                  }
                              });
                          }
                      })
                      .catchError(new Operation<PromiseError>() {
                          @Override
                          public void apply(PromiseError arg) throws OperationException {
                              projectNotificationSubscriber.onFailure(arg.getMessage());
                              callback.onFailure(new Exception(arg.getMessage()));
                          }
                      });
    }

