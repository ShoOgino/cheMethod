  /**
   * Searches and highlights matchings in the given tree by pattern generated from entered search
   * request.
   *
   * @param tree the tree to search in
   * @param matchingStyle style of the matching
   * @param nodeConverter instance of the {@link NodeConverter}
   * @param filterNodes a flag that indicates if needed to remove nodes from the tree that doesn't
   *     match the search pattern
   */
  SpeedSearch(
      Tree tree,
      String matchingStyle,
      NodeConverter<Node, String> nodeConverter,
      boolean filterNodes) {
    this.tree = tree;
    this.filterNodes = filterNodes;
    this.searchRequest = new StringBuilder();
    this.searchRender = new SpeedSearchRender(tree.getTreeStyles(), matchingStyle);
    this.nodeConverter = nodeConverter != null ? nodeConverter : new NodeNameConverter();
    this.nodeStorage = tree.getNodeStorage();
    this.savedNodes = new ArrayList<>();
    this.filteredNodes = new ArrayList<>();
    this.tree.setPresentationRenderer(searchRender);
    this.tree.addKeyPressHandler(
        event -> {
          event.stopPropagation();
          searchRequest.append(String.valueOf(event.getCharCode()));
          update();
        });
    this.tree.addKeyDownHandler(
        event -> {
          switch (event.getNativeKeyCode()) {
            case KEY_ENTER:
              removeSearchPopUpFromTreeIfIsShown();
              break;
            case KEY_BACKSPACE:
              if (!searchRequest.toString().isEmpty()) {
                event.preventDefault();
                searchRequest.setLength(searchRequest.length() - 1);
                doSearch();
              }
              break;
            case KEY_ESCAPE:
              if (searchRequest.length() != 0) {
                event.stopPropagation();
                searchRequest.setLength(0);
                update();
              }
              break;
          }
        });
    this.tree.addExpandHandler(
        event -> {
          if (update) {
            savedNodes = new ArrayList<>(getVisibleNodes());
            if (getVisibleNodes()
                .stream()
                .filter(node -> !node.isLeaf())
                .allMatch(tree::isExpanded)) {
              update = false;
              doSearch();
            }
          } else {
            Node expandedNode = event.getNode();
            List<Node> visibleChildren = nodeStorage.getChildren(expandedNode);
            updateSavedNodes(expandedNode, visibleChildren);
            if (visibleChildren.size() != getFilteredChildren(expandedNode).size()) {
              visibleChildren
                  .stream()
                  .filter(node -> !matchesToSearchRequest().apply(node))
                  .forEach(nodeStorage::remove);
            }
          }
        });

    this.nodeStorage.addStoreClearHandler(event -> update = true);

    initSearchPopUp();
  }

