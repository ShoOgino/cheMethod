    /**
     * If shift is depressed, then we attempt to do a continuous range select. If
     * there exists one or more nodes in the selected nodes list, we test if the
     * node falls within the list. If it does not fall within, we connect the
     * contiguous range of nodes from the specified node to the nearest selected
     * node. If the node falls within the list, we do a continuous range selection
     * to the LAST node that was selected, not the closest.
     */
    private boolean shiftSelect(D nodeData) {

        // We are guaranteed to have at least one node in the list.
        D firstNode = selectedNodes.get(0);
        D lastNode = selectedNodes.get(selectedNodes.size() - 1);

        int comparisonToFirst = dataAdapter.compare(nodeData, firstNode);
        int comparisonToLast = dataAdapter.compare(nodeData, lastNode);

        // If it is to the left.
        if (comparisonToFirst < 0) {
            List<D> range = collectRangeToSelect(nodeData, firstNode, true, false);
            visuallySelect(range, true);
            selectedNodes.addAll(range);
            return true;
        }

        // If it is to the right.
        if (comparisonToLast > 0) {
            List<D> range = collectRangeToSelect(lastNode, nodeData, false, true);
            visuallySelect(range, true);
            selectedNodes.addAll(range);
            return true;
        }

        // If it is somewhere in between, or on the boundary.
        if (comparisonToFirst >= 0 && comparisonToLast <= 0) {

            // Clear the set of selected nodes.
            clearSelections();
            selectedNodes = collectRangeToSelect(nodeData, lastNode, true, true);
            visuallySelect(selectedNodes, true);
            return true;
        }

        assert false : "SelectionModel#shiftSelect(D): This should be unreachable!";

        return false;
    }

