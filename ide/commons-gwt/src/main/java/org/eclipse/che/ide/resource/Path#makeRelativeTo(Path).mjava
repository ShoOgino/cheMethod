  /**
   * Returns a path equivalent to this path, but relative to the given base path if possible.
   *
   * <p>The path is only made relative if the base path if both paths have the same device and have
   * a non-zero length common prefix. If the paths have different devices, or no common prefix, then
   * this path is simply returned. If the path is successfully made relative, then appending the
   * returned path to the base will always produce a path equal to this path.
   *
   * @param base The base path to make this path relative to
   * @return A path relative to the base path, or this path if it could not be made relative to the
   *     given base
   * @since 4.0.0-RC5
   */
  public Path makeRelativeTo(Path base) {
    // can't make relative if devices are not equal
    if (device != base.getDevice()
        && (device == null || !device.equalsIgnoreCase(base.getDevice()))) return this;
    int commonLength = matchingFirstSegments(base);
    final int differenceLength = base.segmentCount() - commonLength;
    final int newSegmentLength = differenceLength + segmentCount() - commonLength;
    if (newSegmentLength == 0) return Path.EMPTY;
    String[] newSegments = new String[newSegmentLength];
    // add parent references for each segment different from the base
    Arrays.fill(newSegments, 0, differenceLength, ".."); // $NON-NLS-1$
    // append the segments of this path not in common with the base
    System.arraycopy(
        segments, commonLength, newSegments, differenceLength, newSegmentLength - differenceLength);
    return new Path(null, newSegments, separators & HAS_TRAILING);
  }

