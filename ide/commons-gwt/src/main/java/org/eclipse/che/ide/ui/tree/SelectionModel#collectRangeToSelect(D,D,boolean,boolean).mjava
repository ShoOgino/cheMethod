    /**
     * Collects all nodes in a continuous range from the start node to the end
     * node (assuming that the nodes are peers) obeying the inclusion boolean
     * params for the boundaries. These nodes are not allowed to be in the
     * selected list.
     */
    private List<D> collectRangeToSelect(
            D startNode, D endNode, boolean includeStart, boolean includeEnd) {
        D parentNode = dataAdapter.getParent(startNode);

        // Do some debug compile sanity checking.
        assert (parentNode != null) : "Null parent node when doing range select!";
        assert (parentNode.equals(
                dataAdapter.getParent(endNode))) : "Different parent nodes when doing range highlight!";
        assert (dataAdapter.compare(startNode, endNode) <= 0) :
                "Nodes are in reverse order for range select! " + dataAdapter.getNodeName(startNode) + " - "
                + dataAdapter.getNodeName(endNode);

        List<D> range = new ArrayList<>();

        // Do a linear scan until we find the startNode.
        List<D> children = dataAdapter.getChildren(parentNode);
        int i = 0;
        boolean adding = false;
        for (int n = children.size(); i < n; i++) {
            D child = children.get(i);
            if (child.equals(startNode)) {
                adding = true;

                if (includeStart) {
                    range.add(child);
                }

                continue;
            }

            if (adding) {
                if (child.equals(endNode)) {
                    if (!includeEnd) {
                        break;
                    }

                    range.add(child);
                    break;
                }

                range.add(child);
            }
        }

        // Sanity check
        if (i == children.size()) {
//      Log.error(getClass(), "Failed to find the start when doing a range selection. Start:",
//          startNode, " End:", endNode);
        }

        return range;
    }

