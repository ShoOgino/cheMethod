    /**
     * Adds the specified node to the list of selected nodes. The list of selected
     * nodes is guaranteed to be sorted in the same direction that the nodes
     * appear in the tree. We only allow nodes to be in the selected list that are
     * peers in the tree (we do not allow selects to span multiple depths in the
     * tree.
     * <p/>
     * Behavior: If no modifier key is depressed, the list of selected nodes will
     * be set to contain just the node passed to this method.
     * <p/>
     * Shift select: If shift is depressed, then we attempt to do a continuous
     * range select. If there exists one or more nodes in the selected nodes list,
     * we test if the node falls within the list. If it does not fall within, we
     * connect the contiguous range of nodes from the specified node to the
     * nearest selected node. If the node falls within the list, we do a
     * continuous range selection to the LAST node that was selected, not the
     * closest.
     * <p/>
     * CTRL select: If CTRL is depressed then we simply search for the insertion
     * point of the specified node in the already sorted select list. If the node
     * is already present, then we remove it and unselect the node. If it was not
     * present, then we insert the node at the appropriate spot in the array and
     * select it.
     *
     * @param nodeData
     *         the node to select
     * @param event
     *         the DOM event that was associated with the select trigger.
     *         This is needed to detect modifier keys. If {@code null} then we
     *         assume that we are appending to the selection and behave just like a
     *         CTRL-click.
     * @return whether or not the select region changed at all.
     */
    public boolean selectNode(D nodeData, SignalEvent event) {
        if (selectedNodes.isEmpty()) {

            // There are no selected nodes. So we should select.
            insertAndSelectNode(nodeData, 0, true);
            return true;
        }

        // Ensure that the node we are selecting is a child of the same
        // directory of the other nodes.
        if (!hasSameParent(selectedNodes.get(0), nodeData)) {
            if (!this.multilevelSelection || event.getShiftKey()) {
                return selectSingleNode(nodeData);
            }
        }

        // So we are guaranteed to have a node that is a peer of the current set of
        // nodes. Now we must examine modifier keys.
        if (event == null || event.getCommandKey()) {
            ctrlSelect(nodeData);
            return true;
        } else {
            if (event.getShiftKey()) {
                return shiftSelect(nodeData);
            }
        }

        // Neither a shift nor a ctrl select. So replace the contents of the
        // selected list with this node.
        return selectSingleNode(nodeData);
    }

