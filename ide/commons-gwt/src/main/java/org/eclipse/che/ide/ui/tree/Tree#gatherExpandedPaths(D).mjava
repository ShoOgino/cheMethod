  /**
   * Walks the tree rooted at the specified renderedNode and gathers a list of paths that correspond
   * to nodes that have been expanded below the specified rendered node. All paths are expressed as
   * root relative.
   *
   * <p>These paths correspond to "expansion leaves". Which are effectively nodes whose children are
   * all leaves, or are all collapsed. That is, nodes whose children all answer false to {@link
   * TreeNodeElement#isOpen()}.
   */
  private List<List<String>> gatherExpandedPaths(D rootData) {
    final List<List<String>> expandedPaths = new ArrayList<>();

    // Can't gather the expansion state for a null parent.
    if (rootData == null) {
      return expandedPaths;
    }

    iterateDfs(
        rootData,
        getModel().dataAdapter,
        new Visitor<D>() {

          @Override
          public boolean shouldVisit(D node) {
            // If a child node is open, it means that it has been expanded and its
            // children should have rendered nodes.
            TreeNodeElement<D> renderedChild = getModel().dataAdapter.getRenderedTreeNode(node);
            return (renderedChild != null) && renderedChild.isOpen();
          }

          @Override
          public void visit(D node, boolean willVisitChildren) {
            if (!willVisitChildren) {
              // This node is an expansion leaf. Accumulate the path.
              expandedPaths.add(getModel().dataAdapter.getNodePath(node));
            }
          }
        });

    return expandedPaths;
  }

