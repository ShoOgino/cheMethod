  public CompletableFuture<InitializeResult> initialize(InitializeParams params) {
    boolean mustInit = false;
    synchronized (launchLock) {
      if (state == State.LAUNCHED) {
        state = State.INITIALIZING;
        mustInit = true;
        launchLock.notifyAll();
      } else if (state < State.INITIALIZING) {
        throw new IllegalStateException("Called init when not launched");
      }
    }

    long threadId = Thread.currentThread().getId();
    if (mustInit) {
      LOG.info("initializing language server  on thread {} for {}", threadId, params.getRootUri());
      params.setRootUri("file:///projects");
      params.setRootPath("/projects");
      CompletableFuture<InitializeResult> res = new CompletableFuture<>();
      languageServer
          .initialize(params)
          .thenApply(
              (result) -> {
                LOG.info(
                    "initialized language server on thread {} for {}",
                    threadId,
                    params.getRootUri());
                synchronized (launchLock) {
                  initResult = result;
                  state = State.INITIALIZED;
                  launchLock.notifyAll();
                }
                return res.complete(result);
              })
          .exceptionally(
              (e) -> {
                LOG.debug(
                    "failed to initialize language server on thread {} for {}",
                    threadId,
                    params.getRootUri());
                synchronized (launchLock) {
                  state = State.LAUNCHED;
                  launchLock.notifyAll();
                }
                res.completeExceptionally(e);
                return null;
              });
      return res;
    } else {
      LOG.info(
          "already initialized language server on thread {} for {}", threadId, params.getRootUri());

      CompletableFuture<InitializeResult> res = new CompletableFuture<>();
      CompletableFuture.runAsync(
          () -> {
            try {
              synchronized (launchLock) {
                while (state == State.INITIALIZING) {
                  LOG.debug(
                      "waiting for language server init on thread {} for {}",
                      threadId,
                      params.getRootUri());
                  launchLock.wait();
                }
                if (state > State.INITIALIZING) {
                  LOG.info("completing init on thread {} for {}", threadId, params.getRootUri());
                  res.complete(initResult);
                } else {
                  LOG.debug(
                      "recursively calling init on thread {} for {}",
                      threadId,
                      params.getRootUri());
                  CompletableFuture<Void> f =
                      initialize(params)
                          .thenAccept(
                              (result) -> {
                                res.complete(result);
                              });
                  f.exceptionally(
                      (e) -> {
                        LOG.debug(
                            "failed recursively calling init on thread {} for {}",
                            threadId,
                            params.getRootUri());
                        res.completeExceptionally(e);
                        return null;
                      });
                }
              }
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
              res.completeExceptionally(e);
            }
          });
      return res;
    }
  }

