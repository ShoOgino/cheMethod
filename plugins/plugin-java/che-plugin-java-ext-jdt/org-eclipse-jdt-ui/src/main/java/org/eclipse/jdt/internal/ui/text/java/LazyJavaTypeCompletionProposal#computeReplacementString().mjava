    /*
     * @see org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal#computeReplacementString()
     */
    @Override
    protected String computeReplacementString() {
        String replacement = super.computeReplacementString();

		/* No import rewriting ever from within the import section. */
        if (isImportCompletion())
            return replacement;

		/* Always use the simple name for non-formal javadoc references to types. */
        // TODO fix
        if (fProposal.getKind() == CompletionProposal.TYPE_REF && fInvocationContext.getCoreContext().isInJavadocText())
            return getSimpleTypeName();

        String qualifiedTypeName = getQualifiedTypeName();

        // Type in package info must be fully qualified.
        if (fCompilationUnit != null && JavaModelUtil.isPackageInfo(fCompilationUnit))
            return qualifiedTypeName;

        if (qualifiedTypeName.indexOf('.') == -1 && replacement.length() > 0)
            // default package - no imports needed
            return qualifiedTypeName;

 		/*
		 * If the user types in the qualification, don't force import rewriting on him - insert the
		 * qualified name.
		 */
        IDocument document = fInvocationContext.getDocument();
        if (document != null) {
            String prefix = getPrefix(document, getReplacementOffset() + getReplacementLength());
            int dotIndex = prefix.lastIndexOf('.');
            // match up to the last dot in order to make higher level matching still work (camel case...)
			if (dotIndex != -1 && qualifiedTypeName.toLowerCase().startsWith(prefix.substring(0, dotIndex + 1).toLowerCase()))
				return qualifiedTypeName;
		}

		/*
		 * The replacement does not contain a qualification (e.g. an inner type qualified by its
		 * parent) - use the replacement directly.
		 */
		if (replacement.indexOf('.') == -1) {
			if (isInJavadoc())
				return getSimpleTypeName(); // don't use the braces added for javadoc link proposals
			return replacement;
		}

		/* Add imports if the preference is on. */
		if (fImportRewrite == null)
			fImportRewrite= createImportRewrite();
		if (fImportRewrite != null) {
			return fImportRewrite.addImport(qualifiedTypeName, fImportContext);
		}

		// fall back for the case we don't have an import rewrite (see allowAddingImports)

		/* No imports for implicit imports. */
		if (fCompilationUnit != null && JavaModelUtil.isImplicitImport(Signature.getQualifier(qualifiedTypeName), fCompilationUnit)) {
			return Signature.getSimpleName(qualifiedTypeName);
		}

		/* Default: use the fully qualified type name. */
		return qualifiedTypeName;
	}

