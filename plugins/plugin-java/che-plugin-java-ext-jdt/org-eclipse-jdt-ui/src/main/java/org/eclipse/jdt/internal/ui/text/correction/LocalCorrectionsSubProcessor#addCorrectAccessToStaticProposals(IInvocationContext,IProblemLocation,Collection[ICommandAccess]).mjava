  /*
   * Fix instance accesses and indirect (static) accesses to static fields/methods
   */
  public static void addCorrectAccessToStaticProposals(
      IInvocationContext context, IProblemLocation problem, Collection<ICommandAccess> proposals)
      throws CoreException {
    IProposableFix fix =
        CodeStyleFix.createIndirectAccessToStaticFix(context.getASTRoot(), problem);
    if (fix != null) {
      Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_CHANGE);
      Map<String, String> options = new HashMap<String, String>();
      options.put(
          CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS,
          CleanUpOptions.TRUE);
      options.put(
          CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS_SUBTYPE_ACCESS,
          CleanUpOptions.TRUE);
      FixCorrectionProposal proposal =
          new FixCorrectionProposal(
              fix,
              new CodeStyleCleanUp(options),
              IProposalRelevance.CREATE_INDIRECT_ACCESS_TO_STATIC,
              image,
              context);
      proposal.setCommandId(ADD_STATIC_ACCESS_ID);
      proposals.add(proposal);
      return;
    }

    IProposableFix[] fixes = CodeStyleFix.createNonStaticAccessFixes(context.getASTRoot(), problem);
    if (fixes != null) {
      IProposableFix fix1 = fixes[0];
      Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_CHANGE);
      Map<String, String> options = new HashMap<String, String>();
      options.put(
          CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS,
          CleanUpOptions.TRUE);
      options.put(
          CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS_INSTANCE_ACCESS,
          CleanUpOptions.TRUE);
      FixCorrectionProposal proposal =
          new FixCorrectionProposal(
              fix1,
              new CodeStyleCleanUp(options),
              IProposalRelevance.CREATE_NON_STATIC_ACCESS_USING_DECLARING_TYPE,
              image,
              context);
      proposal.setCommandId(ADD_STATIC_ACCESS_ID);
      proposals.add(proposal);

      if (fixes.length > 1) {
        Map<String, String> options1 = new HashMap<String, String>();
        options1.put(
            CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS,
            CleanUpOptions.TRUE);
        options1.put(
            CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS_SUBTYPE_ACCESS,
            CleanUpOptions.TRUE);
        options1.put(
            CleanUpConstants.MEMBER_ACCESSES_STATIC_QUALIFY_WITH_DECLARING_CLASS_INSTANCE_ACCESS,
            CleanUpOptions.TRUE);
        IProposableFix fix2 = fixes[1];
        proposal =
            new FixCorrectionProposal(
                fix2,
                new CodeStyleCleanUp(options),
                IProposalRelevance.CREATE_NON_STATIC_ACCESS_USING_INSTANCE_TYPE,
                image,
                context);
        proposals.add(proposal);
      }
    }
    ModifierCorrectionSubProcessor.addNonAccessibleReferenceProposal(
        context,
        problem,
        proposals,
        ModifierCorrectionSubProcessor.TO_NON_STATIC,
        IProposalRelevance.REMOVE_STATIC_MODIFIER);
  }

