  public static void addTypeMismatchProposals(
      IInvocationContext context, IProblemLocation problem, Collection<ICommandAccess> proposals)
      throws CoreException {
    String[] args = problem.getProblemArguments();
    if (args.length != 2) {
      return;
    }

    ICompilationUnit cu = context.getCompilationUnit();

    CompilationUnit astRoot = context.getASTRoot();
    AST ast = astRoot.getAST();

    ASTNode selectedNode = problem.getCoveredNode(astRoot);
    if (!(selectedNode instanceof Expression)) {
      return;
    }
    Expression nodeToCast = (Expression) selectedNode;
    Name receiverNode = null;
    ITypeBinding castTypeBinding = null;

    int parentNodeType = selectedNode.getParent().getNodeType();
    if (parentNodeType == ASTNode.ASSIGNMENT) {
      Assignment assign = (Assignment) selectedNode.getParent();
      Expression leftHandSide = assign.getLeftHandSide();
      if (selectedNode.equals(leftHandSide)) {
        nodeToCast = assign.getRightHandSide();
      }
      castTypeBinding = assign.getLeftHandSide().resolveTypeBinding();
      if (leftHandSide instanceof Name) {
        receiverNode = (Name) leftHandSide;
      } else if (leftHandSide instanceof FieldAccess) {
        receiverNode = ((FieldAccess) leftHandSide).getName();
      }
    } else if (parentNodeType == ASTNode.VARIABLE_DECLARATION_FRAGMENT) {
      VariableDeclarationFragment frag = (VariableDeclarationFragment) selectedNode.getParent();
      if (selectedNode.equals(frag.getName()) || selectedNode.equals(frag.getInitializer())) {
        nodeToCast = frag.getInitializer();
        castTypeBinding = ASTNodes.getType(frag).resolveBinding();
        receiverNode = frag.getName();
      }
    } else if (parentNodeType == ASTNode.MEMBER_VALUE_PAIR) {
      receiverNode = ((MemberValuePair) selectedNode.getParent()).getName();
      castTypeBinding = ASTResolving.guessBindingForReference(nodeToCast);
    } else if (parentNodeType == ASTNode.SINGLE_MEMBER_ANNOTATION) {
      receiverNode =
          ((SingleMemberAnnotation) selectedNode.getParent()).getTypeName(); // use the type name
      castTypeBinding = ASTResolving.guessBindingForReference(nodeToCast);
    } else {
      // try to find the binding corresponding to 'castTypeName'
      castTypeBinding = ASTResolving.guessBindingForReference(nodeToCast);
    }
    if (castTypeBinding == null) {
      return;
    }

    ITypeBinding currBinding = nodeToCast.resolveTypeBinding();

    if (!(nodeToCast instanceof ArrayInitializer)) {
      ITypeBinding castFixType = null;
      if (currBinding == null
          || castTypeBinding.isCastCompatible(currBinding)
          || nodeToCast instanceof CastExpression) {
        castFixType = castTypeBinding;
      } else if (JavaModelUtil.is50OrHigher(cu.getJavaProject())) {
        ITypeBinding boxUnboxedTypeBinding = boxUnboxPrimitives(castTypeBinding, currBinding, ast);
        if (boxUnboxedTypeBinding != castTypeBinding
            && boxUnboxedTypeBinding.isCastCompatible(currBinding)) {
          castFixType = boxUnboxedTypeBinding;
        }
      }
      if (castFixType != null) {
        proposals.add(
            createCastProposal(context, castFixType, nodeToCast, IProposalRelevance.CREATE_CAST));
      }
    }

    boolean nullOrVoid = currBinding == null || "void".equals(currBinding.getName()); // $NON-NLS-1$

    // change method return statement to actual type
    if (!nullOrVoid && parentNodeType == ASTNode.RETURN_STATEMENT) {
      BodyDeclaration decl = ASTResolving.findParentBodyDeclaration(selectedNode);
      if (decl instanceof MethodDeclaration) {
        MethodDeclaration methodDeclaration = (MethodDeclaration) decl;

        currBinding = Bindings.normalizeTypeBinding(currBinding);
        if (currBinding == null) {
          currBinding = ast.resolveWellKnownType("java.lang.Object"); // $NON-NLS-1$
        }
        if (currBinding.isWildcardType()) {
          currBinding = ASTResolving.normalizeWildcardType(currBinding, true, ast);
        }

        ASTRewrite rewrite = ASTRewrite.create(ast);

        String label =
            Messages.format(
                CorrectionMessages.TypeMismatchSubProcessor_changereturntype_description,
                BasicElementLabels.getJavaElementName(currBinding.getName()));
        Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_CHANGE);
        LinkedCorrectionProposal proposal =
            new LinkedCorrectionProposal(
                label, cu, rewrite, IProposalRelevance.CHANGE_METHOD_RETURN_TYPE, image);

        ImportRewrite imports = proposal.createImportRewrite(astRoot);
        ImportRewriteContext importRewriteContext =
            new ContextSensitiveImportRewriteContext(decl, imports);

        Type newReturnType = imports.addImport(currBinding, ast, importRewriteContext);
        rewrite.replace(methodDeclaration.getReturnType2(), newReturnType, null);

        String returnKey = "return"; // $NON-NLS-1$
        proposal.addLinkedPosition(rewrite.track(newReturnType), true, returnKey);
        ITypeBinding[] typeSuggestions = ASTResolving.getRelaxingTypes(ast, currBinding);
        for (int i = 0; i < typeSuggestions.length; i++) {
          proposal.addLinkedPositionProposal(returnKey, typeSuggestions[i]);
        }
        proposals.add(proposal);
      }
    }

    if (!nullOrVoid && receiverNode != null) {
      currBinding = Bindings.normalizeTypeBinding(currBinding);
      if (currBinding == null) {
        currBinding = ast.resolveWellKnownType("java.lang.Object"); // $NON-NLS-1$
      }
      if (currBinding.isWildcardType()) {
        currBinding = ASTResolving.normalizeWildcardType(currBinding, true, ast);
      }
      addChangeSenderTypeProposals(
          context,
          receiverNode,
          currBinding,
          true,
          IProposalRelevance.CHANGE_TYPE_OF_RECEIVER_NODE,
          proposals);
    }

    addChangeSenderTypeProposals(
        context,
        nodeToCast,
        castTypeBinding,
        false,
        IProposalRelevance.CHANGE_TYPE_OF_NODE_TO_CAST,
        proposals);

    if (castTypeBinding == ast.resolveWellKnownType("boolean")
        && currBinding != null
        && !currBinding.isPrimitive()
        && !Bindings.isVoidType(currBinding)) { // $NON-NLS-1$
      String label = CorrectionMessages.TypeMismatchSubProcessor_insertnullcheck_description;
      Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_CHANGE);
      ASTRewrite rewrite = ASTRewrite.create(astRoot.getAST());

      InfixExpression expression = ast.newInfixExpression();
      expression.setLeftOperand((Expression) rewrite.createMoveTarget(nodeToCast));
      expression.setRightOperand(ast.newNullLiteral());
      expression.setOperator(InfixExpression.Operator.NOT_EQUALS);
      rewrite.replace(nodeToCast, expression, null);

      proposals.add(
          new ASTRewriteCorrectionProposal(
              label,
              context.getCompilationUnit(),
              rewrite,
              IProposalRelevance.INSERT_NULL_CHECK,
              image));
    }
  }

