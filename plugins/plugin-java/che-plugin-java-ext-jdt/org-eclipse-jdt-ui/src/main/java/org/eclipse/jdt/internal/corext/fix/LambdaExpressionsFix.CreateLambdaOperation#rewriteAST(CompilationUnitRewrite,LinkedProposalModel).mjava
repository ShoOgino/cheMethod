    /** {@inheritDoc} */
    @Override
    public void rewriteAST(CompilationUnitRewrite cuRewrite, LinkedProposalModel model)
        throws CoreException {

      ASTRewrite rewrite = cuRewrite.getASTRewrite();
      ImportRemover importRemover = cuRewrite.getImportRemover();
      AST ast = rewrite.getAST();

      HashMap<ClassInstanceCreation, HashSet<String>> cicToNewNames =
          new HashMap<ClassInstanceCreation, HashSet<String>>();
      for (int i = 0; i < fExpressions.size(); i++) {
        ClassInstanceCreation classInstanceCreation = fExpressions.get(i);
        TextEditGroup group =
            createTextEditGroup(
                FixMessages.LambdaExpressionsFix_convert_to_lambda_expression, cuRewrite);

        AnonymousClassDeclaration anonymTypeDecl =
            classInstanceCreation.getAnonymousClassDeclaration();
        List<BodyDeclaration> bodyDeclarations = anonymTypeDecl.bodyDeclarations();

        Object object = bodyDeclarations.get(0);
        if (!(object instanceof MethodDeclaration)) continue;
        MethodDeclaration methodDeclaration = (MethodDeclaration) object;
        HashSet<String> excludedNames = new HashSet<String>();
        if (i != 0) {
          for (ClassInstanceCreation convertedCic : fExpressions.subList(0, i)) {
            if (ASTNodes.isParent(classInstanceCreation, convertedCic)) {
              excludedNames.addAll(cicToNewNames.get(convertedCic));
            }
          }
        }
        HashSet<String> newNames =
            makeNamesUnique(excludedNames, methodDeclaration, rewrite, group);
        cicToNewNames.put(classInstanceCreation, new HashSet<String>(newNames));
        List<SingleVariableDeclaration> methodParameters = methodDeclaration.parameters();

        // use short form with inferred parameter types and without parentheses if possible
        LambdaExpression lambdaExpression = ast.newLambdaExpression();
        List<VariableDeclaration> lambdaParameters = lambdaExpression.parameters();
        lambdaExpression.setParentheses(methodParameters.size() != 1);
        for (SingleVariableDeclaration methodParameter : methodParameters) {
          VariableDeclarationFragment lambdaParameter = ast.newVariableDeclarationFragment();
          lambdaParameter.setName((SimpleName) rewrite.createCopyTarget(methodParameter.getName()));
          lambdaParameters.add(lambdaParameter);
        }

        Block body = methodDeclaration.getBody();
        List<Statement> statements = body.statements();
        ASTNode lambdaBody = body;
        if (statements.size() == 1) {
          // use short form with just an expression body if possible
          Statement statement = statements.get(0);
          if (statement instanceof ExpressionStatement) {
            lambdaBody = ((ExpressionStatement) statement).getExpression();
          } else if (statement instanceof ReturnStatement) {
            Expression returnExpression = ((ReturnStatement) statement).getExpression();
            if (returnExpression != null) {
              lambdaBody = returnExpression;
            }
          }
        }
        //TODO: Bug 421479: [1.8][clean up][quick assist] convert anonymous to lambda must consider lost scope of interface
        //				lambdaBody.accept(new InterfaceAccessQualifier(rewrite, classInstanceCreation.getType().resolveBinding())); //TODO: maybe
        // need a separate ASTRewrite and string placeholder

        lambdaExpression.setBody(rewrite.createCopyTarget(lambdaBody));
        Expression replacement = lambdaExpression;
        if (ASTNodes.isTargetAmbiguous(classInstanceCreation, lambdaParameters.isEmpty())) {
          CastExpression cast = ast.newCastExpression();
          cast.setExpression(lambdaExpression);
          ImportRewrite importRewrite = cuRewrite.getImportRewrite();
          ImportRewriteContext importRewriteContext =
              new ContextSensitiveImportRewriteContext(classInstanceCreation, importRewrite);
          Type castType =
              importRewrite.addImport(
                  classInstanceCreation.getType().resolveBinding(), ast, importRewriteContext);
          cast.setType(castType);
          importRemover.registerAddedImports(castType);
          replacement = cast;
        }
        rewrite.replace(classInstanceCreation, replacement, group);

        importRemover.registerRemovedNode(classInstanceCreation);
        importRemover.registerRetainedNode(lambdaBody);
      }
    }

