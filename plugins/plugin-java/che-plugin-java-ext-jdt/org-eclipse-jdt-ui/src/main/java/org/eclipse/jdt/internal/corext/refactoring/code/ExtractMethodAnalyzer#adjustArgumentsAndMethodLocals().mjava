  private void adjustArgumentsAndMethodLocals() {
    for (int i = 0; i < fArguments.length; i++) {
      IVariableBinding argument = fArguments[i];
      // Both arguments and locals consider FlowInfo.WRITE_POTENTIAL. But at the end a variable
      // can either be a local of an argument. Fix this based on the compute return type which
      // didn't exist when we computed the locals and arguments (see computeInput())
      if (fInputFlowInfo.hasAccessMode(fInputFlowContext, argument, FlowInfo.WRITE_POTENTIAL)) {
        if (argument != fReturnValue) fArguments[i] = null;
        // We didn't remove the argument. So we have to remove the local declaration
        if (fArguments[i] != null) {
          for (int l = 0; l < fMethodLocals.length; l++) {
            if (fMethodLocals[l] == argument) fMethodLocals[l] = null;
          }
        }
      }
    }
  }

