	/*
	 * @see org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer#computeCompletionProposals(org.eclipse.jface.text.contentassist.TextContentAssistInvocationContext, org.eclipse.core.runtime.IProgressMonitor)
	 */
	@Override
	public List<ICompletionProposal> computeCompletionProposals(ContentAssistInvocationContext context, IProgressMonitor monitor) {
		List<ICompletionProposal> types= super.computeCompletionProposals(context, monitor);

		if (!(context instanceof JavaContentAssistInvocationContext))
			return types;

		JavaContentAssistInvocationContext javaContext= (JavaContentAssistInvocationContext) context;
		CompletionContext coreContext= javaContext.getCoreContext();
		if (coreContext != null && coreContext.getTokenLocation() != CompletionContext.TL_CONSTRUCTOR_START)
			return types;

		try {
			if (types.size() > 0 && context.computeIdentifierPrefix().length() == 0) {
				IType expectedType= javaContext.getExpectedType();
				if (expectedType != null) {
					// empty prefix completion - insert LRU types if known, but prune if they already occur in the core list

					// compute minmimum relevance and already proposed list
					int relevance= Integer.MAX_VALUE;
					Set<String> proposed= new HashSet<String>();
					for (Iterator<ICompletionProposal> it= types.iterator(); it.hasNext();) {
						AbstractJavaCompletionProposal p= (AbstractJavaCompletionProposal) it.next();
						IJavaElement element= p.getJavaElement();
						if (element instanceof IType)
							proposed.add(((IType) element).getFullyQualifiedName());
						relevance= Math.min(relevance, p.getRelevance());
					}

					// insert history types
					List<String> history= JavaPlugin.getDefault().getContentAssistHistory().getHistory(expectedType.getFullyQualifiedName()).getTypes();
					relevance-= history.size() + 1;
					for (Iterator<String> it= history.iterator(); it.hasNext();) {
						String type= it.next();
						if (proposed.contains(type))
							continue;

						IJavaCompletionProposal proposal= createTypeProposal(relevance, type, javaContext);

						if (proposal != null)
							types.add(proposal);
						relevance++;
					}
				}
			}
		} catch (BadLocationException x) {
			// log & ignore
			JavaPlugin.log(x);
		} catch (JavaModelException x) {
			// log & ignore
			JavaPlugin.log(x);
		}

		return types;
	}

