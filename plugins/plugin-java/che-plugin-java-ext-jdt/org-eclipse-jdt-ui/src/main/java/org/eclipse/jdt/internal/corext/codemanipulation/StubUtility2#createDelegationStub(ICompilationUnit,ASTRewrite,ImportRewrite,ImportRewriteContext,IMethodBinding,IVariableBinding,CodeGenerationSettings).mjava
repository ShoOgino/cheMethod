  public static MethodDeclaration createDelegationStub(
      ICompilationUnit unit,
      ASTRewrite rewrite,
      ImportRewrite imports,
      ImportRewriteContext context,
      IMethodBinding delegate,
      IVariableBinding delegatingField,
      CodeGenerationSettings settings)
      throws CoreException {
    Assert.isNotNull(delegate);
    Assert.isNotNull(delegatingField);
    Assert.isNotNull(settings);

    AST ast = rewrite.getAST();

    MethodDeclaration decl = ast.newMethodDeclaration();
    decl.modifiers()
        .addAll(
            ASTNodeFactory.newModifiers(
                ast,
                delegate.getModifiers()
                    & ~Modifier.SYNCHRONIZED
                    & ~Modifier.ABSTRACT
                    & ~Modifier.NATIVE));

    decl.setName(ast.newSimpleName(delegate.getName()));
    decl.setConstructor(false);

    createTypeParameters(imports, context, ast, delegate, decl);

    decl.setReturnType2(imports.addImport(delegate.getReturnType(), ast, context));

    List<SingleVariableDeclaration> params =
        createParameters(unit.getJavaProject(), imports, context, ast, delegate, null, decl);

    createThrownExceptions(decl, delegate, imports, context, ast);

    Block body = ast.newBlock();
    decl.setBody(body);

    String delimiter = StubUtility.getLineDelimiterUsed(unit);

    Statement statement = null;
    MethodInvocation invocation = ast.newMethodInvocation();
    invocation.setName(ast.newSimpleName(delegate.getName()));
    List<Expression> arguments = invocation.arguments();
    for (int i = 0; i < params.size(); i++)
      arguments.add(ast.newSimpleName(params.get(i).getName().getIdentifier()));
    if (settings.useKeywordThis) {
      FieldAccess access = ast.newFieldAccess();
      access.setExpression(ast.newThisExpression());
      access.setName(ast.newSimpleName(delegatingField.getName()));
      invocation.setExpression(access);
    } else invocation.setExpression(ast.newSimpleName(delegatingField.getName()));
    if (delegate.getReturnType().isPrimitive()
        && delegate.getReturnType().getName().equals("void")) { // $NON-NLS-1$
      statement = ast.newExpressionStatement(invocation);
    } else {
      ReturnStatement returnStatement = ast.newReturnStatement();
      returnStatement.setExpression(invocation);
      statement = returnStatement;
    }
    body.statements().add(statement);

    ITypeBinding declaringType = delegatingField.getDeclaringClass();
    if (declaringType == null) { // can be null for
      return decl;
    }

    String qualifiedName = declaringType.getQualifiedName();
    IPackageBinding packageBinding = declaringType.getPackage();
    if (packageBinding != null) {
      if (packageBinding.getName().length() > 0
          && qualifiedName.startsWith(packageBinding.getName()))
        qualifiedName = qualifiedName.substring(packageBinding.getName().length());
    }

    if (settings.createComments) {
      /*
       * TODO: have API for delegate method comments This is an inlined
       * version of
       * {@link CodeGeneration#getMethodComment(ICompilationUnit, String, MethodDeclaration, IMethodBinding, String)}
       */
      delegate = delegate.getMethodDeclaration();
      String declaringClassQualifiedName = delegate.getDeclaringClass().getQualifiedName();
      String linkToMethodName = delegate.getName();
      String[] parameterTypesQualifiedNames = StubUtility.getParameterTypeNamesForSeeTag(delegate);
      String string =
          StubUtility.getMethodComment(
              unit,
              qualifiedName,
              decl,
              delegate.isDeprecated(),
              linkToMethodName,
              declaringClassQualifiedName,
              parameterTypesQualifiedNames,
              true,
              delimiter);
      if (string != null) {
        Javadoc javadoc = (Javadoc) rewrite.createStringPlaceholder(string, ASTNode.JAVADOC);
        decl.setJavadoc(javadoc);
      }
    }
    return decl;
  }

