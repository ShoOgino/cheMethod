    private RefactoringStatus checkReturnTypeSyntax() {
      String newTypeName = fReturnTypeInfo.getNewTypeName();
      if ("".equals(newTypeName.trim())) { //$NON-NLS-1$
        String msg = RefactoringCoreMessages.TypeContextChecker_return_type_not_empty;
        return RefactoringStatus.createFatalErrorStatus(msg);
      }
      List<String> problemsCollector = new ArrayList<String>(0);
      Type parsedType = parseType(newTypeName, fMethod.getJavaProject(), problemsCollector);
      if (parsedType == null) {
        String msg =
            Messages.format(
                RefactoringCoreMessages.TypeContextChecker_invalid_return_type,
                BasicElementLabels.getJavaElementName(newTypeName));
        return RefactoringStatus.createFatalErrorStatus(msg);
      }
      if (problemsCollector.size() == 0) return null;

      RefactoringStatus result = new RefactoringStatus();
      for (Iterator<String> iter = problemsCollector.iterator(); iter.hasNext(); ) {
        String[] keys =
            new String[] {
              BasicElementLabels.getJavaElementName(newTypeName),
              BasicElementLabels.getJavaElementName(iter.next())
            };
        String msg =
            Messages.format(
                RefactoringCoreMessages.TypeContextChecker_invalid_return_type_syntax, keys);
        result.addError(msg);
      }
      return result;
    }

