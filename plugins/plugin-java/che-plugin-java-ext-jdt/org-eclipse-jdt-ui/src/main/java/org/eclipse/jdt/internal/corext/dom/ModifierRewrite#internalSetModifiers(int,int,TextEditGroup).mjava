	/**
	 * Sets the given modifiers and removes all other modifiers that match the consideredFlags mask.
	 * Does not touch other flags and leaves annotations in place.
	 *
	 * @param modifiers the modifiers to set
	 * @param consideredFlags mask of modifiers to consider
	 * @param editGroup the edit group in which to collect the corresponding text edits, or
	 *            <code>null</code> if ungrouped
	 * @return a tracked position that contains the changed modifiers
	 */
	private PositionInformation internalSetModifiers(int modifiers, int consideredFlags, TextEditGroup editGroup) {
		int newModifiers= modifiers & consideredFlags;

		ITrackedNodePosition trackedFallback= null;
		List<ITrackedNodePosition> trackedNodes= new ArrayList<ITrackedNodePosition>();

		// remove modifiers
		List<IExtendedModifier> originalList= fModifierRewrite.getOriginalList();
		for (int i= 0; i < originalList.size(); i++) {
			ASTNode curr= (ASTNode) originalList.get(i);
			if (curr instanceof Modifier) {
				int flag= ((Modifier)curr).getKeyword().toFlagValue();
				if ((consideredFlags & flag) != 0) {
					if ((newModifiers & flag) == 0) {
						fModifierRewrite.remove(curr, editGroup);
						if (trackedFallback == null)
							trackedFallback= fModifierRewrite.getASTRewrite().track(curr);
					}
					newModifiers &= ~flag;
				}
			}
		}

		// find last annotation
		IExtendedModifier lastAnnotation= null;
		List<IExtendedModifier> extendedList= fModifierRewrite.getRewrittenList();
		for (int i= 0; i < extendedList.size(); i++) {
			IExtendedModifier curr= extendedList.get(i);
			if (curr.isAnnotation())
				lastAnnotation= curr;
		}

		// add modifiers
		List<Modifier> newNodes= ASTNodeFactory.newModifiers(fAst, newModifiers);
		for (int i= 0; i < newNodes.size(); i++) {
			Modifier curr= newNodes.get(i);
			if ((curr.getKeyword().toFlagValue() & VISIBILITY_MODIFIERS) != 0) {
				if (lastAnnotation != null)
					fModifierRewrite.insertAfter(curr, (ASTNode) lastAnnotation, editGroup);
				else
					fModifierRewrite.insertFirst(curr, editGroup);
			} else {
				fModifierRewrite.insertLast(curr, editGroup);
			}
			trackedNodes.add(fModifierRewrite.getASTRewrite().track(curr));
		}

		if (trackedNodes.isEmpty()) {
			if (trackedFallback == null) {
				// out of tricks...
				trackedFallback= fModifierRewrite.getASTRewrite().track(fModifierRewrite.getParent());
			}
			return new LinkedProposalPositionGroup.StartPositionInformation(trackedFallback);
		} else {
			return new LinkedProposalPositionGroup.TrackedNodesPosition(trackedNodes);
		}
	}

