  private static int internalGetPossibleTypeKinds(ASTNode node) {
    int kind = SimilarElementsRequestor.ALL_TYPES;

    int mask = SimilarElementsRequestor.ALL_TYPES | SimilarElementsRequestor.VOIDTYPE;

    ASTNode parent = node.getParent();
    while (parent instanceof QualifiedName) {
      if (node.getLocationInParent() == QualifiedName.QUALIFIER_PROPERTY) {
        return SimilarElementsRequestor.REF_TYPES;
      }
      node = parent;
      parent = parent.getParent();
      mask = SimilarElementsRequestor.REF_TYPES;
    }
    while (parent instanceof Type) {
      if (parent instanceof QualifiedType) {
        if (node.getLocationInParent() == QualifiedType.QUALIFIER_PROPERTY) {
          return mask & (SimilarElementsRequestor.REF_TYPES);
        }
        mask &= SimilarElementsRequestor.REF_TYPES;
      } else if (parent instanceof NameQualifiedType) {
        if (node.getLocationInParent() == NameQualifiedType.QUALIFIER_PROPERTY) {
          return mask & (SimilarElementsRequestor.REF_TYPES);
        }
        mask &= SimilarElementsRequestor.REF_TYPES;
      } else if (parent instanceof ParameterizedType) {
        if (node.getLocationInParent() == ParameterizedType.TYPE_ARGUMENTS_PROPERTY) {
          return mask & SimilarElementsRequestor.REF_TYPES_AND_VAR;
        }
        mask &= SimilarElementsRequestor.CLASSES | SimilarElementsRequestor.INTERFACES;
      } else if (parent instanceof WildcardType) {
        if (node.getLocationInParent() == WildcardType.BOUND_PROPERTY) {
          return mask & SimilarElementsRequestor.REF_TYPES_AND_VAR;
        }
      }
      node = parent;
      parent = parent.getParent();
    }

    switch (parent.getNodeType()) {
      case ASTNode.TYPE_DECLARATION:
        if (node.getLocationInParent() == TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY) {
          kind = SimilarElementsRequestor.INTERFACES;
        } else if (node.getLocationInParent() == TypeDeclaration.SUPERCLASS_TYPE_PROPERTY) {
          kind = SimilarElementsRequestor.CLASSES;
        }
        break;
      case ASTNode.ENUM_DECLARATION:
        kind = SimilarElementsRequestor.INTERFACES;
        break;
      case ASTNode.METHOD_DECLARATION:
        if (node.getLocationInParent() == MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY) {
          kind = SimilarElementsRequestor.CLASSES;
        } else if (node.getLocationInParent() == MethodDeclaration.RETURN_TYPE2_PROPERTY) {
          kind = SimilarElementsRequestor.ALL_TYPES | SimilarElementsRequestor.VOIDTYPE;
        }
        break;
      case ASTNode.ANNOTATION_TYPE_MEMBER_DECLARATION:
        kind =
            SimilarElementsRequestor.PRIMITIVETYPES
                | SimilarElementsRequestor.ANNOTATIONS
                | SimilarElementsRequestor.ENUMS;
        break;
      case ASTNode.INSTANCEOF_EXPRESSION:
        kind = SimilarElementsRequestor.REF_TYPES;
        break;
      case ASTNode.THROW_STATEMENT:
        kind = SimilarElementsRequestor.CLASSES;
        break;
      case ASTNode.CLASS_INSTANCE_CREATION:
        if (((ClassInstanceCreation) parent).getAnonymousClassDeclaration() == null) {
          kind = SimilarElementsRequestor.CLASSES;
        } else {
          kind = SimilarElementsRequestor.CLASSES | SimilarElementsRequestor.INTERFACES;
        }
        break;
      case ASTNode.SINGLE_VARIABLE_DECLARATION:
        int superParent = parent.getParent().getNodeType();
        if (superParent == ASTNode.CATCH_CLAUSE) {
          kind = SimilarElementsRequestor.CLASSES;
        } else if (superParent == ASTNode.ENHANCED_FOR_STATEMENT) {
          kind = SimilarElementsRequestor.REF_TYPES;
        }
        break;
      case ASTNode.TAG_ELEMENT:
        kind = SimilarElementsRequestor.REF_TYPES;
        break;
      case ASTNode.MARKER_ANNOTATION:
      case ASTNode.SINGLE_MEMBER_ANNOTATION:
      case ASTNode.NORMAL_ANNOTATION:
        kind = SimilarElementsRequestor.ANNOTATIONS;
        break;
      case ASTNode.TYPE_PARAMETER:
        if (((TypeParameter) parent).typeBounds().indexOf(node) > 0) {
          kind = SimilarElementsRequestor.INTERFACES;
        } else {
          kind = SimilarElementsRequestor.REF_TYPES_AND_VAR;
        }
        break;
      case ASTNode.TYPE_LITERAL:
        kind = SimilarElementsRequestor.REF_TYPES;
        break;
      default:
    }
    return kind & mask;
  }

