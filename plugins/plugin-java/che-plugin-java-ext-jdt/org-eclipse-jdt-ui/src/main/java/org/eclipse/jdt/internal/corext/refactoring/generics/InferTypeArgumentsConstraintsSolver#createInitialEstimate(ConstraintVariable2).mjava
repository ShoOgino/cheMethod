  private TypeSet createInitialEstimate(ConstraintVariable2 cv) {
    // TODO: check assumption: only immutable CVs have a type
    //		ParametricStructure parametricStructure= fElemStructureEnv.elemStructure(cv);
    //		if (parametricStructure != null && parametricStructure !=
    // ParametricStructureComputer.ParametricStructure.NONE) {
    //			return SubTypesOfSingleton.create(parametricStructure.getBase());
    //		}

    TType type = cv.getType();
    if (type == null) {
      return fTypeSetEnvironment.getUniverseTypeSet();

    } else if (cv instanceof IndependentTypeVariable2) {
      return fTypeSetEnvironment.getUniverseTypeSet();
      // TODO: solve problem with recursive bounds
      //			TypeVariable tv= (TypeVariable) type;
      //			TType[] bounds= tv.getBounds();
      //			TypeSet result= SubTypesOfSingleton.create(bounds[0].getErasure());
      //			for (int i= 1; i < bounds.length; i++) {
      //				result= result.intersectedWith(SubTypesOfSingleton.create(bounds[i].getErasure()));
      //			}
      //			return result;

    } else if (cv instanceof ArrayTypeVariable2) {
      return fTypeSetEnvironment.getUniverseTypeSet();
    } else if (cv instanceof ArrayElementVariable2) {
      if (cv.getType() != null && cv.getType().isTypeVariable()) {
        return fTypeSetEnvironment.getUniverseTypeSet();
      } else {
        return new SingletonTypeSet(type, fTypeSetEnvironment);
      }

    } else if (type.isVoidType()) {
      return fTypeSetEnvironment.getEmptyTypeSet();
    } else {
      return new SingletonTypeSet(type, fTypeSetEnvironment);
    }
  }

