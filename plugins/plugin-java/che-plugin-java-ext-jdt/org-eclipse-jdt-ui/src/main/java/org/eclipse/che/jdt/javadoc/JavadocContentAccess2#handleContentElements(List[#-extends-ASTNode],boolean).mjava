  private void handleContentElements(List<? extends ASTNode> nodes, boolean skipLeadingWhitespace) {
    ASTNode previousNode = null;
    for (Iterator<? extends ASTNode> iter = nodes.iterator(); iter.hasNext(); ) {
      ASTNode child = iter.next();
      if (previousNode != null) {
        int previousEnd = previousNode.getStartPosition() + previousNode.getLength();
        int childStart = child.getStartPosition();
        if (previousEnd > childStart) {
          // should never happen, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=304826
          Exception exception =
              new Exception(
                  "Illegal ASTNode positions: previousEnd="
                      + previousEnd // $NON-NLS-1$
                      + ", childStart="
                      + childStart // $NON-NLS-1$
                      + ", element="
                      + fElement.getHandleIdentifier() // $NON-NLS-1$
                      + ", Javadoc:\n"
                      + fSource); // $NON-NLS-1$
          LOG.error(exception.getMessage(), exception);
        } else if (previousEnd != childStart) {
          // Need to preserve whitespace before a node that's not
          // directly following the previous node (e.g. on a new line)
          // due to https://bugs.eclipse.org/bugs/show_bug.cgi?id=206518 :
          String textWithStars = fSource.substring(previousEnd, childStart);
          String text = removeDocLineIntros(textWithStars);
          fBuf.append(text);
        }
      }
      previousNode = child;
      if (child instanceof TextElement) {
        String text = ((TextElement) child).getText();
        if (skipLeadingWhitespace) {
          text = text.replaceFirst("^\\s+", ""); // $NON-NLS-1$ //$NON-NLS-2$
        }
        // workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=233481 :
        text = text.replaceAll("(\r\n?|\n)([ \t]*\\*)", "$1"); // $NON-NLS-1$ //$NON-NLS-2$
        handleText(text);
      } else if (child instanceof TagElement) {
        handleInlineTagElement((TagElement) child);
      } else {
        // This is unexpected. Fail gracefully by just copying the source.
        int start = child.getStartPosition();
        String text = fSource.substring(start, start + child.getLength());
        fBuf.append(removeDocLineIntros(text));
      }
    }
  }

