  /**
   * If suffix matching is enabled, the refactoring may suggest two fields to have the same name
   * which reside in the same type. Same thing may also happen if the user makes poor choices for
   * the field names.
   *
   * <p>Consider: FooBarThing fFooBarThing; FooBarThing fBarThing;
   *
   * <p>Rename "FooBarThing" to "DifferentHunk". Suggestion for both fields is "fDifferentHunk" (and
   * rightly so).
   *
   * @param currentField field
   * @param newName new name
   * @return status
   */
  private RefactoringStatus checkForConflictingRename(IField currentField, String newName) {
    RefactoringStatus status = new RefactoringStatus();
    for (Iterator<IJavaElement> iter = fFinalSimilarElementToName.keySet().iterator();
        iter.hasNext();
        ) {
      IJavaElement element = iter.next();
      if (element instanceof IField) {
        IField alreadyRegisteredField = (IField) element;
        String alreadyRegisteredFieldName = fFinalSimilarElementToName.get(element);
        if (alreadyRegisteredFieldName.equals(newName)) {
          if (alreadyRegisteredField.getDeclaringType().equals(currentField.getDeclaringType())) {

            String message =
                Messages.format(
                    RefactoringCoreMessages.RenameTypeProcessor_cannot_rename_fields_same_new_name,
                    new String[] {
                      BasicElementLabels.getJavaElementName(
                          alreadyRegisteredField.getElementName()),
                      BasicElementLabels.getJavaElementName(currentField.getElementName()),
                      BasicElementLabels.getJavaElementName(
                          alreadyRegisteredField.getDeclaringType().getFullyQualifiedName('.')),
                      BasicElementLabels.getJavaElementName(newName)
                    });
            status.addFatalError(message);
            return status;
          }
        }
      }
    }
    return status;
  }

