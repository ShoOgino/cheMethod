	private int isQualifierOK(String value, int nameStart) {
		// only works for references without whitespace
		int qualifierAfter= nameStart - 1;
		if (qualifierAfter < 0)
			// there is absolutely nothing before the name itself in the string
			return MATCH_UNQUALIFIED;

		char charBeforeName= value.charAt(qualifierAfter);
		if (! isQualifierSeparator(charBeforeName))
			// the char before the name is not a # or . - should not get here anyway
			return MATCH_UNQUALIFIED; // NO_MATCH ?

		boolean canFinish= charBeforeName == '#';
		// work through the qualifier from back to front
		for (int i= 0; i < fQualifier.length() ; i++) {
			int qualifierCharPos= qualifierAfter - 1 - i;
			if (qualifierCharPos < 0)
				// the position does not exist, return OK if last read char was a non-separator
				return canFinish ? MATCH_UNQUALIFIED : NO_MATCH;

			char qualifierChar= value.charAt(qualifierCharPos);
			char goalQualifierChar= fQualifier.charAt(fQualifier.length() - 1 - i);
			if (qualifierChar != goalQualifierChar)
				// the chars do not match. return OK if last read char was a non-separator and the current one a non-qualifier
				return (canFinish && !isQualifierPart(qualifierChar)) ? MATCH_UNQUALIFIED : NO_MATCH;

			canFinish= ! isQualifierSeparator(qualifierChar);
		}
		int beforeQualifierPos= qualifierAfter - fQualifier.length() - 1;
		if (beforeQualifierPos >= 0) {
			char beforeQualifierChar= value.charAt(beforeQualifierPos);
			if (Character.isJavaIdentifierPart(beforeQualifierChar)) {
				return NO_MATCH;
			}
			if (isQualifierSeparator(beforeQualifierChar)) {
				if (beforeQualifierPos > 0) {
					/*
					 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=142508 :
					 * If the character before the qualifier separator is not
					 * an identifier part, then accept the match.
					 */
					char precedingOne= value.charAt(beforeQualifierPos - 1);
					if (Character.isJavaIdentifierPart(precedingOne)) {
						return NO_MATCH;
					}
				}
			}
			return MATCH_QUALIFIED;

		}
		return MATCH_QUALIFIED;
	}

