  private static void addRemoveIncludingConditionProposal(
      IInvocationContext context,
      ASTNode toRemove,
      ASTNode replacement,
      Collection<ICommandAccess> proposals) {
    Image image =
        JavaPluginImages.get(
            JavaPluginImages
                .IMG_TOOL_DELETE); //JavaPlugin.getDefault().getWorkbench().getSharedImages().getImage(ISharedImages.IMG_TOOL_DELETE);
    String label =
        CorrectionMessages
            .LocalCorrectionsSubProcessor_removeunreachablecode_including_condition_description;
    AST ast = toRemove.getAST();
    ASTRewrite rewrite = ASTRewrite.create(ast);
    ASTRewriteCorrectionProposal proposal =
        new ASTRewriteCorrectionProposal(
            label,
            context.getCompilationUnit(),
            rewrite,
            IProposalRelevance.REMOVE_UNREACHABLE_CODE_INCLUDING_CONDITION,
            image);

    if (replacement == null
        || replacement instanceof EmptyStatement
        || replacement instanceof Block && ((Block) replacement).statements().size() == 0) {
      if (ASTNodes.isControlStatementBody(toRemove.getLocationInParent())) {
        rewrite.replace(toRemove, toRemove.getAST().newBlock(), null);
      } else {
        rewrite.remove(toRemove, null);
      }

    } else if (toRemove instanceof Expression && replacement instanceof Expression) {
      Expression moved = (Expression) rewrite.createMoveTarget(replacement);
      Expression toRemoveExpression = (Expression) toRemove;
      Expression replacementExpression = (Expression) replacement;
      ITypeBinding explicitCast =
          ASTNodes.getExplicitCast(replacementExpression, toRemoveExpression);
      if (explicitCast != null) {
        CastExpression cast = ast.newCastExpression();
        if (NecessaryParenthesesChecker.needsParentheses(
            replacementExpression, cast, CastExpression.EXPRESSION_PROPERTY)) {
          ParenthesizedExpression parenthesized = ast.newParenthesizedExpression();
          parenthesized.setExpression(moved);
          moved = parenthesized;
        }
        cast.setExpression(moved);
        ImportRewrite imports = proposal.createImportRewrite(context.getASTRoot());
        ImportRewriteContext importRewriteContext =
            new ContextSensitiveImportRewriteContext(toRemove, imports);
        cast.setType(imports.addImport(explicitCast, ast, importRewriteContext));
        moved = cast;
      }
      rewrite.replace(toRemove, moved, null);

    } else {
      ASTNode parent = toRemove.getParent();
      ASTNode moveTarget;
      if ((parent instanceof Block || parent instanceof SwitchStatement)
          && replacement instanceof Block) {
        ListRewrite listRewrite = rewrite.getListRewrite(replacement, Block.STATEMENTS_PROPERTY);
        List<Statement> list = ((Block) replacement).statements();
        int lastIndex = list.size() - 1;
        moveTarget = listRewrite.createMoveTarget(list.get(0), list.get(lastIndex));
      } else {
        moveTarget = rewrite.createMoveTarget(replacement);
      }

      rewrite.replace(toRemove, moveTarget, null);
    }

    proposals.add(proposal);
  }

