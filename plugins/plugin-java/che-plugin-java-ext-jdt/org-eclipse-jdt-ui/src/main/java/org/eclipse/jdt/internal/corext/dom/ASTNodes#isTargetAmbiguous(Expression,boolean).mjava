  /**
   * Checks whether overloaded methods can result in an ambiguous method call or a semantic change
   * when the <code>expression</code> argument is replaced with a poly expression form of the
   * functional interface instance.
   *
   * @param expression the method argument, which is a functional interface instance
   * @param expressionIsExplicitlyTyped <code>true</code> iff the intended replacement for <code>
   *     expression</code> is an explicitly typed lambda expression (JLS8 15.27.1)
   * @return <code>true</code> if overloaded methods can result in an ambiguous method call or a
   *     semantic change, <code>false</code> otherwise
   * @since 3.10
   */
  public static boolean isTargetAmbiguous(
      Expression expression, boolean expressionIsExplicitlyTyped) {
    StructuralPropertyDescriptor locationInParent = expression.getLocationInParent();

    while (locationInParent == ParenthesizedExpression.EXPRESSION_PROPERTY
        || locationInParent == ConditionalExpression.THEN_EXPRESSION_PROPERTY
        || locationInParent == ConditionalExpression.ELSE_EXPRESSION_PROPERTY) {
      expression = (Expression) expression.getParent();
      locationInParent = expression.getLocationInParent();
    }

    ASTNode parent = expression.getParent();
    IMethodBinding methodBinding;
    int argumentIndex;
    int argumentCount;
    Expression invocationQualifier = null;
    if (locationInParent == MethodInvocation.ARGUMENTS_PROPERTY) {
      MethodInvocation methodInvocation = (MethodInvocation) parent;
      methodBinding = methodInvocation.resolveMethodBinding();
      argumentIndex = methodInvocation.arguments().indexOf(expression);
      argumentCount = methodInvocation.arguments().size();
      invocationQualifier = methodInvocation.getExpression();
    } else if (locationInParent == SuperMethodInvocation.ARGUMENTS_PROPERTY) {
      SuperMethodInvocation superMethodInvocation = (SuperMethodInvocation) parent;
      methodBinding = superMethodInvocation.resolveMethodBinding();
      argumentIndex = superMethodInvocation.arguments().indexOf(expression);
      argumentCount = superMethodInvocation.arguments().size();
      invocationQualifier = superMethodInvocation.getQualifier();
    } else if (locationInParent == ConstructorInvocation.ARGUMENTS_PROPERTY) {
      ConstructorInvocation constructorInvocation = (ConstructorInvocation) parent;
      methodBinding = constructorInvocation.resolveConstructorBinding();
      argumentIndex = constructorInvocation.arguments().indexOf(expression);
      argumentCount = constructorInvocation.arguments().size();
    } else if (locationInParent == SuperConstructorInvocation.ARGUMENTS_PROPERTY) {
      SuperConstructorInvocation superConstructorInvocation = (SuperConstructorInvocation) parent;
      methodBinding = superConstructorInvocation.resolveConstructorBinding();
      argumentIndex = superConstructorInvocation.arguments().indexOf(expression);
      argumentCount = superConstructorInvocation.arguments().size();
    } else if (locationInParent == ClassInstanceCreation.ARGUMENTS_PROPERTY) {
      ClassInstanceCreation creation = (ClassInstanceCreation) parent;
      methodBinding = creation.resolveConstructorBinding();
      argumentIndex = creation.arguments().indexOf(expression);
      argumentCount = creation.arguments().size();
    } else if (locationInParent == EnumConstantDeclaration.ARGUMENTS_PROPERTY) {
      EnumConstantDeclaration enumConstantDecl = (EnumConstantDeclaration) parent;
      methodBinding = enumConstantDecl.resolveConstructorBinding();
      argumentIndex = enumConstantDecl.arguments().indexOf(expression);
      argumentCount = enumConstantDecl.arguments().size();
    } else {
      return false;
    }

    if (methodBinding != null) {
      ITypeBinding invocationTargetType;
      if (parent instanceof MethodInvocation || parent instanceof SuperMethodInvocation) {
        if (invocationQualifier != null) {
          invocationTargetType = invocationQualifier.resolveTypeBinding();
          if (invocationTargetType != null && parent instanceof SuperMethodInvocation) {
            invocationTargetType = invocationTargetType.getSuperclass();
          }
        } else {
          ITypeBinding enclosingType = getEnclosingType(parent);
          if (enclosingType != null && parent instanceof SuperMethodInvocation) {
            enclosingType = enclosingType.getSuperclass();
          }
          if (enclosingType != null) {
            IMethodBinding methodInHierarchy =
                Bindings.findMethodInHierarchy(
                    enclosingType, methodBinding.getName(), methodBinding.getParameterTypes());
            if (methodInHierarchy != null) {
              invocationTargetType = enclosingType;
            } else {
              invocationTargetType = methodBinding.getDeclaringClass();
            }
          } else {
            // not expected
            invocationTargetType = methodBinding.getDeclaringClass();
          }
        }
      } else {
        invocationTargetType = methodBinding.getDeclaringClass();
      }
      if (invocationTargetType != null) {
        TypeBindingVisitor visitor =
            new AmbiguousTargetMethodAnalyzer(
                invocationTargetType,
                methodBinding,
                argumentIndex,
                argumentCount,
                expressionIsExplicitlyTyped);
        return !(visitor.visit(invocationTargetType)
            && Bindings.visitHierarchy(invocationTargetType, visitor));
      }
    }

    return true;
  }

