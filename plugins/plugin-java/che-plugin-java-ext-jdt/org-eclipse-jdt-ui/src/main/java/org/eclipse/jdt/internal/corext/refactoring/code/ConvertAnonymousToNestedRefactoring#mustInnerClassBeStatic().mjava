  public boolean mustInnerClassBeStatic() {
    ITypeBinding typeBinding =
        ((AbstractTypeDeclaration)
                ASTNodes.getParent(fAnonymousInnerClassNode, AbstractTypeDeclaration.class))
            .resolveBinding();
    ASTNode current = fAnonymousInnerClassNode.getParent();
    boolean ans = false;
    while (current != null) {
      switch (current.getNodeType()) {
        case ASTNode.SUPER_CONSTRUCTOR_INVOCATION:
        case ASTNode.CONSTRUCTOR_INVOCATION:
          return true;
        case ASTNode.ANONYMOUS_CLASS_DECLARATION:
          {
            AnonymousClassDeclaration enclosingAnonymousClassDeclaration =
                (AnonymousClassDeclaration) current;
            ITypeBinding binding = enclosingAnonymousClassDeclaration.resolveBinding();
            if (binding != null && Bindings.isSuperType(typeBinding, binding.getSuperclass())) {
              return false;
            }
            break;
          }
        case ASTNode.FIELD_DECLARATION:
          {
            FieldDeclaration enclosingFieldDeclaration = (FieldDeclaration) current;
            if (Modifier.isStatic(enclosingFieldDeclaration.getModifiers())) {
              ans = true;
            }
            break;
          }
        case ASTNode.METHOD_DECLARATION:
          {
            MethodDeclaration enclosingMethodDeclaration = (MethodDeclaration) current;
            if (Modifier.isStatic(enclosingMethodDeclaration.getModifiers())) {
              ans = true;
            }
            break;
          }
        case ASTNode.TYPE_DECLARATION:
          {
            return ans;
          }
      }
      current = current.getParent();
    }
    return ans;
  }

