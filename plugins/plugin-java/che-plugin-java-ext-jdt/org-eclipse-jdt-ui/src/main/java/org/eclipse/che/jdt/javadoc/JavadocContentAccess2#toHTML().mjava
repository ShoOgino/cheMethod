  private String toHTML() {
    fBuf = new StringBuffer();
    fLiteralContent = 0;

    // After first loop, non-null entries in the following two lists are missing and need to be
    // inherited:
    List<String> parameterNames = initParameterNames();
    List<String> exceptionNames = initExceptionNames();

    TagElement deprecatedTag = null;
    TagElement start = null;
    List<TagElement> parameters = new ArrayList<TagElement>();
    TagElement returnTag = null;
    List<TagElement> exceptions = new ArrayList<TagElement>();
    List<TagElement> versions = new ArrayList<TagElement>();
    List<TagElement> authors = new ArrayList<TagElement>();
    List<TagElement> sees = new ArrayList<TagElement>();
    List<TagElement> since = new ArrayList<TagElement>();
    List<TagElement> rest = new ArrayList<TagElement>();

    List<TagElement> tags = fJavadoc.tags();
    for (Iterator<TagElement> iter = tags.iterator(); iter.hasNext(); ) {
      TagElement tag = iter.next();
      String tagName = tag.getTagName();
      if (tagName == null) {
        start = tag;

      } else if (TagElement.TAG_PARAM.equals(tagName)) {
        parameters.add(tag);
        List<? extends ASTNode> fragments = tag.fragments();
        if (fragments.size() > 0) {
          Object first = fragments.get(0);
          if (first instanceof SimpleName) {
            String name = ((SimpleName) first).getIdentifier();
            int paramIndex = parameterNames.indexOf(name);
            if (paramIndex != -1) {
              parameterNames.set(paramIndex, null);
            }
          }
        }

      } else if (TagElement.TAG_RETURN.equals(tagName)) {
        if (returnTag == null) returnTag = tag; // the Javadoc tool only shows the first return tag

      } else if (TagElement.TAG_EXCEPTION.equals(tagName)
          || TagElement.TAG_THROWS.equals(tagName)) {
        exceptions.add(tag);
        List<? extends ASTNode> fragments = tag.fragments();
        if (fragments.size() > 0) {
          Object first = fragments.get(0);
          if (first instanceof Name) {
            String name = ASTNodes.getSimpleNameIdentifier((Name) first);
            int exceptionIndex = exceptionNames.indexOf(name);
            if (exceptionIndex != -1) {
              exceptionNames.set(exceptionIndex, null);
            }
          }
        }

      } else if (TagElement.TAG_SINCE.equals(tagName)) {
        since.add(tag);
      } else if (TagElement.TAG_VERSION.equals(tagName)) {
        versions.add(tag);
      } else if (TagElement.TAG_AUTHOR.equals(tagName)) {
        authors.add(tag);
      } else if (TagElement.TAG_SEE.equals(tagName)) {
        sees.add(tag);
      } else if (TagElement.TAG_DEPRECATED.equals(tagName)) {
        if (deprecatedTag == null)
          deprecatedTag = tag; // the Javadoc tool only shows the first deprecated tag
      } else {
        rest.add(tag);
      }
    }

    // TODO: @Documented annotations before header
    if (deprecatedTag != null) handleDeprecatedTag(deprecatedTag);
    if (start != null) handleContentElements(start.fragments());
    else if (fMethod != null) {
      CharSequence inherited = fJavadocLookup.getInheritedMainDescription(fMethod);
      // The Javadoc tool adds "Description copied from class: ..." (only for the main description).
      // We don't bother doing that.
      handleInherited(inherited);
    }

    CharSequence[] parameterDescriptions = new CharSequence[parameterNames.size()];
    boolean hasInheritedParameters =
        inheritParameterDescriptions(parameterNames, parameterDescriptions);
    boolean hasParameters = parameters.size() > 0 || hasInheritedParameters;

    CharSequence returnDescription = null;
    if (returnTag == null && needsReturnTag())
      returnDescription = fJavadocLookup.getInheritedReturnDescription(fMethod);
    boolean hasReturnTag = returnTag != null || returnDescription != null;

    CharSequence[] exceptionDescriptions = new CharSequence[exceptionNames.size()];
    boolean hasInheritedExceptions =
        inheritExceptionDescriptions(exceptionNames, exceptionDescriptions);
    boolean hasExceptions = exceptions.size() > 0 || hasInheritedExceptions;

    if (hasParameters
        || hasReturnTag
        || hasExceptions
        || versions.size() > 0
        || authors.size() > 0
        || since.size() > 0
        || sees.size() > 0
        || rest.size() > 0
        || (fBuf.length() > 0
            && (parameterDescriptions.length > 0 || exceptionDescriptions.length > 0))) {
      handleSuperMethodReferences();
      fBuf.append(BLOCK_TAG_START);
      handleParameterTags(parameters, parameterNames, parameterDescriptions);
      handleReturnTag(returnTag, returnDescription);
      handleExceptionTags(exceptions, exceptionNames, exceptionDescriptions);
      handleBlockTags(JavaDocMessages.JavaDoc2HTMLTextReader_since_section, since);
      handleBlockTags(JavaDocMessages.JavaDoc2HTMLTextReader_version_section, versions);
      handleBlockTags(JavaDocMessages.JavaDoc2HTMLTextReader_author_section, authors);
      handleBlockTags(JavaDocMessages.JavaDoc2HTMLTextReader_see_section, sees);
      handleBlockTags(rest);
      fBuf.append(BLOCK_TAG_END);

    } else if (fBuf.length() > 0) {
      handleSuperMethodReferences();
    }

    String result = fBuf.toString();
    fBuf = null;
    return result;
  }

