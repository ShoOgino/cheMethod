	//TODO hard-wired to collections
	private void initializeContainerStructure() {
		if (DEBUG_INITIALIZATION)
			System.out.println("  *** Seeding container structure ***"); //$NON-NLS-1$
		for (int i = 0; i < fAllConstraintVariables.length; i++) {
			ConstraintVariable2 v = fAllConstraintVariables[i];
			TType varType = declaredTypeOf(v);

			if (varType != null) {
				// rmf 11/30/2004 - Added isUnmodifiableFieldOrMethod() test to
				// avoid unifying element types of container actual arguments
				// with formal arguments of binary methods, to permit passing
				// List<String> to a binary method taking a raw List.
				if (isParametricType(varType) && !isUnmodifiableFieldOrMethod(v)) {
					if (DEBUG_INITIALIZATION) System.out.println("Entity has           container structure: " + v); //$NON-NLS-1$
					setStructureAndPush(v, newParametricType(varType));
				} else if (!mightBeParametric(varType)) {
					// Not a supertype of any container type - can't have container structure
					if (DEBUG_INITIALIZATION) System.out.println("Entity DOES NOT have container structure: " + v); //$NON-NLS-1$
					setStructureAndPush(v, ParametricStructure.NONE);
				}
				// else we're not sure yet whether this has container structure
			} else {
//				TType exprType= v.getType(); // TODO: always null!
//
//				if (isArrayAccess(v)) {
//					if (DEBUG_INITIALIZATION) System.out.println("Entity DOES NOT have container structure: " + v);
//					setStructureAndPush(v, NO_STRUCTURE); // definitely not container structure, Java 1.5 says no generics inside arrays
//				} else if (isParametricType(exprType)) {
//					if (DEBUG_INITIALIZATION) System.out.println("Entity has           container structure: " + v);
//					setStructureAndPush(v, newParametricType(exprType));
//				} else if (exprType != null && !mightBeParametric(exprType)) {
//					// Not a supertype of any container type - can't have container structure
//					if (DEBUG_INITIALIZATION) System.out.println("Entity DOES NOT have container structure: " + v);
//					setStructureAndPush(v, NO_STRUCTURE);
//				}

				// TODO Markus: the following just updates the set of child element variables of the parent variable of 'v'.
				// You already maintain this information automatically, so the code below is not needed...
//				if (v instanceof CollectionElementVariable2) {
//					CollectionElementVariable2 ev= (CollectionElementVariable2) v;
//					int idx= ev.getDeclarationTypeVariableIndex(); //TODO : INDEX IS -1 IF THE TYPE VARIABLE COMES FROM A SUPERTYPE!!!
//
//					Collection/*<ConstraintVariable2>*/ vars= fTCModel.getElementVariables(ev).values();
//
//					if (vars == null) vars= new ConstraintVariable2[ev.getNumContainerTypeParams()];
//					vars[idx]= ev;
//					fVariableElementEnv.setElementVariables(ev.getParentConstraintVariable(), vars);
//				}
				// else we're not sure yet whether this has container structure
			}
		}
		// Every variable v in fAllVariables is now in one of 3 states:
		//  - elemStructure(v) == some parametric type:       definitely container structure, but we may not know the sub-structure yet
		//  - elemStructure(v) == some AbstractTypeParameter: definitely not container structure
		//  - elemStructure(v) == null:                       we know nothing yet about its structure
	}

