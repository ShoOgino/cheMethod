  /**
   * Finds and returns the super type signature in the <code>extends</code> or <code>implements
   * </code> clause of <code>subType</code> that corresponds to <code>superType</code>.
   *
   * @param subType a direct and true sub type of <code>superType</code>
   * @param superType a direct super type (super class or interface) of <code>subType</code>
   * @return the super type signature of <code>subType</code> referring to <code>superType</code>
   * @throws org.eclipse.jdt.core.JavaModelException if extracting the super type signatures fails,
   *     or if <code>subType</code> contains no super type signature to <code>superType</code>
   */
  private String findMatchingSuperTypeSignature(IType subType, IType superType)
      throws JavaModelException {
    String[] signatures = getSuperTypeSignatures(subType, superType);
    for (int i = 0; i < signatures.length; i++) {
      String signature = signatures[i];
      String qualified = SignatureUtil.qualifySignature(signature, subType);
      String subFQN = SignatureUtil.stripSignatureToFQN(qualified);

      String superFQN = superType.getFullyQualifiedName();
      if (subFQN.equals(superFQN)) {
        return signature;
      }

      // TODO handle local types
    }

    throw new JavaModelException(
        new CoreException(
            new Status(
                IStatus.ERROR,
                JavaPlugin.getPluginId(),
                IStatus.OK,
                "Illegal hierarchy",
                null))); // $NON-NLS-1$
  }

