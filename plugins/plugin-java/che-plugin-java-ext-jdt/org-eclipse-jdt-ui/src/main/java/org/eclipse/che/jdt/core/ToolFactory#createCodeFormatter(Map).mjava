//    /**
//     * Create an instance of a code formatter. A code formatter implementation can be contributed via the
//     * extension point "org.eclipse.jdt.core.codeFormatter". If unable to find a registered extension, the factory
//     * will default to using the default code formatter.
//     *
//     * @return an instance of a code formatter
//     * @see org.eclipse.jdt.core.ICodeFormatter
//     * @see org.eclipse.jdt.core.ToolFactory#createDefaultCodeFormatter(java.util.Map)
//     * @deprecated The extension point has been deprecated, use {@link #createCodeFormatter(java.util.Map)} instead.
//     */
//    public static ICodeFormatter createCodeFormatter() {
//
//        Plugin jdtCorePlugin = org.eclipse.jdt.core.JavaCore.getPlugin();
//        if (jdtCorePlugin == null) return null;
//
//        IExtensionPoint extension = jdtCorePlugin.getDescriptor().getExtensionPoint(JavaModelManager.FORMATTER_EXTPOINT_ID);
//        if (extension != null) {
//            IExtension[] extensions = extension.getExtensions();
//            for (int i = 0; i < extensions.length; i++) {
//                IConfigurationElement[] configElements = extensions[i].getConfigurationElements();
//                for (int j = 0; j < configElements.length; j++) {
//                    try {
//                        Object execExt = configElements[j].createExecutableExtension("class"); //$NON-NLS-1$
//                        if (execExt instanceof ICodeFormatter) {
//                            // use first contribution found
//                            return (ICodeFormatter)execExt;
//                        }
//                    } catch (CoreException e) {
//                        // unable to instantiate extension, will answer default formatter instead
//                    }
//                }
//            }
//        }
//        // no proper contribution found, use default formatter
//        return createDefaultCodeFormatter(null);
//    }
//
    /**
     * Create an instance of the built-in code formatter.
     * <p>The given options should at least provide the source level ({@link org.eclipse.jdt.core.JavaCore#COMPILER_SOURCE}),
     * the  compiler compliance level ({@link org.eclipse.jdt.core.JavaCore#COMPILER_COMPLIANCE}) and the target platform
     * ({@link org.eclipse.jdt.core.JavaCore#COMPILER_CODEGEN_TARGET_PLATFORM}).
     * Without these options, it is not possible for the code formatter to know what kind of source it needs to format.
     * </p><p>
     * Note this is equivalent to <code>createCodeFormatter(options, M_FORMAT_NEW)</code>. Thus some code formatter options
     * may be ignored. See @{link {@link #M_FORMAT_NEW} for more details.
     * </p>
     * @param options - the options map to use for formatting with the default code formatter. Recognized options
	 * 	are documented on <code>JavaCore#getDefaultOptions()</code>. If set to <code>null</code>, then use
	 * 	the current settings from <code>JavaCore#getOptions</code>.
	 * @return an instance of the built-in code formatter
	 * @see org.eclipse.jdt.core.formatter.CodeFormatter
	 * @see org.eclipse.jdt.core.JavaCore#getOptions()
	 * @since 3.0
	 */
	public static CodeFormatter createCodeFormatter(Map options){
		return createCodeFormatter(options, M_FORMAT_NEW);
	}

