  @Override
  public RefactoringStatus checkInitialConditions(IProgressMonitor pm)
      throws CoreException, OperationCanceledException {
    try {
      pm.beginTask(RefactoringCoreMessages.IntroduceIndirectionRefactoring_checking_activation, 1);
      fRewrites = new HashMap<ICompilationUnit, CompilationUnitRewrite>();

      // This refactoring has been invoked on
      // (1) a TextSelection inside an ICompilationUnit or inside an IClassFile (definitely with source), or
      // (2) an IMethod inside a ICompilationUnit or inside an IClassFile (with or without source)

      if (fTargetMethod == null) {
        // (1) invoked on a text selection

        if (fSelectionStart == 0)
          return RefactoringStatus.createFatalErrorStatus(
              RefactoringCoreMessages
                  .IntroduceIndirectionRefactoring_not_available_on_this_selection);

        // if a text selection exists, source is available.
        CompilationUnit selectionCURoot;
        ASTNode selectionNode;
        if (fSelectionCompilationUnit != null) {
          // compilation unit - could use CuRewrite later on
          selectionCURoot = getCachedCURewrite(fSelectionCompilationUnit).getRoot();
          selectionNode =
              getSelectedNode(
                  fSelectionCompilationUnit, selectionCURoot, fSelectionStart, fSelectionLength);
        } else {
          // binary class file - no cu rewrite
          ASTParser parser = ASTParser.newParser(ASTProvider.SHARED_AST_LEVEL);
          parser.setResolveBindings(true);
          parser.setSource(fSelectionClassFile);
          selectionCURoot = (CompilationUnit) parser.createAST(null);
          selectionNode = getSelectedNode(null, selectionCURoot, fSelectionStart, fSelectionLength);
        }

        if (selectionNode == null)
          return RefactoringStatus.createFatalErrorStatus(
              RefactoringCoreMessages
                  .IntroduceIndirectionRefactoring_not_available_on_this_selection);

        IMethodBinding targetMethodBinding = null;

        if (selectionNode.getNodeType() == ASTNode.METHOD_INVOCATION) {
          targetMethodBinding = ((MethodInvocation) selectionNode).resolveMethodBinding();
        } else if (selectionNode.getNodeType() == ASTNode.METHOD_DECLARATION) {
          targetMethodBinding = ((MethodDeclaration) selectionNode).resolveBinding();
        } else if (selectionNode.getNodeType() == ASTNode.SUPER_METHOD_INVOCATION) {
          // Allow invocation on super methods calls. makes sense as other
          // calls or even only the declaration can be updated.
          targetMethodBinding = ((SuperMethodInvocation) selectionNode).resolveMethodBinding();
        } else {
          return RefactoringStatus.createFatalErrorStatus(
              RefactoringCoreMessages
                  .IntroduceIndirectionRefactoring_not_available_on_this_selection);
        }
        fTargetMethodBinding = targetMethodBinding.getMethodDeclaration(); // resolve generics
        fTargetMethod = (IMethod) fTargetMethodBinding.getJavaElement();

        //allow single updating mode if an invocation was selected and the invocation can be updated
        if (selectionNode instanceof MethodInvocation && fSelectionCompilationUnit != null)
          fSelectionMethodInvocation = (MethodInvocation) selectionNode;

      } else {
        // (2) invoked on an IMethod: Source may not be available

        if (fTargetMethod.getDeclaringType().isAnnotation())
          return RefactoringStatus.createFatalErrorStatus(
              RefactoringCoreMessages.IntroduceIndirectionRefactoring_not_available_on_annotation);

        if (fTargetMethod.getCompilationUnit() != null) {
          // source method
          CompilationUnit selectionCURoot =
              getCachedCURewrite(fTargetMethod.getCompilationUnit()).getRoot();
          MethodDeclaration declaration =
              ASTNodeSearchUtil.getMethodDeclarationNode(fTargetMethod, selectionCURoot);
          fTargetMethodBinding = declaration.resolveBinding().getMethodDeclaration();
        } else {
          // binary method - no CURewrite available (and none needed as we cannot update the method anyway)
          ASTParser parser = ASTParser.newParser(ASTProvider.SHARED_AST_LEVEL);
          parser.setProject(fTargetMethod.getJavaProject());
          IBinding[] bindings = parser.createBindings(new IJavaElement[] {fTargetMethod}, null);
          fTargetMethodBinding = ((IMethodBinding) bindings[0]).getMethodDeclaration();
        }
      }

      if (fTargetMethod == null
          || fTargetMethodBinding == null
          || (!RefactoringAvailabilityTester.isIntroduceIndirectionAvailable(fTargetMethod)))
        return RefactoringStatus.createFatalErrorStatus(
            RefactoringCoreMessages
                .IntroduceIndirectionRefactoring_not_available_on_this_selection);

      if (fTargetMethod.getDeclaringType().isLocal()
          || fTargetMethod.getDeclaringType().isAnonymous())
        return RefactoringStatus.createFatalErrorStatus(
            RefactoringCoreMessages
                .IntroduceIndirectionRefactoring_not_available_for_local_or_anonymous_types);

      if (fTargetMethod.isConstructor())
        return RefactoringStatus.createFatalErrorStatus(
            RefactoringCoreMessages.IntroduceIndirectionRefactoring_not_available_for_constructors);

      if (fIntermediaryMethodName == null) fIntermediaryMethodName = fTargetMethod.getElementName();

      if (fIntermediaryType == null) {
        if (fSelectionCompilationUnit != null && !fSelectionCompilationUnit.isReadOnly())
          fIntermediaryType = getEnclosingInitialSelectionMember().getDeclaringType();
        else if (!fTargetMethod.isBinary() && !fTargetMethod.isReadOnly())
          fIntermediaryType = fTargetMethod.getDeclaringType();
      }

      return new RefactoringStatus();
    } finally {
      pm.done();
    }
  }

