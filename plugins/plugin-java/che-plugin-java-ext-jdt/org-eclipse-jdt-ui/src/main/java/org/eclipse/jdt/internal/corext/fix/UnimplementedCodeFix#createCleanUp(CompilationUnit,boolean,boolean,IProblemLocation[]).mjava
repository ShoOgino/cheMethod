  public static ICleanUpFix createCleanUp(
      CompilationUnit root,
      boolean addMissingMethod,
      boolean makeTypeAbstract,
      IProblemLocation[] problems) {
    Assert.isLegal(!addMissingMethod || !makeTypeAbstract);
    if (!addMissingMethod && !makeTypeAbstract) return null;

    if (problems.length == 0) return null;

    ArrayList<CompilationUnitRewriteOperation> operations =
        new ArrayList<CompilationUnitRewriteOperation>();

    for (int i = 0; i < problems.length; i++) {
      IProblemLocation problem = problems[i];
      if (addMissingMethod) {
        ASTNode typeNode = getSelectedTypeNode(root, problem);
        if (typeNode != null && !isTypeBindingNull(typeNode)) {
          operations.add(new AddUnimplementedMethodsOperation(typeNode));
        }
      } else {
        ASTNode typeNode = getSelectedTypeNode(root, problem);
        if (typeNode instanceof TypeDeclaration) {
          operations.add(new MakeTypeAbstractOperation((TypeDeclaration) typeNode));
        }
      }
    }

    if (operations.size() == 0) return null;

    String label;
    if (addMissingMethod) {
      label = CorrectionMessages.UnimplementedMethodsCorrectionProposal_description;
    } else {
      label = CorrectionMessages.UnimplementedCodeFix_MakeAbstractFix_label;
    }
    return new UnimplementedCodeFix(
        label, root, operations.toArray(new CompilationUnitRewriteOperation[operations.size()]));
  }

