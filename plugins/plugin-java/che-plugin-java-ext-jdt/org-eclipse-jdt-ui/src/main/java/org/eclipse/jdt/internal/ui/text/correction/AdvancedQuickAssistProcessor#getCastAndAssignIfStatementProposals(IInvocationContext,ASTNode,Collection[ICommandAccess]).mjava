	private static boolean getCastAndAssignIfStatementProposals(IInvocationContext context, ASTNode node, Collection<ICommandAccess> resultingCollections) {
		if (node instanceof IfStatement) {
			node= ((IfStatement)node).getExpression();
		} else if (node instanceof WhileStatement) {
			node= ((WhileStatement)node).getExpression();
		} else if (node instanceof Block) {
			List<Statement> statements= ((Block)node).statements();
			if (statements.size() > 0) {
				if (context.getSelectionOffset() > statements.get(0).getStartPosition()) {
					return false;
				}
			}
			ASTNode parent= node.getParent();
			Expression expression= null;
			if (parent instanceof IfStatement) {
				expression= ((IfStatement)parent).getExpression();
			} else if (parent instanceof WhileStatement) {
				expression= ((WhileStatement)parent).getExpression();
			} else {
				return false;
			}

			if (expression instanceof InstanceofExpression) {
				node= expression;
			} else {
				final ArrayList<InstanceofExpression> nodes= new ArrayList<InstanceofExpression>();
				expression.accept(new ASTVisitor() {
					@Override
					public boolean visit(InstanceofExpression instanceofExpression) {
						nodes.add(instanceofExpression);
						return false;
					}
				});

				if (nodes.size() != 1) {
					return false;
				}
				node= nodes.get(0);
			}
		} else {
			while (node != null && !(node instanceof InstanceofExpression) && !(node instanceof Statement)) {
				node= node.getParent();
			}
		}

		if (!(node instanceof InstanceofExpression)) {
			return false;
		}
		InstanceofExpression expression= (InstanceofExpression)node;
		// test that we are the expression of a 'while' or 'if'
		while (node.getParent() instanceof Expression) {
			node= node.getParent();
		}
		StructuralPropertyDescriptor locationInParent= node.getLocationInParent();

		boolean negated= isNegated(expression);

		Statement body= null;
		ASTNode insertionPosition= null;
		if (negated) {
			insertionPosition= node.getParent();
			if (locationInParent == IfStatement.EXPRESSION_PROPERTY) {
				body= ((IfStatement)node.getParent()).getElseStatement();
				if (body != null) {
					negated= false;
				}
			}
			if (body == null && insertionPosition.getParent() instanceof Block) {
				body= (Statement)insertionPosition.getParent();
			}
		} else {
			if (locationInParent == IfStatement.EXPRESSION_PROPERTY) {
				body= ((IfStatement)node.getParent()).getThenStatement();
			} else if (locationInParent == WhileStatement.EXPRESSION_PROPERTY) {
				body= ((WhileStatement)node.getParent()).getBody();
			}
		}
		if (body == null) {
			return false;
		}

		Type originalType= expression.getRightOperand();
		if (originalType.resolveBinding() == null) {
			return false;
		}

		//  we could produce quick assist
		if (resultingCollections == null) {
			return true;
		}

		final String KEY_NAME= "name"; //$NON-NLS-1$
		final String KEY_TYPE= "type"; //$NON-NLS-1$
		//
		AST ast= expression.getAST();
		ASTRewrite rewrite= ASTRewrite.create(ast);
		ICompilationUnit cu= context.getCompilationUnit();
		// prepare correction proposal
		String label= CorrectionMessages.AdvancedQuickAssistProcessor_castAndAssign;
		Image image= JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_LOCAL);
		LinkedCorrectionProposal proposal= new LinkedCorrectionProposal(label, cu, rewrite, IProposalRelevance.CAST_AND_ASSIGN, image);
		// prepare possible variable names
		List<String> excludedNames= Arrays.asList(ASTResolving.getUsedVariableNames(body));
		String[] varNames= suggestLocalVariableNames(cu, originalType.resolveBinding(), excludedNames);
		for (int i= 0; i < varNames.length; i++) {
			proposal.addLinkedPositionProposal(KEY_NAME, varNames[i], null);
		}
		CastExpression castExpression= ast.newCastExpression();
		castExpression.setExpression((Expression)rewrite.createCopyTarget(expression.getLeftOperand()));
		castExpression.setType((Type)ASTNode.copySubtree(ast, originalType));
		// prepare new variable declaration
		VariableDeclarationFragment vdf= ast.newVariableDeclarationFragment();
		vdf.setName(ast.newSimpleName(varNames[0]));
		vdf.setInitializer(castExpression);
		// prepare new variable declaration statement
		VariableDeclarationStatement vds= ast.newVariableDeclarationStatement(vdf);
		vds.setType((Type)ASTNode.copySubtree(ast, originalType));

		// add new variable declaration statement
		if (negated) {
			ListRewrite listRewriter= rewrite.getListRewrite(body, Block.STATEMENTS_PROPERTY);
			listRewriter.insertAfter(vds, insertionPosition, null);
		} else {
			if (body instanceof Block) {
				ListRewrite listRewriter= rewrite.getListRewrite(body, Block.STATEMENTS_PROPERTY);
				listRewriter.insertAt(vds, 0, null);
			} else {
				Block newBlock= ast.newBlock();
				List<Statement> statements= newBlock.statements();
				statements.add(vds);
				statements.add((Statement) rewrite.createMoveTarget(body));
				rewrite.replace(body, newBlock, null);
			}
		}

		// setup linked positions
		proposal.addLinkedPosition(rewrite.track(vdf.getName()), true, KEY_NAME);
		proposal.addLinkedPosition(rewrite.track(vds.getType()), false, KEY_TYPE);
		proposal.addLinkedPosition(rewrite.track(castExpression.getType()), false, KEY_TYPE);
		proposal.setEndPosition(rewrite.track(vds)); // set cursor after expression statement
		// add correction proposal
		resultingCollections.add(proposal);
		return true;
	}

