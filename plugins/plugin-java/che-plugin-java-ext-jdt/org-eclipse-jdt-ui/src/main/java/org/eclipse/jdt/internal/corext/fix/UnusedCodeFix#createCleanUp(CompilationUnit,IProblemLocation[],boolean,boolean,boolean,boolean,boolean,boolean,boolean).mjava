	public static ICleanUpFix createCleanUp(CompilationUnit compilationUnit, IProblemLocation[] problems,
											boolean removeUnusedPrivateMethods,
											boolean removeUnusedPrivateConstructors,
											boolean removeUnusedPrivateFields,
											boolean removeUnusedPrivateTypes,
											boolean removeUnusedLocalVariables,
											boolean removeUnusedImports,
											boolean removeUnusedCast) {

		List<CompilationUnitRewriteOperation> result = new ArrayList<CompilationUnitRewriteOperation>();
		Hashtable<ASTNode, List<SimpleName>> variableDeclarations = new Hashtable<ASTNode, List<SimpleName>>();
		LinkedHashSet<CastExpression> unnecessaryCasts = new LinkedHashSet<CastExpression>();
		for (int i = 0; i < problems.length; i++) {
			IProblemLocation problem = problems[i];
			int id = problem.getProblemId();

			if (removeUnusedImports && (id == IProblem.UnusedImport || id == IProblem.DuplicateImport || id == IProblem
					.ConflictingImport ||
										id == IProblem.CannotImportPackage || id == IProblem.ImportNotFound)) {
				ImportDeclaration node = UnusedCodeFix.getImportDeclaration(problem, compilationUnit);
				if (node != null) {
					result.add(new RemoveImportOperation(node));
				}
			}

			if ((removeUnusedPrivateMethods && id == IProblem.UnusedPrivateMethod) ||
				(removeUnusedPrivateConstructors && id == IProblem.UnusedPrivateConstructor) ||
				(removeUnusedPrivateTypes && id == IProblem.UnusedPrivateType)) {

				SimpleName name = getUnusedName(compilationUnit, problem);
				if (name != null) {
					IBinding binding = name.resolveBinding();
					if (binding != null) {
						result.add(new RemoveUnusedMemberOperation(new SimpleName[]{name}, false));
					}
				}
			}

			if ((removeUnusedLocalVariables && id == IProblem.LocalVariableIsNeverUsed) ||
				(removeUnusedPrivateFields && id == IProblem.UnusedPrivateField)) {
				SimpleName name = getUnusedName(compilationUnit, problem);
				if (name != null) {
					IBinding binding = name.resolveBinding();
					if (binding instanceof IVariableBinding && !isFormalParameterInEnhancedForStatement(name) &&
						(!((IVariableBinding)binding).isField() || isSideEffectFree(name, compilationUnit))) {
						VariableDeclarationFragment parent =
								(VariableDeclarationFragment)ASTNodes.getParent(name, VariableDeclarationFragment.class);
						if (parent != null) {
							ASTNode varDecl = parent.getParent();
							if (!variableDeclarations.containsKey(varDecl)) {
								variableDeclarations.put(varDecl, new ArrayList<SimpleName>());
							}
							variableDeclarations.get(varDecl).add(name);
						} else {
							result.add(new RemoveUnusedMemberOperation(new SimpleName[]{name}, false));
						}
					}
				}
			}

			if (removeUnusedCast && id == IProblem.UnnecessaryCast) {
				ASTNode selectedNode = problem.getCoveringNode(compilationUnit);

				ASTNode curr = selectedNode;
				while (curr instanceof ParenthesizedExpression) {
					curr = ((ParenthesizedExpression)curr).getExpression();
				}

				if (curr instanceof CastExpression) {
					unnecessaryCasts.add((CastExpression)curr);
				}
			}
		}
		for (Iterator<ASTNode> iter = variableDeclarations.keySet().iterator(); iter.hasNext(); ) {
			ASTNode node = iter.next();
			List<SimpleName> names = variableDeclarations.get(node);
			result.add(new RemoveUnusedMemberOperation(names.toArray(new SimpleName[names.size()]), false));
		}
		if (unnecessaryCasts.size() > 0)
			result.add(new RemoveAllCastOperation(unnecessaryCasts));

		if (result.size() == 0)
			return null;

		return new UnusedCodeFix(FixMessages.UnusedCodeFix_change_name, compilationUnit,
								 result.toArray(new CompilationUnitRewriteOperation[result.size()]));
	}

