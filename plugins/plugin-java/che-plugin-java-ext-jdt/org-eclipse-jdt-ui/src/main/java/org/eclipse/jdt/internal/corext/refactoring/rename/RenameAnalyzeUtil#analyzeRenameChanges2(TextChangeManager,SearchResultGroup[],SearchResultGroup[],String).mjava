  //TODO: Currently filters out declarations (MethodDeclarationMatch, FieldDeclarationMatch).
  //Long term solution: only pass reference search results in.
  static RefactoringStatus analyzeRenameChanges2(
      TextChangeManager manager,
      SearchResultGroup[] oldReferences,
      SearchResultGroup[] newReferences,
      String newElementName) {
    RefactoringStatus result = new RefactoringStatus();

    HashMap<ICompilationUnit, SearchMatch[]> cuToNewResults =
        new HashMap<ICompilationUnit, SearchMatch[]>(newReferences.length);
    for (int i1 = 0; i1 < newReferences.length; i1++) {
      ICompilationUnit cu = newReferences[i1].getCompilationUnit();
      if (cu != null) cuToNewResults.put(cu.getPrimary(), newReferences[i1].getSearchResults());
    }

    for (int i = 0; i < oldReferences.length; i++) {
      SearchResultGroup oldGroup = oldReferences[i];
      SearchMatch[] oldMatches = oldGroup.getSearchResults();
      ICompilationUnit cu = oldGroup.getCompilationUnit();
      if (cu == null) continue;

      SearchMatch[] newSearchMatches = cuToNewResults.remove(cu);
      if (newSearchMatches == null) {
        for (int j = 0; j < oldMatches.length; j++) {
          SearchMatch oldMatch = oldMatches[j];
          addShadowsError(cu, oldMatch, result);
        }
      } else {
        analyzeChanges(cu, manager.get(cu), oldMatches, newSearchMatches, newElementName, result);
      }
    }

    for (Iterator<Entry<ICompilationUnit, SearchMatch[]>> iter =
            cuToNewResults.entrySet().iterator();
        iter.hasNext();
        ) {
      Entry<ICompilationUnit, SearchMatch[]> entry = iter.next();
      ICompilationUnit cu = entry.getKey();
      SearchMatch[] newSearchMatches = entry.getValue();
      for (int i = 0; i < newSearchMatches.length; i++) {
        SearchMatch newMatch = newSearchMatches[i];
        addReferenceShadowedError(cu, newMatch, newElementName, result);
      }
    }
    return result;
  }

