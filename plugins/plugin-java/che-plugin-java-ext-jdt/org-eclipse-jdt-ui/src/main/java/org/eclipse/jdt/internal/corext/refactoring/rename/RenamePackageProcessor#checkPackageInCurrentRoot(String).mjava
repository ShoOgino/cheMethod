  private RefactoringStatus checkPackageInCurrentRoot(String newName) throws CoreException {
    if (fRenameSubpackages) {
      String currentName = getCurrentElementName();
      if (isAncestorPackage(currentName, newName)) {
        // renaming to subpackage (a -> a.b) is always OK, since all subpackages are also renamed
        return null;
      }
      if (!isAncestorPackage(newName, currentName)) {
        // renaming to an unrelated package
        if (!isPackageNameOkInRoot(newName, getPackageFragmentRoot())) {
          return RefactoringStatus.createFatalErrorStatus(
              RefactoringCoreMessages.RenamePackageRefactoring_package_exists);
        }
      }
      // renaming to superpackage (a.b -> a) or another package is OK iff
      // 'a.b' does not contain any subpackage that would collide with another subpackage of 'a'
      // (e.g. a.b.c collides if a.c already exists, but a.b.b does not collide with a.b)
      IPackageFragment[] packsToRename = JavaElementUtil.getPackageAndSubpackages(fPackage);
      for (int i = 0; i < packsToRename.length; i++) {
        IPackageFragment pack = packsToRename[i];
        String newPack = newName + pack.getElementName().substring(currentName.length());
        if (!isAncestorPackage(currentName, newPack)
            && !isPackageNameOkInRoot(newPack, getPackageFragmentRoot())) {
          String msg =
              Messages.format(
                  RefactoringCoreMessages.RenamePackageProcessor_subpackage_collides,
                  BasicElementLabels.getJavaElementName(newPack));
          return RefactoringStatus.createFatalErrorStatus(msg);
        }
      }
      return null;

    } else if (!isPackageNameOkInRoot(newName, getPackageFragmentRoot())) {
      return RefactoringStatus.createFatalErrorStatus(
          RefactoringCoreMessages.RenamePackageRefactoring_package_exists);
    } else {
      return null;
    }
  }

