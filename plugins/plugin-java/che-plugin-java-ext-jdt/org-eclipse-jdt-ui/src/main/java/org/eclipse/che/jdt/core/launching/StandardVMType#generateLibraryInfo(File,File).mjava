	/**
	 * Generates library information for the given java executable. A main
	 * program is run (<code>org.eclipse.jdt.internal.launching.support.
	 * LibraryDetector</code>), that dumps the system properties for bootpath
	 * and extension directories. This output is then parsed and cached for
	 * future reference.
	 *
	 * @param javaHome
	 *         the Java home folder
	 * @param javaExecutable
	 *         the Java executable file
	 * @return library info or <code>null</code> if none
	 */
	protected LibraryInfo generateLibraryInfo(File javaHome, File javaExecutable) {
		LibraryInfo info = null;

		// if this is 1.1.X, the properties will not exist		
		IPath classesZip = new Path(javaHome.getAbsolutePath()).append(LIB).append("classes.zip"); //$NON-NLS-1$ 
		if (classesZip.toFile().exists()) {
			return new LibraryInfo("1.1.x", new String[]{classesZip.toOSString()}, new String[0], new String[0]); //$NON-NLS-1$
		}
//		//locate the launching support jar - it contains the main program to run
//		File file = Launching.getFileInPlugin(new Path("lib/launchingsupport.jar")); //$NON-NLS-1$
//		if (file != null && file.exists()) {
//			String javaExecutablePath = javaExecutable.getAbsolutePath();
//			String[] cmdLine = new String[] { javaExecutablePath, MIN_VM_SIZE,
//					"-classpath", file.getAbsolutePath(), "org.eclipse.jdt.internal.launching.support.LibraryDetector" }; //$NON-NLS-1$
// $NON-NLS-2$
//			Process p = null;
//			try {
//				String envp[] = null;
////				if (Platform.OS_MACOSX.equals(Platform.getOS())) {
////					Map<String, String> map = DebugPlugin.getDefault().getLaunchManager().getNativeEnvironmentCasePreserved();
////					if (map.remove(StandardVMDebugger.JAVA_JVM_VERSION) != null) {
////						envp = new String[map.size()];
////						Iterator<Entry<String, String>> iterator = map.entrySet().iterator();
////						int i = 0;
////						while (iterator.hasNext()) {
////							Entry<String, String> entry = iterator.next();
////							envp[i] = entry.getKey() + "=" + entry.getValue(); //$NON-NLS-1$
////							i++;
////						}
////					}
////				}
//				p = DebugPlugin.exec(cmdLine, null, envp);
//				IProcess process = DebugPlugin.newProcess(new Launch(null, ILaunchManager.RUN_MODE, null), p, "Library Detection");
// $NON-NLS-1$
//				for (int i= 0; i < 600; i++) {
//					// Wait no more than 30 seconds (600 * 50 milliseconds)
//					if (process.isTerminated()) {
//						break;
//					}
//					try {
//						Thread.sleep(50);
//					} catch (InterruptedException e) {
//					}
//				}
//				info = parseLibraryInfo(process);
//			} catch (CoreException ioe) {
//				Launching.log(ioe);
//			} finally {
//				if (p != null) {
//					p.destroy();
//				}
//			}
//		}
		if (info == null) {
			// log error that we were unable to generate library information - see bug 70011
			Launching.log(NLS.bind("Failed to retrieve default libraries for {0}", new String[]{javaHome.getAbsolutePath()}));
			//$NON-NLS-1$
		}
		return info;
	}

