  @Override
  public void endVisit(CastExpression node) {
    //		if (! (expressionCv instanceof CollectionElementVariable2))
    //			return; //TODO: returns too early when dealing with nested collections.

    Type type = node.getType();
    ITypeBinding typeBinding = type.resolveBinding();
    if (typeBinding.isPrimitive()) {
      ImmutableTypeVariable2 boxed = fTCModel.makeImmutableTypeVariable(typeBinding, node);
      setConstraintVariable(node, boxed);
      return; // avoid removing numeric conversions
    }

    ConstraintVariable2 typeCv = getConstraintVariable(type);
    if (typeCv == null) return;

    // TODO: can this be loosened when we remove casts?
    setConstraintVariable(node, typeCv);

    Expression expression = node.getExpression();
    ConstraintVariable2 expressionCv = getConstraintVariable(expression);

    // Avoid removing casts that have not been made obsolete by this refactoring:
    if (expressionCv == null) return;
    if (expressionCv instanceof ImmutableTypeVariable2) return;
    if (!(expressionCv instanceof TypeVariable2
            || expressionCv instanceof IndependentTypeVariable2
            || expressionCv instanceof CollectionElementVariable2)
        && fTCModel.getElementVariables(expressionCv).size() == 0
        && fTCModel.getArrayElementVariable(expressionCv) == null) return;

    fTCModel.createAssignmentElementConstraints(typeCv, expressionCv);

    if (expression instanceof MethodInvocation) {
      MethodInvocation invoc = (MethodInvocation) expression;
      if (!isSpecialCloneInvocation(invoc.resolveMethodBinding(), invoc.getExpression())) {
        fTCModel.makeCastVariable(node, expressionCv);
      }
    } else {
      fTCModel.makeCastVariable(node, expressionCv);
    }

    boolean eitherIsIntf =
        typeBinding.isInterface() || expression.resolveTypeBinding().isInterface();
    if (eitherIsIntf) return;

    // TODO: preserve up- and down-castedness!

  }

