    /**
     * Returns the closest ancestor of <code>node</code> whose type is <code>nodeType</code>, or <code>null</code> if none.
     * <p>
     * <b>Warning:</b> This method does not stop at any boundaries like parentheses, statements, body declarations, etc.
     * The resulting node may be in a totally different scope than the given node.
     * Consider using one of the {@link ASTResolving}<code>.find(..)</code> methods instead.
     * </p>
     * @param node the node
     * @param nodeType the node type constant from {@link org.eclipse.jdt.core.dom.ASTNode}
     * @return the closest ancestor of <code>node</code> whose type is <code>nodeType</code>, or <code>null</code> if none
     */
    public static ASTNode getParent(ASTNode node, int nodeType) {
        do {
            node = node.getParent();
        } while (node != null && node.getNodeType() != nodeType);
        return node;
    }
//
//    public static ASTNode findParent(ASTNode node, StructuralPropertyDescriptor[][] pathes) {
//        for (int p = 0; p < pathes.length; p++) {
//            StructuralPropertyDescriptor[] path = pathes[p];
//            ASTNode current = node;
//            int d = path.length - 1;
//            for (; d >= 0 && current != null; d--) {
//                StructuralPropertyDescriptor descriptor = path[d];
//                if (!descriptor.equals(current.getLocationInParent()))
//                    break;
//                current = current.getParent();
//            }
//            if (d < 0)
//                return current;
//        }
//        return null;
//    }

