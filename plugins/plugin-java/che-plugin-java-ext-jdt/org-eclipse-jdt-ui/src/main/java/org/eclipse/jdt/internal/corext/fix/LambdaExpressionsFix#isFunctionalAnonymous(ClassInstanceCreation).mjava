	static boolean isFunctionalAnonymous(ClassInstanceCreation node) {
		ITypeBinding typeBinding = node.resolveTypeBinding();
		if (typeBinding == null)
			return false;
		ITypeBinding[] interfaces = typeBinding.getInterfaces();
		if (interfaces.length != 1)
			return false;
		if (interfaces[0].getFunctionalInterfaceMethod() == null)
			return false;

		AnonymousClassDeclaration anonymTypeDecl = node.getAnonymousClassDeclaration();
		if (anonymTypeDecl == null || anonymTypeDecl.resolveBinding() == null)
			return false;

		List<BodyDeclaration> bodyDeclarations = anonymTypeDecl.bodyDeclarations();
		// cannot convert if there are fields or additional methods
		if (bodyDeclarations.size() != 1)
			return false;
		BodyDeclaration bodyDeclaration = bodyDeclarations.get(0);
		if (!(bodyDeclaration instanceof MethodDeclaration))
			return false;

		MethodDeclaration methodDecl = (MethodDeclaration)bodyDeclaration;
		IMethodBinding methodBinding = methodDecl.resolveBinding();

		if (methodBinding == null)
			return false;
		// generic lambda expressions are not allowed
		if (methodBinding.isGenericMethod())
			return false;

		// lambda cannot refer to 'this'/'super' literals
		if (SuperThisReferenceFinder.hasReference(methodDecl))
			return false;

		if (!isInTargetTypeContext(node))
			return false;

		return true;
	}

