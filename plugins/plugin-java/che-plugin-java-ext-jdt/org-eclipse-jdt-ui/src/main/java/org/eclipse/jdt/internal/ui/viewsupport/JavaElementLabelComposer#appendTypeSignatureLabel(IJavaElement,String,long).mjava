  protected void appendTypeSignatureLabel(
      IJavaElement enclosingElement, String typeSig, long flags) {
    int sigKind = Signature.getTypeSignatureKind(typeSig);
    switch (sigKind) {
      case Signature.BASE_TYPE_SIGNATURE:
        fBuffer.append(Signature.toString(typeSig));
        break;
      case Signature.ARRAY_TYPE_SIGNATURE:
        appendTypeSignatureLabel(enclosingElement, Signature.getElementType(typeSig), flags);
        for (int dim = Signature.getArrayCount(typeSig); dim > 0; dim--) {
          fBuffer.append('[').append(']');
        }
        break;
      case Signature.CLASS_TYPE_SIGNATURE:
        String baseType = getSimpleTypeName(enclosingElement, typeSig);
        fBuffer.append(baseType);

        String[] typeArguments = Signature.getTypeArguments(typeSig);
        appendTypeArgumentSignaturesLabel(enclosingElement, typeArguments, flags);
        break;
      case Signature.TYPE_VARIABLE_SIGNATURE:
        fBuffer.append(getSimpleTypeName(enclosingElement, typeSig));
        break;
      case Signature.WILDCARD_TYPE_SIGNATURE:
        char ch = typeSig.charAt(0);
        if (ch == Signature.C_STAR) { //workaround for bug 85713
          fBuffer.append('?');
        } else {
          if (ch == Signature.C_EXTENDS) {
            fBuffer.append("? extends "); //$NON-NLS-1$
            appendTypeSignatureLabel(enclosingElement, typeSig.substring(1), flags);
          } else if (ch == Signature.C_SUPER) {
            fBuffer.append("? super "); //$NON-NLS-1$
            appendTypeSignatureLabel(enclosingElement, typeSig.substring(1), flags);
          }
        }
        break;
      case Signature.CAPTURE_TYPE_SIGNATURE:
        appendTypeSignatureLabel(enclosingElement, typeSig.substring(1), flags);
        break;
      case Signature.INTERSECTION_TYPE_SIGNATURE:
        String[] typeBounds = Signature.getIntersectionTypeBounds(typeSig);
        appendTypeBoundsSignaturesLabel(enclosingElement, typeBounds, flags);
        break;
      default:
        // unknown
    }
  }

