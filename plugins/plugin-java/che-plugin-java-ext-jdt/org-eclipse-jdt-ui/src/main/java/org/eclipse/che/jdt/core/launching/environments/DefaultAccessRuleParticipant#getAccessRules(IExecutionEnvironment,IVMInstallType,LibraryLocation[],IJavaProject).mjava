  /* (non-Javadoc)
   * @see org.eclipse.jdt.launching.environments.IAccessRuleParticipant#getAccessRules(org.eclipse.jdt.launching.environments
   * .IExecutionEnvironment, org.eclipse.jdt.launching.IVMInstall, org.eclipse.jdt.launching.LibraryLocation[], org.eclipse.jdt.core
   * .IJavaProject)
   */
  public IAccessRule[][] getAccessRules(
      IExecutionEnvironment environment,
      IVMInstallType vm,
      LibraryLocation[] libraries,
      IJavaProject project) {
    IAccessRule[][] allRules = null;
    allRules = fgRules.get(environment.getId());
    if (allRules == null || allRules.length != libraries.length) {
      // if a different number of libraries, create a new set of rules
      String[] packages = retrieveSystemPackages(environment);
      IAccessRule[] packageRules = null;
      if (packages.length > 0) {
        packageRules = new IAccessRule[packages.length + 1];
        for (int i = 0; i < packages.length; i++) {
          packageRules[i] =
              JavaCore.newAccessRule(
                  new Path(packages[i].replace('.', IPath.SEPARATOR)), IAccessRule.K_ACCESSIBLE);
        }
        // add IGNORE_IF_BETTER flag in case another explicit entry allows access (see bug 228488)
        packageRules[packages.length] =
            JavaCore.newAccessRule(
                new Path("**/*"), IAccessRule.K_NON_ACCESSIBLE | IAccessRule.IGNORE_IF_BETTER);
        // $NON-NLS-1$
      } else {
        packageRules = new IAccessRule[0];
      }
      allRules = new IAccessRule[libraries.length][];
      for (int i = 0; i < allRules.length; i++) {
        allRules[i] = packageRules;
      }
      fgRules.put(environment.getId(), allRules);
    }
    return allRules;
  }

