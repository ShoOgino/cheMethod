  private static void addToStaticAccessOperations(
      CompilationUnit compilationUnit,
      IProblemLocation[] problems,
      boolean changeNonStaticAccessToStatic,
      boolean changeIndirectStaticAccessToDirect,
      List<CompilationUnitRewriteOperation> result) {
    if (!changeNonStaticAccessToStatic && !changeIndirectStaticAccessToDirect) return;

    HashMap<ASTNode, Block> createdBlocks = new HashMap<ASTNode, Block>();
    for (int i = 0; i < problems.length; i++) {
      IProblemLocation problem = problems[i];
      boolean isNonStaticAccess = changeNonStaticAccessToStatic && isNonStaticAccess(problem);
      boolean isIndirectStaticAccess =
          changeIndirectStaticAccessToDirect && isIndirectStaticAccess(problem);
      if (isNonStaticAccess || isIndirectStaticAccess) {
        ToStaticAccessOperation[] nonStaticAccessInformation =
            createToStaticAccessOperations(compilationUnit, createdBlocks, problem, true);
        if (nonStaticAccessInformation != null) {
          ToStaticAccessOperation op = nonStaticAccessInformation[0];

          Expression qualifier = op.fQualifier;
          if (!(qualifier instanceof MethodInvocation) || !isMethodArgument(qualifier)) {
            for (Iterator<CompilationUnitRewriteOperation> it = result.iterator();
                it.hasNext(); ) { // see bug 346230
              CompilationUnitRewriteOperation oper = it.next();
              if (oper instanceof CodeStyleFix.AddThisQualifierOperation
                  && ((CodeStyleFix.AddThisQualifierOperation) oper).fName.equals(qualifier)) {
                result.remove(oper);
                break;
              }
            }
            result.add(op);
          }
        }
      }
    }
  }

