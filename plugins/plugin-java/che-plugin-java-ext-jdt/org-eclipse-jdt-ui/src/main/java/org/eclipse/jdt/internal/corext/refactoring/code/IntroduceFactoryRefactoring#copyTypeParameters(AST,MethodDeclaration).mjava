  /**
   * Copies the constructor's parent type's type parameters, if any, as method type parameters of
   * the new static factory method. (Recall that static methods can't refer to type arguments of the
   * enclosing class, since they have no instance to serve as a context.)<br>
   * Makes sure to copy the bounds from the owning type, to ensure that the return type of the
   * factory method satisfies the bounds of the type being instantiated.<br>
   * E.g., for ctor Foo() in the type Foo<T extends Number>, be sure that the factory method is
   * declared as<br>
   * <code>static <T extends Number> Foo<T> createFoo()</code><br>
   * and not simply<br>
   * <code>static <T> Foo<T> createFoo()</code><br>
   * or the compiler will bark.
   *
   * @param ast utility object needed to create ASTNode's for the new method
   * @param newMethod the method onto which to copy the type parameters
   */
  private void copyTypeParameters(AST ast, MethodDeclaration newMethod) {
    ITypeBinding[] ctorOwnerTypeParms = fCtorBinding.getDeclaringClass().getTypeParameters();
    List<TypeParameter> factoryMethodTypeParms = newMethod.typeParameters();
    for (int i = 0; i < ctorOwnerTypeParms.length; i++) {
      TypeParameter newParm = ast.newTypeParameter();
      ITypeBinding[] parmTypeBounds = ctorOwnerTypeParms[i].getTypeBounds();
      List<Type> newParmBounds = newParm.typeBounds();

      newParm.setName(ast.newSimpleName(ctorOwnerTypeParms[i].getName()));
      for (int b = 0; b < parmTypeBounds.length; b++) {
        if (parmTypeBounds[b].isClass() && parmTypeBounds[b].getSuperclass() == null) continue;

        Type newBound = fImportRewriter.addImport(parmTypeBounds[b], ast);

        newParmBounds.add(newBound);
      }
      factoryMethodTypeParms.add(newParm);
    }
  }

