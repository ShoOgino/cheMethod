	/**
	 * For the type parameter at <code>paramIndex</code> in the type at <code>path[pathIndex]</code>
	 * , this method computes the corresponding type parameter index in the type at
	 * <code>path[0]</code>. If the type parameter does not map to a type parameter of the super
	 * type, <code>-1</code> is returned.
	 *
	 * @param path the type inheritance path, a non-empty array of consecutive sub types
	 * @param pathIndex an index into <code>path</code> specifying the type to start with
	 * @param paramIndex the index of the type parameter to map - <code>path[pathIndex]</code> must
	 *            have a type parameter at that index, lest an
	 *            <code>ArrayIndexOutOfBoundsException</code> is thrown
	 * @return the index of the type parameter in <code>path[0]</code> corresponding to the type
	 *         parameter at <code>paramIndex</code> in <code>path[pathIndex]</code>, or -1 if there
	 *         is no corresponding type parameter
	 * @throws org.eclipse.jdt.core.JavaModelException if this element does not exist or if an exception occurs while
	 *             accessing its corresponding resource
	 * @throws ArrayIndexOutOfBoundsException if <code>path[pathIndex]</code> has &lt;=
	 *             <code>paramIndex</code> parameters
	 */
	private int mapTypeParameterIndex(IType[] path, int pathIndex, int paramIndex) throws JavaModelException, ArrayIndexOutOfBoundsException {
		if (pathIndex == 0)
			// break condition: we've reached the top of the hierarchy
			return paramIndex;

		IType subType= path[pathIndex];
		IType superType= path[pathIndex - 1];

		String superSignature= findMatchingSuperTypeSignature(subType, superType);
		ITypeParameter param= subType.getTypeParameters()[paramIndex];
		int index= findMatchingTypeArgumentIndex(superSignature, param.getElementName());
		if (index == -1) {
			// not mapped through
			return -1;
		}

		return mapTypeParameterIndex(path, pathIndex - 1, index);
	}

