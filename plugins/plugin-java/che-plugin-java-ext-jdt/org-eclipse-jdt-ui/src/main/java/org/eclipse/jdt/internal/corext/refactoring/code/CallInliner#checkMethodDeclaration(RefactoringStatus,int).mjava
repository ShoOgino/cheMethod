  // the checks depend on invocation context and therefore can't be done in SourceAnalyzer
  private void checkMethodDeclaration(RefactoringStatus result, int severity) {
    MethodDeclaration methodDeclaration = fSourceProvider.getDeclaration();
    // it is not allowed to inline constructor invocation only if it is used for class instance creation
    // if constructor is invoked from another constructor then we can inline such invocation
    if (fInvocation.getNodeType() != ASTNode.CONSTRUCTOR_INVOCATION
        && methodDeclaration.isConstructor()) {
      result.addEntry(
          new RefactoringStatusEntry(
              severity,
              RefactoringCoreMessages.CallInliner_constructors,
              JavaStatusContext.create(fCUnit, fInvocation)));
    }
    if (fSourceProvider.hasSuperMethodInvocation()
        && fInvocation.getNodeType() == ASTNode.METHOD_INVOCATION) {
      Expression receiver = ((MethodInvocation) fInvocation).getExpression();
      if (receiver instanceof ThisExpression) {
        result.addEntry(
            new RefactoringStatusEntry(
                severity,
                RefactoringCoreMessages.CallInliner_super_into_this_expression,
                JavaStatusContext.create(fCUnit, fInvocation)));
      }
    }
  }

