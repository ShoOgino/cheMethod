  /**
   * Finds the highest position in <code>document</code> such that the position is &lt;= <code>
   * position</code> and &gt; <code>bound</code> and <code>document.getChar(position) == ch</code>
   * evaluates to <code>true</code> for at least one ch in <code>chars</code> and the position is in
   * the default partition.
   *
   * @param document the document being modified
   * @param position the first character position in <code>document</code> to be considered
   * @param partitioning the document partitioning
   * @param bound the first position in <code>document</code> to not consider any more, with <code>
   *     scanTo</code> &gt; <code>position</code>
   * @param chars an array of <code>char</code> to search for
   * @return the highest position of one element in <code>chars</code> in (<code>bound</code>,
   *     <code>position</code>] that resides in a Java partition, or <code>-1</code> if none can be
   *     found
   */
  private static int scanBackward(
      IDocument document, int position, String partitioning, int bound, char[] chars) {
    Assert.isTrue(bound >= -1);
    Assert.isTrue(position < document.getLength());

    Arrays.sort(chars);

    try {
      while (position > bound) {

        if (Arrays.binarySearch(chars, document.getChar(position)) >= 0
            && isDefaultPartition(document, position, partitioning)) return position;

        position--;
      }
    } catch (BadLocationException e) {
    }
    return -1;
  }

