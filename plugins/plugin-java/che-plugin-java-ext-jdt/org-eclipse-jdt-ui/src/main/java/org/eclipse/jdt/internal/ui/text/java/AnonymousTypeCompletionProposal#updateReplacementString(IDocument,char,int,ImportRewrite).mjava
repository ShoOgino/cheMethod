  /*
   * @see org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposal#updateReplacementString(org.eclipse.jface.text.IDocument, char, int, org.eclipse.jdt.core.dom.rewrite.ImportRewrite)
   */
  @Override
  protected boolean updateReplacementString(
      IDocument document, char trigger, int offset, ImportRewrite impRewrite)
      throws CoreException, BadLocationException {
    fImportRewrite = impRewrite;
    String newBody = createNewBody(impRewrite);
    if (newBody == null) return false;

    CompletionProposal coreProposal = ((MemberProposalInfo) getProposalInfo()).fProposal;
    boolean isAnonymousConstructorInvoc =
        coreProposal.getKind() == CompletionProposal.ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION;

    boolean replacementStringEndsWithParentheses =
        isAnonymousConstructorInvoc || getReplacementString().endsWith(")"); // $NON-NLS-1$

    // construct replacement text: an expression to be formatted
    StringBuffer buf = new StringBuffer("new A("); // $NON-NLS-1$
    if (!replacementStringEndsWithParentheses || isAnonymousConstructorInvoc) buf.append(')');
    buf.append(newBody);

    // use the code formatter
    String lineDelim = TextUtilities.getDefaultLineDelimiter(document);
    final IJavaProject project = fCompilationUnit.getJavaProject();
    IRegion lineInfo = document.getLineInformationOfOffset(getReplacementOffset());
    int indent =
        Strings.computeIndentUnits(
            document.get(lineInfo.getOffset(), lineInfo.getLength()), project);

    Map<String, String> options =
        project != null ? project.getOptions(true) : JavaCore.getOptions();
    options.put(
        DefaultCodeFormatterConstants.FORMATTER_INDENT_EMPTY_LINES,
        DefaultCodeFormatterConstants.TRUE);
    String replacementString =
        CodeFormatterUtil.format(CodeFormatter.K_EXPRESSION, buf.toString(), 0, lineDelim, options);

    int lineEndOffset = lineInfo.getOffset() + lineInfo.getLength();

    int p = offset;
    char ch = document.getChar(p);
    while (p < lineEndOffset) {
      if (ch == '(' || ch == ')' || ch == ';' || ch == ',') break;
      ch = document.getChar(++p);
    }

    if (ch != ';' && ch != ',' && ch != ')') replacementString = replacementString + ';';

    replacementString =
        Strings.changeIndent(
            replacementString,
            0,
            project,
            CodeFormatterUtil.createIndentString(indent, project),
            lineDelim);

    int beginIndex = replacementString.indexOf('(');
    if (!isAnonymousConstructorInvoc) beginIndex++;
    replacementString = replacementString.substring(beginIndex);

    int pos = offset;
    if (isAnonymousConstructorInvoc && (insertCompletion() ^ isInsertModeToggled())) {
      // Keep existing code
      int endPos = pos;
      ch = document.getChar(endPos);
      while (endPos < lineEndOffset
          && ch != '('
          && ch != ')'
          && ch != ';'
          && ch != ','
          && !Character.isWhitespace(ch)) ch = document.getChar(++endPos);

      int keepLength = endPos - pos;
      if (keepLength > 0) {
        String keepStr = document.get(pos, keepLength);
        replacementString = replacementString + keepStr;
        setCursorPosition(replacementString.length() - keepLength);
      }
    } else setCursorPosition(replacementString.length());

    setReplacementString(replacementString);

    if (pos < document.getLength() && document.getChar(pos) == ')') {
      int currentLength = getReplacementLength();
      if (replacementStringEndsWithParentheses) setReplacementLength(currentLength + pos - offset);
      else setReplacementLength(currentLength + pos - offset + 1);
    }
    return false;
  }

