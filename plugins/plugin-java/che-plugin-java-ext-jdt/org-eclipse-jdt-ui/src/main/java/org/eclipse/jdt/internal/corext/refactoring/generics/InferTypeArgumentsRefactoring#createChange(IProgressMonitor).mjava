  /*
   * @see org.eclipse.ltk.core.refactoring.Refactoring#createChange(org.eclipse.core.runtime.IProgressMonitor)
   */
  @Override
  public Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {
    pm.beginTask("", 1); // $NON-NLS-1$
    try {
      DynamicValidationStateChange result =
          new DynamicValidationStateChange(
              RefactoringCoreMessages.InferTypeArgumentsRefactoring_name,
              fChangeManager.getAllChanges()) {

            @Override
            public final ChangeDescriptor getDescriptor() {
              final Map<String, String> arguments = new HashMap<String, String>();
              final IJavaProject project = getSingleProject();
              final String description =
                  RefactoringCoreMessages.InferTypeArgumentsRefactoring_descriptor_description;
              final String header =
                  project != null
                      ? Messages.format(
                          RefactoringCoreMessages
                              .InferTypeArgumentsRefactoring_descriptor_description_project,
                          BasicElementLabels.getJavaElementName(project.getElementName()))
                      : RefactoringCoreMessages
                          .InferTypeArgumentsRefactoring_descriptor_description;
              final String name = project != null ? project.getElementName() : null;
              final JDTRefactoringDescriptorComment comment =
                  new JDTRefactoringDescriptorComment(name, this, header);
              final String[] settings = new String[fElements.length];
              for (int index = 0; index < settings.length; index++)
                settings[index] =
                    JavaElementLabels.getTextLabel(
                        fElements[index], JavaElementLabels.ALL_FULLY_QUALIFIED);
              comment.addSetting(
                  JDTRefactoringDescriptorComment.createCompositeSetting(
                      RefactoringCoreMessages.InferTypeArgumentsRefactoring_original_elements,
                      settings));
              if (fAssumeCloneReturnsSameType)
                comment.addSetting(
                    RefactoringCoreMessages.InferTypeArgumentsRefactoring_assume_clone);
              if (fLeaveUnconstrainedRaw)
                comment.addSetting(
                    RefactoringCoreMessages.InferTypeArgumentsRefactoring_leave_unconstrained);
              final InferTypeArgumentsDescriptor descriptor =
                  RefactoringSignatureDescriptorFactory.createInferTypeArgumentsDescriptor(
                      name,
                      description,
                      comment.asString(),
                      arguments,
                      RefactoringDescriptor.STRUCTURAL_CHANGE | RefactoringDescriptor.MULTI_CHANGE);
              for (int index = 0; index < fElements.length; index++)
                arguments.put(
                    JavaRefactoringDescriptorUtil.ATTRIBUTE_ELEMENT + (index + 1),
                    JavaRefactoringDescriptorUtil.elementToHandle(name, fElements[index]));
              arguments.put(
                  ATTRIBUTE_CLONE, Boolean.valueOf(fAssumeCloneReturnsSameType).toString());
              arguments.put(ATTRIBUTE_LEAVE, Boolean.valueOf(fLeaveUnconstrainedRaw).toString());
              return new RefactoringChangeDescriptor(descriptor);
            }
          };
      return result;
    } finally {
      pm.done();
    }
  }

