		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean visit(final FieldAccess node) {
			if (!fRemoveFieldQualifiers)
				return true;

			Expression expression = node.getExpression();
			if (!(expression instanceof ThisExpression))
				return true;

			final SimpleName name = node.getName();
			if (hasConflict(expression.getStartPosition(), name, ScopeAnalyzer.VARIABLES | ScopeAnalyzer.CHECK_VISIBILITY))
				return true;

			Name qualifier = ((ThisExpression)expression).getQualifier();
			if (qualifier != null) {
				ITypeBinding outerClass = (ITypeBinding)qualifier.resolveBinding();
				if (outerClass == null)
					return true;

				IVariableBinding nameBinding = (IVariableBinding)name.resolveBinding();
				if (nameBinding == null)
					return true;

				ITypeBinding variablesDeclaringClass = nameBinding.getDeclaringClass();
				if (outerClass != variablesDeclaringClass)
					//be conservative: We have a reference to a field of an outer type, and this type inherited
					//the field. It's possible that the inner type inherits the same field. We must not remove
					//the qualifier in this case.
					return true;

				ITypeBinding enclosingTypeBinding = Bindings.getBindingOfParentType(node);
				if (enclosingTypeBinding == null || Bindings.isSuperType(variablesDeclaringClass, enclosingTypeBinding))
					//We have a reference to a field of an outer type, and this type inherited
					//the field. The inner type inherits the same field. We must not remove
					//the qualifier in this case.
					return true;
			}

			fOperations.add(new CompilationUnitRewriteOperation() {
				@Override
				public void rewriteAST(CompilationUnitRewrite cuRewrite, LinkedProposalModel model) throws CoreException {
					ASTRewrite rewrite = cuRewrite.getASTRewrite();
					TextEditGroup group = createTextEditGroup(FixMessages.CodeStyleFix_removeThis_groupDescription, cuRewrite);
					rewrite.replace(node, rewrite.createCopyTarget(name), group);
				}
			});
			return super.visit(node);
		}

