	@SuppressWarnings("boxing")
	protected void appendMethodBody(final IMethod method) throws JavaModelException {
		if (method.isConstructor()) {
			final IType declaringType= method.getDeclaringType();
			String superSignature= declaringType.getSuperclassTypeSignature();
			if (superSignature != null) {
				superSignature= Signature.getTypeErasure(superSignature);
				final IType superclass= declaringType.getJavaProject().findType(
						Signature.getSignatureQualifier(superSignature), Signature.getSignatureSimpleName(superSignature));
				if (superclass != null) {
					final IMethod[] superMethods= superclass.getMethods();
					
					// collect super constructors by parameter count
					Map<Integer, List<IMethod>> superConstructorsByParamCount= new TreeMap<Integer, List<IMethod>>();
					boolean multi= false;
					IMethod superConstructor= null;
					for (int i= 0; i < superMethods.length; i++) {
						IMethod superMethod= superMethods[i];
						if (superMethod.isConstructor()
								&& !Flags.isPrivate(superMethod.getFlags())
								&& !(Flags.isPackageDefault(superMethod.getFlags()) && !declaringType.getPackageFragment().equals(superclass.getPackageFragment()))
								) {
							int paramCount= superMethod.getNumberOfParameters();
							if (paramCount == 0) {
								superConstructor= superMethod;
								break;
							}
							List<IMethod> constructors= superConstructorsByParamCount.get(paramCount);
							if (constructors == null) {
								constructors= new ArrayList<IMethod>();
								superConstructorsByParamCount.put(paramCount, constructors);
							}
							constructors.add(superMethod);
						}
					}
					if (superConstructor == null && superConstructorsByParamCount.size() > 0) {
						// look for constructors without exceptions and without parameters
						done: for (List<IMethod> constructors : superConstructorsByParamCount.values()) {
							for (IMethod constructor : constructors) {
								if (constructor.getExceptionTypes().length == 0) {
									superConstructor= constructor;
									multi= constructors.size() != 1;
									if (multi)
										break;
									else
										break done;
								}
								if (superConstructor == null) {
									superConstructor= constructor;
									multi= constructors.size() != 1;
								}									
							}
						}
						if (superConstructor == null) {
							// give up, get first
							superConstructor= superConstructorsByParamCount.values().iterator().next().get(0);
							multi= true;
						}
					}
					if (superConstructor != null) {
						final String[] superParameters= superConstructor.getParameterTypes();
						final int paramLength= superParameters.length;
						fBuffer.append("super("); //$NON-NLS-1$
						if (paramLength != 0) {
							for (int index= 0; index < paramLength; index++) {
								if (index > 0)
									fBuffer.append(","); //$NON-NLS-1$
								appendExpression(superParameters[index], multi);
							}
						}
						fBuffer.append(");"); //$NON-NLS-1$
					}
				}
			}
		} else {
			String returnType= method.getReturnType();
			if (!Signature.SIG_VOID.equals(returnType)) {
				fBuffer.append("return "); //$NON-NLS-1$
				appendExpression(returnType);
				fBuffer.append(";"); //$NON-NLS-1$
			}
		}
	}

