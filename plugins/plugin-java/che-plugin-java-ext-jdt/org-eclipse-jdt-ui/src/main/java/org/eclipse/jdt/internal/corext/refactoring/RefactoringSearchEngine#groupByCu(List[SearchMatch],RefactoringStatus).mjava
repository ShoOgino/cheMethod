  /**
   * @param matchList a List of SearchMatch
   * @param status the status to report errors.
   * @return a SearchResultGroup[], grouped by SearchMatch#getResource()
   */
  public static SearchResultGroup[] groupByCu(
      List<SearchMatch> matchList, RefactoringStatus status) {
    Map<IResource, List<SearchMatch>> grouped = new HashMap<IResource, List<SearchMatch>>();
    boolean hasPotentialMatches = false;
    boolean hasNonCuMatches = false;

    for (Iterator<SearchMatch> iter = matchList.iterator(); iter.hasNext(); ) {
      SearchMatch searchMatch = iter.next();
      if (searchMatch.getAccuracy() == SearchMatch.A_INACCURATE) hasPotentialMatches = true;
      if (!grouped.containsKey(searchMatch.getResource()))
        grouped.put(searchMatch.getResource(), new ArrayList<SearchMatch>(1));
      grouped.get(searchMatch.getResource()).add(searchMatch);
    }

    for (Iterator<IResource> iter = grouped.keySet().iterator(); iter.hasNext(); ) {
      IResource resource = iter.next();
      IJavaElement element = JavaCore.create(resource);
      if (!(element instanceof ICompilationUnit)) {
        iter.remove();
        hasNonCuMatches = true;
      }
    }

    SearchResultGroup[] result = new SearchResultGroup[grouped.keySet().size()];
    int i = 0;
    for (Iterator<IResource> iter = grouped.keySet().iterator(); iter.hasNext(); ) {
      IResource resource = iter.next();
      List<SearchMatch> searchMatches = grouped.get(resource);
      SearchMatch[] matchArray = searchMatches.toArray(new SearchMatch[searchMatches.size()]);
      result[i] = new SearchResultGroup(resource, matchArray);
      i++;
    }
    addStatusErrors(status, hasPotentialMatches, hasNonCuMatches);
    return result;
  }

