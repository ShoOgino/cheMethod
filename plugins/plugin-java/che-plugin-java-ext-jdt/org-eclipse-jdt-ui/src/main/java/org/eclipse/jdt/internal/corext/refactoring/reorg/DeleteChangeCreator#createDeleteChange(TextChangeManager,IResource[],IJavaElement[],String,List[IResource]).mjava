	/**
	 * @param manager the text change manager
	 * @param resources the resources to delete
	 * @param javaElements the Java elements to delete
	 * @param changeName the name of the change
	 * @param packageDeletes a list of {@link IResource}s that will be deleted
	 *        by the delete operation of the {@link IPackageFragment}s in
	 *        <code>javaElements</code>, or <code>null</code> iff
	 *        <code>javaElements</code> does not contain package fragments
	 * @return the created change
	 * @throws CoreException
	 */
	static Change createDeleteChange(TextChangeManager manager, IResource[] resources,
			IJavaElement[] javaElements, String changeName, List<IResource> packageDeletes) throws CoreException {
		/*
		 * Problem: deleting a package and subpackages can result in
		 * multiple package fragments in fJavaElements but only
		 * one folder in packageDeletes. The way to handle this is to make the undo
		 * change of individual package delete changes an empty change, and
		 * add take care of the undo in UndoablePackageDeleteChange.
		 */
		DynamicValidationStateChange result;
		if (packageDeletes.size() > 0) {
			result= new UndoablePackageDeleteChange(changeName, packageDeletes);
		} else {
			result= new DynamicValidationStateChange(changeName);
		}

		for (int i= 0; i < javaElements.length; i++) {
			IJavaElement element= javaElements[i];
			if (! ReorgUtils.isInsideCompilationUnit(element))
				result.add(createDeleteChange(element));
		}

		for (int i= 0; i < resources.length; i++) {
			result.add(createDeleteChange(resources[i]));
		}

		Map<ICompilationUnit, List<IJavaElement>> grouped= ReorgUtils.groupByCompilationUnit(getElementsSmallerThanCu(javaElements));
		if (grouped.size() != 0 ){
			Assert.isNotNull(manager);
			for (Iterator<ICompilationUnit> iter= grouped.keySet().iterator(); iter.hasNext();) {
				ICompilationUnit cu= iter.next();
				result.add(createDeleteChange(cu, grouped.get(cu), manager));
			}
		}

		return result;
	}

