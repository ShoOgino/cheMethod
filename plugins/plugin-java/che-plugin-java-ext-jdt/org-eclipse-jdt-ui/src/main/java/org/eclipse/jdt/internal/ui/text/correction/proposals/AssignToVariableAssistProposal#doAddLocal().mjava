  private ASTRewrite doAddLocal() {
    Expression expression = ((ExpressionStatement) fNodeToAssign).getExpression();
    AST ast = fNodeToAssign.getAST();

    ASTRewrite rewrite = ASTRewrite.create(ast);

    createImportRewrite((CompilationUnit) fNodeToAssign.getRoot());

    String[] varNames = suggestLocalVariableNames(fTypeBinding, expression);
    for (int i = 0; i < varNames.length; i++) {
      addLinkedPositionProposal(KEY_NAME, varNames[i], null);
    }

    VariableDeclarationFragment newDeclFrag = ast.newVariableDeclarationFragment();
    newDeclFrag.setName(ast.newSimpleName(varNames[0]));
    newDeclFrag.setInitializer((Expression) rewrite.createCopyTarget(expression));

    Type type = evaluateType(ast);

    if (ASTNodes.isControlStatementBody(fNodeToAssign.getLocationInParent())) {
      Block block = ast.newBlock();
      block.statements().add(rewrite.createMoveTarget(fNodeToAssign));
      rewrite.replace(fNodeToAssign, block, null);
    }

    if (needsSemicolon(expression)) {
      VariableDeclarationStatement varStatement = ast.newVariableDeclarationStatement(newDeclFrag);
      varStatement.setType(type);
      rewrite.replace(expression, varStatement, null);
    } else {
      // trick for bug 43248: use an VariableDeclarationExpression and keep the ExpressionStatement
      VariableDeclarationExpression varExpression =
          ast.newVariableDeclarationExpression(newDeclFrag);
      varExpression.setType(type);
      rewrite.replace(expression, varExpression, null);
    }

    addLinkedPosition(rewrite.track(newDeclFrag.getName()), true, KEY_NAME);
    addLinkedPosition(rewrite.track(type), false, KEY_TYPE);
    setEndPosition(rewrite.track(fNodeToAssign)); // set cursor after expression statement

    return rewrite;
  }

