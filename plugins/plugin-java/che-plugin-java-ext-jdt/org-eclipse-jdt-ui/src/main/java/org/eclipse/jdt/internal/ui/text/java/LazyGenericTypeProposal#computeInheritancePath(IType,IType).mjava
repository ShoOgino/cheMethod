	/**
	 * Computes one inheritance path from <code>superType</code> to <code>subType</code> or
	 * <code>null</code> if <code>subType</code> does not inherit from <code>superType</code>. Note
	 * that there may be more than one inheritance path - this method simply returns one.
	 * <p>
	 * The returned array contains <code>superType</code> at its first index, and
	 * <code>subType</code> at its last index. If <code>subType</code> equals <code>superType</code>
	 * , an array of length 1 is returned containing that type.
	 * </p>
	 *
	 * @param subType the sub type
	 * @param superType the super type
	 * @return an inheritance path from <code>superType</code> to <code>subType</code>, or
	 *         <code>null</code> if <code>subType</code> does not inherit from
	 *         <code>superType</code>
	 * @throws org.eclipse.jdt.core.JavaModelException if this element does not exist or if an exception occurs while
	 *             accessing its corresponding resource
	 */
	private IType[] computeInheritancePath(IType subType, IType superType) throws JavaModelException {
		if (superType == null)
			return null;

		// optimization: avoid building the type hierarchy for the identity case
		if (superType.equals(subType))
			return new IType[] { subType };

		ITypeHierarchy hierarchy= subType.newSupertypeHierarchy(getProgressMonitor());
		if (!hierarchy.contains(superType))
			return null; // no path

		List<IType> path= new LinkedList<IType>();
		path.add(superType);
		do {
			// any sub type must be on a hierarchy chain from superType to subType
			superType= hierarchy.getSubtypes(superType)[0];
			path.add(superType);
		} while (!superType.equals(subType)); // since the equality case is handled above, we can spare one check

		return path.toArray(new IType[path.size()]);
	}

