  /**
   * Returns the new type node corresponding to the type of the given declaration including the
   * extra dimensions. If the type is a {@link UnionType}, use the LUB type. If the <code>
   * importRewrite</code> is <code>null</code>, the type may be fully-qualified.
   *
   * @param ast The AST to create the resulting type with.
   * @param declaration The variable declaration to get the type from
   * @param importRewrite the import rewrite to use, or <code>null</code>
   * @param context the import rewrite context, or <code>null</code>
   * @return a new type node created with the given AST.
   * @since 3.7.1
   */
  public static Type newType(
      AST ast,
      VariableDeclaration declaration,
      ImportRewrite importRewrite,
      ImportRewriteContext context) {
    if (declaration instanceof VariableDeclarationFragment
        && declaration.getParent() instanceof LambdaExpression) {
      return newType(
          (LambdaExpression) declaration.getParent(),
          (VariableDeclarationFragment) declaration,
          ast,
          importRewrite,
          context);
    }

    Type type = ASTNodes.getType(declaration);
    if (declaration instanceof SingleVariableDeclaration) {
      Type type2 = ((SingleVariableDeclaration) declaration).getType();
      if (type2 instanceof UnionType) {
        ITypeBinding typeBinding = type2.resolveBinding();
        if (typeBinding != null) {
          if (importRewrite != null) {
            type = importRewrite.addImport(typeBinding, ast, context);
            return type;
          } else {
            String qualifiedName = typeBinding.getQualifiedName();
            if (qualifiedName.length() > 0) {
              type = ast.newSimpleType(ast.newName(qualifiedName));
              return type;
            }
          }
        }
        // XXX: fallback for intersection types or unresolved types: take first type of union
        type = (Type) ((UnionType) type2).types().get(0);
        return type;
      }
    }

    type = (Type) ASTNode.copySubtree(ast, type);

    List<Dimension> extraDimensions = declaration.extraDimensions();
    if (!extraDimensions.isEmpty()) {
      ArrayType arrayType;
      if (type instanceof ArrayType) {
        arrayType = (ArrayType) type;
      } else {
        arrayType = ast.newArrayType(type, 0);
        type = arrayType;
      }
      arrayType.dimensions().addAll(ASTNode.copySubtrees(ast, extraDimensions));
    }
    return type;
  }

