  private void replaceCall(RefactoringStatus status, String[] blocks, TextEditGroup textEditGroup) {
    // Inline empty body
    if (blocks.length == 0 && fTargetNode != null) {
      if (fNeedsStatement) {
        fRewrite.replace(fTargetNode, fTargetNode.getAST().newEmptyStatement(), textEditGroup);
      } else {
        fRewrite.remove(fTargetNode, textEditGroup);
      }
    } else {
      ASTNode node = null;
      for (int i = 0; i < blocks.length - 1; i++) {
        node = fRewrite.createStringPlaceholder(blocks[i], ASTNode.RETURN_STATEMENT);
        fListRewrite.insertAt(node, fInsertionIndex++, textEditGroup);
      }
      String block = blocks[blocks.length - 1];
      // We can inline a call where the declaration is a function and the call itself
      // is a statement. In this case we have to create a temporary variable if the
      // returned expression must be evaluated.
      if (fContext.callMode == ASTNode.EXPRESSION_STATEMENT && fSourceProvider.hasReturnValue()) {
        if (fSourceProvider.mustEvaluateReturnedExpression()) {
          if (fSourceProvider.returnValueNeedsLocalVariable()) {
            IMethodBinding invocation = Invocations.resolveBinding(fInvocation);
            node =
                createLocalDeclaration(
                    invocation.getReturnType(),
                    fInvocationScope.createName(fSourceProvider.getMethodName(), true),
                    (Expression)
                        fRewrite.createStringPlaceholder(block, ASTNode.METHOD_INVOCATION));
          } else {
            node =
                fRewrite
                    .getAST()
                    .newExpressionStatement(
                        (Expression)
                            fRewrite.createStringPlaceholder(block, ASTNode.METHOD_INVOCATION));
          }
        } else {
          node = null;
        }
      } else if (fTargetNode instanceof Expression) {
        node = fRewrite.createStringPlaceholder(block, ASTNode.METHOD_INVOCATION);

        // fixes bug #24941
        if (needsExplicitCast(status)) {
          AST ast = node.getAST();
          CastExpression castExpression = ast.newCastExpression();
          Type returnType = fImportRewrite.addImport(fSourceProvider.getReturnType(), ast);
          castExpression.setType(returnType);

          if (NecessaryParenthesesChecker.needsParentheses(
              fSourceProvider.getReturnExpressions().get(0),
              castExpression,
              CastExpression.EXPRESSION_PROPERTY)) {
            ParenthesizedExpression parenthesized = ast.newParenthesizedExpression();
            parenthesized.setExpression((Expression) node);
            node = parenthesized;
          }

          castExpression.setExpression((Expression) node);
          node = castExpression;

          if (NecessaryParenthesesChecker.needsParentheses(
              castExpression, fTargetNode.getParent(), fTargetNode.getLocationInParent())) {
            ParenthesizedExpression parenthesized = ast.newParenthesizedExpression();
            parenthesized.setExpression((Expression) node);
            node = parenthesized;
          }
        } else if (fSourceProvider.needsReturnedExpressionParenthesis(
            fTargetNode.getParent(), fTargetNode.getLocationInParent())) {
          ParenthesizedExpression pExp = fTargetNode.getAST().newParenthesizedExpression();
          pExp.setExpression((Expression) node);
          node = pExp;
        }
      } else {
        node = fRewrite.createStringPlaceholder(block, ASTNode.RETURN_STATEMENT);
      }

      // Now replace the target node with the source node
      if (node != null) {
        if (fTargetNode == null) {
          fListRewrite.insertAt(node, fInsertionIndex++, textEditGroup);
        } else {
          fRewrite.replace(fTargetNode, node, textEditGroup);
        }
      } else {
        if (fTargetNode != null) {
          fRewrite.remove(fTargetNode, textEditGroup);
        }
      }
    }
  }

