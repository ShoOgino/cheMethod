  private IMethod[] findAllRippleMethods(IProgressMonitor pm, WorkingCopyOwner owner)
      throws CoreException {
    pm.beginTask("", 4); //$NON-NLS-1$

    findAllDeclarations(new SubProgressMonitor(pm, 1), owner);

    //TODO: report assertion as error status and fall back to only return fMethod
    //check for bug 81058:
    if (!fDeclarations.contains(fMethod))
      Assert.isTrue(
          false,
          "Search for method declaration did not find original element: "
              + fMethod.toString()); //$NON-NLS-1$

    createHierarchyOfDeclarations(new SubProgressMonitor(pm, 1), owner);
    createTypeToMethod();
    createUnionFind();
    if (pm.isCanceled()) throw new OperationCanceledException();

    fHierarchy = null;
    fRootTypes = null;

    Map<IType, List<IType>> partitioning = new HashMap<IType, List<IType>>();
    for (Iterator<IType> iter = fTypeToMethod.keySet().iterator(); iter.hasNext(); ) {
      IType type = iter.next();
      IType rep = fUnionFind.find(type);
      List<IType> types = partitioning.get(rep);
      if (types == null) types = new ArrayList<IType>();
      types.add(type);
      partitioning.put(rep, types);
    }
    Assert.isTrue(partitioning.size() > 0);
    if (partitioning.size() == 1) return fDeclarations.toArray(new IMethod[fDeclarations.size()]);

    //Multiple partitions; must look out for nasty marriage cases
    //(types inheriting method from two ancestors, but without redeclaring it).
    IType methodTypeRep = fUnionFind.find(fMethod.getDeclaringType());
    List<IType> relatedTypes = partitioning.get(methodTypeRep);
    boolean hasRelatedInterfaces = false;
    List<IMethod> relatedMethods = new ArrayList<IMethod>();
    for (Iterator<IType> iter = relatedTypes.iterator(); iter.hasNext(); ) {
      IType relatedType = iter.next();
      relatedMethods.add(fTypeToMethod.get(relatedType));
      if (relatedType.isInterface()) hasRelatedInterfaces = true;
    }

    //Definition: An alien type is a type that is not a related type. The set of
    // alien types diminishes as new types become related (a.k.a marry a relatedType).

    List<IMethod> alienDeclarations = new ArrayList<IMethod>(fDeclarations);
    fDeclarations = null;
    alienDeclarations.removeAll(relatedMethods);
    List<IType> alienTypes = new ArrayList<IType>();
    boolean hasAlienInterfaces = false;
    for (Iterator<IMethod> iter = alienDeclarations.iterator(); iter.hasNext(); ) {
      IMethod alienDeclaration = iter.next();
      IType alienType = alienDeclaration.getDeclaringType();
      alienTypes.add(alienType);
      if (alienType.isInterface()) hasAlienInterfaces = true;
    }
    if (alienTypes.size() == 0) //no nasty marriage scenarios without types to marry with...
    return relatedMethods.toArray(new IMethod[relatedMethods.size()]);
    if (!hasRelatedInterfaces
        && !hasAlienInterfaces) //no nasty marriage scenarios without interfaces...
    return relatedMethods.toArray(new IMethod[relatedMethods.size()]);

    //find all subtypes of related types:
    HashSet<IType> relatedSubTypes = new HashSet<IType>();
    List<IType> relatedTypesToProcess = new ArrayList<IType>(relatedTypes);
    while (relatedTypesToProcess.size() > 0) {
      //TODO: would only need subtype hierarchies of all top-of-ripple relatedTypesToProcess
      for (Iterator<IType> iter = relatedTypesToProcess.iterator(); iter.hasNext(); ) {
        if (pm.isCanceled()) throw new OperationCanceledException();
        IType relatedType = iter.next();
        ITypeHierarchy hierarchy =
            getCachedHierarchy(relatedType, owner, new SubProgressMonitor(pm, 1));
        if (hierarchy == null)
          hierarchy = relatedType.newTypeHierarchy(owner, new SubProgressMonitor(pm, 1));
        IType[] allSubTypes = hierarchy.getAllSubtypes(relatedType);
        for (int i = 0; i < allSubTypes.length; i++) relatedSubTypes.add(allSubTypes[i]);
      }
      relatedTypesToProcess.clear(); //processed; make sure loop terminates

      HashSet<IType> marriedAlienTypeReps = new HashSet<IType>();
      for (Iterator<IType> iter = alienTypes.iterator(); iter.hasNext(); ) {
        if (pm.isCanceled()) throw new OperationCanceledException();
        IType alienType = iter.next();
        IMethod alienMethod = fTypeToMethod.get(alienType);
        ITypeHierarchy hierarchy =
            getCachedHierarchy(alienType, owner, new SubProgressMonitor(pm, 1));
        if (hierarchy == null)
          hierarchy = alienType.newTypeHierarchy(owner, new SubProgressMonitor(pm, 1));
        IType[] allSubtypes = hierarchy.getAllSubtypes(alienType);
        for (int i = 0; i < allSubtypes.length; i++) {
          IType subtype = allSubtypes[i];
          if (relatedSubTypes.contains(subtype)) {
            if (JavaModelUtil.isVisibleInHierarchy(alienMethod, subtype.getPackageFragment())) {
              marriedAlienTypeReps.add(fUnionFind.find(alienType));
            } else {
              // not overridden
            }
          }
        }
      }

      if (marriedAlienTypeReps.size() == 0)
        return relatedMethods.toArray(new IMethod[relatedMethods.size()]);

      for (Iterator<IType> iter = marriedAlienTypeReps.iterator(); iter.hasNext(); ) {
        IType marriedAlienTypeRep = iter.next();
        List<IType> marriedAlienTypes = partitioning.get(marriedAlienTypeRep);
        for (Iterator<IType> iterator = marriedAlienTypes.iterator(); iterator.hasNext(); ) {
          IType marriedAlienInterfaceType = iterator.next();
          relatedMethods.add(fTypeToMethod.get(marriedAlienInterfaceType));
        }
        alienTypes.removeAll(marriedAlienTypes); //not alien any more
        relatedTypesToProcess.addAll(marriedAlienTypes); //process freshly married types again
      }
    }

    fRootReps = null;
    fRootHierarchies = null;
    fTypeToMethod = null;
    fUnionFind = null;

    return relatedMethods.toArray(new IMethod[relatedMethods.size()]);
  }

