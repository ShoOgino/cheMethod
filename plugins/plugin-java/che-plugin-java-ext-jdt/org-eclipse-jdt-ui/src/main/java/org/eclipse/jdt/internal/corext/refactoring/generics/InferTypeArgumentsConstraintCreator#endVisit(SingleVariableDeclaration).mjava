  @Override
  public void endVisit(SingleVariableDeclaration node) {
    // used for formal method parameters and catch clauses
    // TODO: extra dimensions?

    //		ConstraintVariable2 typeCv= getConstraintVariable(node.getType()); //TODO: who needs this?

    //		ConstraintVariable2 nameCv;
    //		switch (node.getParent().getNodeType()) {
    //			case ASTNode.METHOD_DECLARATION :
    //				MethodDeclaration parent= (MethodDeclaration) node.getParent();
    //				int index= parent.parameters().indexOf(node);
    //				nameCv= fTCFactory.makeParameterTypeVariable(parent.resolveBinding(), index,
    // node.getType());
    //				//store source range even if variable not used in constraint here. TODO: move to
    // visit(MethodDeclaration)?
    //				break;
    //			case ASTNode.CATCH_CLAUSE :
    //				nameCv= fTCFactory.makeVariableVariable(node.resolveBinding());
    //
    //				break;
    //			default:
    //				unexpectedNode(node.getParent());
    //		}
    //		setConstraintVariable(node, nameCv);

    // TODO: Move this into visit(SimpleName) or leave it here?
    //		ExpressionVariable2 name= fTCFactory.makeExpressionVariable(node.getName());
    //		TypeVariable2 type= fTCFactory.makeTypeVariable(node.getType());
    //		ITypeConstraint2[] nameEqualsType= fTCFactory.createEqualsConstraint(name, type);
    //		addConstraints(nameEqualsType);

    // TODO: When can a SingleVariableDeclaration have an initializer? Never up to Java 1.5?
    Expression initializer = node.getInitializer();
    if (initializer == null) return;

    //		ConstraintVariable2 initializerCv= getConstraintVariable(initializer);
    //		ConstraintVariable2 nameCv= getConstraintVariable(node);
    // TODO: check: property has been set in visit(CatchClause), visit(MethodDeclaration),
    // visit(EnhancedForStatament)
    // fTCFactory.createSubtypeConstraint(initializerCv, nameCv); //TODO: not for augment raw
    // container clients
  }

