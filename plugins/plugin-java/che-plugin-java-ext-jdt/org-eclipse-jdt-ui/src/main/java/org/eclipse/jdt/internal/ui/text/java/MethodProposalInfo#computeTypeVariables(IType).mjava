  /**
   * The type and method signatures received in <code>CompletionProposals</code> of type <code>
   * METHOD_REF</code> contain concrete type bounds. When comparing parameters of the signature with
   * an <code>IMethod</code>, we have to make sure that we match the case where the formal method
   * declaration uses a type variable which in the signature is already substituted with a concrete
   * type (bound).
   *
   * <p>This method creates a map from type variable names to type signatures based on the position
   * they appear in the type declaration. The type signatures are filtered through {@link
   * SignatureUtil#getLowerBound(char[])}.
   *
   * @param type the type to get the variables from
   * @return a map from type variables to concrete type signatures
   * @throws org.eclipse.jdt.core.JavaModelException if accessing the java model fails
   */
  private Map<String, char[]> computeTypeVariables(IType type) throws JavaModelException {
    Map<String, char[]> map = new HashMap<String, char[]>();
    char[] declarationSignature = fProposal.getDeclarationSignature();
    if (declarationSignature == null) // array methods don't contain a declaration signature
    return map;
    char[][] concreteParameters = Signature.getTypeArguments(declarationSignature);

    ITypeParameter[] typeParameters = type.getTypeParameters();
    for (int i = 0; i < typeParameters.length; i++) {
      String variable = typeParameters[i].getElementName();
      if (concreteParameters.length > i)
        // use lower bound since method equality is only parameter based
        map.put(variable, SignatureUtil.getLowerBound(concreteParameters[i]));
      else
        // fProposal.getDeclarationSignature() is a raw type - use Object
        map.put(variable, "Ljava.lang.Object;".toCharArray()); // $NON-NLS-1$
    }

    return map;
  }

