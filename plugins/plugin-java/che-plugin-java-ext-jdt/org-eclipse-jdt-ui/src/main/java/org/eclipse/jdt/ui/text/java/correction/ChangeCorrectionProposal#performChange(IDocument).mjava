	/**
	 * Performs the change associated with this proposal.
	 * <p>
	 * Subclasses may extend, but must call the super implementation.
	 *
	 * @param activeEditor the editor currently active or <code>null</code> if no editor is active
	 * @param document the document of the editor currently active or <code>null</code> if no editor
	 *            is visible
	 * @throws CoreException when the invocation of the change failed
	 */
	protected void performChange(/*IEditorPart activeEditor,*/ IDocument document) throws CoreException {
//		StyledText disabledStyledText = null;
//		TraverseListener traverseBlocker = null;

		Change change = null;
//		IRewriteTarget rewriteTarget = null;
		try {
			change = getChange();
			if (change != null) {
//				if (document != null) {
//					LinkedModeModel.closeAllModels(document);
//				}
//				if (activeEditor != null) {
//					rewriteTarget = (IRewriteTarget)activeEditor.getAdapter(IRewriteTarget.class);
//					if (rewriteTarget != null) {
//						rewriteTarget.beginCompoundChange();
//					}
//					/*
//					 * Workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=195834#c7 :
//					 * During change execution, an EventLoopProgressMonitor can process the event queue while the text
//					 * widget has focus. When that happens and the user e.g. pressed a key, the event is prematurely
//					 * delivered to the text widget and screws up the document. Change execution fails or performs
//					 * wrong changes.
//					 *
//					 * The fix is to temporarily disable the text widget.
//					 */
//					Object control= activeEditor.getAdapter(Control.class);
//					if (control instanceof StyledText) {
//						disabledStyledText= (StyledText) control;
//						if (disabledStyledText.getEditable()) {
//							disabledStyledText.setEditable(false);
//							traverseBlocker= new TraverseListener() {
//								public void keyTraversed(TraverseEvent e) {
//									e.doit= true;
//									e.detail= SWT.TRAVERSE_NONE;
//								}
//							};
//							disabledStyledText.addTraverseListener(traverseBlocker);
//						} else {
//							disabledStyledText= null;
//						}
//					}
//				}

				change.initializeValidationData(new NullProgressMonitor());
				RefactoringStatus valid= change.isValid(new NullProgressMonitor());
				if (valid.hasFatalError()) {
					IStatus status= new Status(IStatus.ERROR, JavaPlugin.getPluginId(), IStatus.ERROR,
						valid.getMessageMatchingSeverity(RefactoringStatus.FATAL), null);
					throw new CoreException(status);
				} else {
//					IUndoManager manager= RefactoringCore.getUndoManager();
					Change undoChange;
					boolean successful= false;
					try {
//						manager.aboutToPerformChange(change);
						undoChange= change.perform(new NullProgressMonitor());
						successful= true;
					} finally {
//						manager.changePerformed(change, successful);
					}
					if (undoChange != null) {
//						undoChange.initializeValidationData(new NullProgressMonitor());
//						manager.addUndo(getName(), undoChange);
					}
				}
			}
		} finally {
//			if (disabledStyledText != null) {
//				disabledStyledText.setEditable(true);
//				disabledStyledText.removeTraverseListener(traverseBlocker);
//				// Workaround to fix bug 434791 during 4.4 RC2. Will be replaced by official API during 4.5.
//				ITextOperationTarget textOperationTarget= (ITextOperationTarget) activeEditor.getAdapter(ITextOperationTarget.class);
//				if (textOperationTarget != null && textOperationTarget.canDoOperation(-100))
//					textOperationTarget.doOperation(-100);
//			}
//			if (rewriteTarget != null) {
//				rewriteTarget.endCompoundChange();
//			}

			if (change != null) {
				change.dispose();
			}
		}
	}

