  private List<ICompletionProposal> internalComputeCompletionProposals(
      int offset, JavaContentAssistInvocationContext context) {
    ICompilationUnit unit = context.getCompilationUnit();
    if (unit == null) return Collections.emptyList();

    ITextViewer viewer = context.getViewer();

    CompletionProposalCollector collector = createCollector(context);
    collector.setInvocationContext(context);

    // Allow completions for unresolved types - since 3.3
    collector.setAllowsRequiredProposals(
        CompletionProposal.FIELD_REF, CompletionProposal.TYPE_REF, true);
    collector.setAllowsRequiredProposals(
        CompletionProposal.FIELD_REF, CompletionProposal.TYPE_IMPORT, true);
    collector.setAllowsRequiredProposals(
        CompletionProposal.FIELD_REF, CompletionProposal.FIELD_IMPORT, true);

    collector.setAllowsRequiredProposals(
        CompletionProposal.METHOD_REF, CompletionProposal.TYPE_REF, true);
    collector.setAllowsRequiredProposals(
        CompletionProposal.METHOD_REF, CompletionProposal.TYPE_IMPORT, true);
    collector.setAllowsRequiredProposals(
        CompletionProposal.METHOD_REF, CompletionProposal.METHOD_IMPORT, true);

    collector.setAllowsRequiredProposals(
        CompletionProposal.CONSTRUCTOR_INVOCATION, CompletionProposal.TYPE_REF, true);

    collector.setAllowsRequiredProposals(
        CompletionProposal.ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION,
        CompletionProposal.TYPE_REF,
        true);
    collector.setAllowsRequiredProposals(
        CompletionProposal.ANONYMOUS_CLASS_DECLARATION, CompletionProposal.TYPE_REF, true);

    collector.setAllowsRequiredProposals(
        CompletionProposal.TYPE_REF, CompletionProposal.TYPE_REF, true);

    // Set the favorite list to propose static members - since 3.3
    collector.setFavoriteReferences(getFavoriteStaticMembers());

    try {
      Point selection = viewer.getSelectedRange();
      if (selection.y > 0) collector.setReplacementLength(selection.y);
      unit.codeComplete(offset, collector, fTimeoutProgressMonitor);
    } catch (OperationCanceledException x) {
      //			IBindingService bindingSvc= (IBindingService)PlatformUI.getWorkbench().getAdapter(IBindingService.class);
      //			String keyBinding= bindingSvc.getBestActiveBindingFormattedFor(IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST);
      //			fErrorMessage= Messages.format(JavaTextMessages.CompletionProcessor_error_javaCompletion_took_too_long_message, keyBinding);
      JavaPlugin.log(x);
    } catch (JavaModelException x) {
      //			Shell shell= viewer.getTextWidget().getShell();
      //			if (x.isDoesNotExist() && !unit.getJavaProject().isOnClasspath(unit))
      //				MessageDialog.openInformation(shell, JavaTextMessages.CompletionProcessor_error_notOnBuildPath_title, JavaTextMessages.CompletionProcessor_error_notOnBuildPath_message);
      //			else
      //				ErrorDialog.openError(shell, JavaTextMessages.CompletionProcessor_error_accessing_title, JavaTextMessages.CompletionProcessor_error_accessing_message, x.getStatus());
      JavaPlugin.log(x);
    }

    ICompletionProposal[] javaProposals = collector.getJavaCompletionProposals();
    int contextInformationOffset = guessMethodContextInformationPosition(context);
    if (contextInformationOffset != offset) {
      for (int i = 0; i < javaProposals.length; i++) {
        if (javaProposals[i] instanceof JavaMethodCompletionProposal) {
          JavaMethodCompletionProposal jmcp = (JavaMethodCompletionProposal) javaProposals[i];
          jmcp.setContextInformationPosition(contextInformationOffset);
        }
      }
    }

    List<ICompletionProposal> proposals =
        new ArrayList<ICompletionProposal>(Arrays.asList(javaProposals));
    if (proposals.size() == 0) {
      String error = collector.getErrorMessage();
      if (error.length() > 0) fErrorMessage = error;
    }
    return proposals;
  }

