  public static void addTypeMismatchInForEachProposals(
      IInvocationContext context, IProblemLocation problem, Collection<ICommandAccess> proposals) {
    CompilationUnit astRoot = context.getASTRoot();
    ASTNode selectedNode = problem.getCoveringNode(astRoot);
    if (selectedNode == null
        || selectedNode.getLocationInParent() != EnhancedForStatement.EXPRESSION_PROPERTY) {
      return;
    }
    EnhancedForStatement forStatement = (EnhancedForStatement) selectedNode.getParent();

    ITypeBinding expressionBinding = forStatement.getExpression().resolveTypeBinding();
    if (expressionBinding == null) {
      return;
    }

    ITypeBinding expectedBinding;
    if (expressionBinding.isArray()) {
      expectedBinding = expressionBinding.getComponentType();
    } else {
      IMethodBinding iteratorMethod =
          Bindings.findMethodInHierarchy(
              expressionBinding, "iterator", new String[0]); // $NON-NLS-1$
      if (iteratorMethod == null) {
        return;
      }
      ITypeBinding[] typeArguments = iteratorMethod.getReturnType().getTypeArguments();
      if (typeArguments.length != 1) {
        return;
      }
      expectedBinding = typeArguments[0];
    }
    AST ast = astRoot.getAST();
    expectedBinding = Bindings.normalizeForDeclarationUse(expectedBinding, ast);

    SingleVariableDeclaration parameter = forStatement.getParameter();

    ICompilationUnit cu = context.getCompilationUnit();
    if (parameter.getName().getLength() == 0) {
      SimpleName simpleName = null;
      if (parameter.getType() instanceof SimpleType) {
        SimpleType type = (SimpleType) parameter.getType();
        if (type.getName() instanceof SimpleName) {
          simpleName = (SimpleName) type.getName();
        }
      } else if (parameter.getType() instanceof NameQualifiedType) {
        simpleName = ((NameQualifiedType) parameter.getType()).getName();
      }
      if (simpleName != null) {
        String name = simpleName.getIdentifier();
        int relevance = StubUtility.hasLocalVariableName(cu.getJavaProject(), name) ? 10 : 7;
        String label =
            Messages.format(
                CorrectionMessages.TypeMismatchSubProcessor_create_loop_variable_description,
                BasicElementLabels.getJavaElementName(name));
        Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_LOCAL);

        proposals.add(
            new NewVariableCorrectionProposal(
                label,
                cu,
                NewVariableCorrectionProposal.LOCAL,
                simpleName,
                null,
                relevance,
                image));
        return;
      }
    }

    String label =
        Messages.format(
            CorrectionMessages.TypeMismatchSubProcessor_incompatible_for_each_type_description,
            new String[] {
              BasicElementLabels.getJavaElementName(parameter.getName().getIdentifier()),
              BindingLabelProvider.getBindingLabel(
                  expectedBinding, BindingLabelProvider.DEFAULT_TEXTFLAGS)
            });
    Image image = JavaPluginImages.get(JavaPluginImages.IMG_CORRECTION_CHANGE);
    ASTRewrite rewrite = ASTRewrite.create(ast);
    ASTRewriteCorrectionProposal proposal =
        new ASTRewriteCorrectionProposal(
            label, cu, rewrite, IProposalRelevance.INCOMPATIBLE_FOREACH_TYPE, image);

    ImportRewrite importRewrite = proposal.createImportRewrite(astRoot);
    ImportRewriteContext importRewriteContext =
        new ContextSensitiveImportRewriteContext(
            ASTResolving.findParentBodyDeclaration(selectedNode), importRewrite);
    Type newType = importRewrite.addImport(expectedBinding, ast, importRewriteContext);
    rewrite.replace(parameter.getType(), newType, null);

    proposals.add(proposal);
  }

