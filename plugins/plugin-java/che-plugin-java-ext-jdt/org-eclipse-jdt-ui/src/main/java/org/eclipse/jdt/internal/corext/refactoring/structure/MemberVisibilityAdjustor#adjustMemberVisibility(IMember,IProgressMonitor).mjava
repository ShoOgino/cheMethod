	/**
	 * Check whether anyone accesses the members of the moved type from the
	 * outside. Those may need to have their visibility adjusted.
	 * @param member the member
	 * @param monitor the progress monitor to use
	 * @throws JavaModelException if an error occurs
	 */
	private void adjustMemberVisibility(final IMember member, final IProgressMonitor monitor) throws JavaModelException {

		if (member instanceof IType) {
			// recursively check accessibility of member type's members
			final IJavaElement[] typeMembers = ((IType)member).getChildren();
			for (int i = 0; i < typeMembers.length; i++) {
				if (!(typeMembers[i] instanceof IInitializer))
					adjustMemberVisibility((IMember)typeMembers[i], monitor);
			}
		}

		if (member.equals(fReferenced) || Modifier.isPublic(member.getFlags()))
			return;

		final SearchResultGroup[] references = findReferences(member, monitor);
		for (int i = 0; i < references.length; i++) {
			final SearchMatch[] searchResults = references[i].getSearchResults();
			for (int k = 0; k < searchResults.length; k++) {
				final IJavaElement referenceToMember = (IJavaElement)searchResults[k].getElement();
				if (fAdjustments.get(member) == null && referenceToMember instanceof IMember && !isInsideMovedMember(referenceToMember)) {
					// check whether the member is still visible from the
					// destination. As we are moving a type, the destination is
					// a package or another type.
					adjustIncomingVisibility(fReferencing, member, new SubProgressMonitor(monitor, 1));
				}
			}
		}
	}

