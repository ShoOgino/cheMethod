  /**
   * Adjusts the visibility of the specified member.
   *
   * @param element the "source" point from which to calculate the visibility
   * @param referencedMovedElement the moved element which may be adjusted in visibility
   * @param monitor the progress monitor to use
   * @throws JavaModelException if the visibility adjustment could not be computed
   */
  private void adjustIncomingVisibility(
      final IJavaElement element, IMember referencedMovedElement, final IProgressMonitor monitor)
      throws JavaModelException {
    final ModifierKeyword threshold =
        getVisibilityThreshold(element, referencedMovedElement, monitor);
    int flags = referencedMovedElement.getFlags();
    IType declaring = referencedMovedElement.getDeclaringType();
    if (declaring != null && declaring.isInterface()
        || referencedMovedElement instanceof IField
            && Flags.isEnum(referencedMovedElement.getFlags())) return;
    if (hasLowerVisibility(flags, threshold == null ? Modifier.NONE : threshold.toFlagValue())
        && needsVisibilityAdjustment(referencedMovedElement, threshold))
      fAdjustments.put(
          referencedMovedElement,
          new IncomingMemberVisibilityAdjustment(
              referencedMovedElement,
              threshold,
              RefactoringStatus.createStatus(
                  fVisibilitySeverity,
                  Messages.format(
                      getMessage(referencedMovedElement),
                      new String[] {getLabel(referencedMovedElement), getLabel(threshold)}),
                  JavaStatusContext.create(referencedMovedElement),
                  null,
                  RefactoringStatusEntry.NO_CODE,
                  null)));
  }

