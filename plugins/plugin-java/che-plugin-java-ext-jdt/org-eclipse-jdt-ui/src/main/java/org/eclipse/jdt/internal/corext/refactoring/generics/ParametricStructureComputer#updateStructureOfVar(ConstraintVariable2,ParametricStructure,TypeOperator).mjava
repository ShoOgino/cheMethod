	/**
	 * Updates the structure of the given ConstraintVariable to be consistent
	 * with the structure of 'type2', in accordance with the given TypeOperator.
	 * If any changes are made, pushes the variable onto fWorkList2.
	 */
	private boolean updateStructureOfVar(ConstraintVariable2 v, ParametricStructure type2, TypeOperator op) {
		if ((type2 == null)) // no structure info to use to update 'v'
			return false ;

		ParametricStructure vStructure= elemStructure(v);
		boolean vStructureUnknown= (vStructure == null);
		boolean type2Structured= type2 != ParametricStructure.NONE;

		if (vStructureUnknown) {
			if (DEBUG_INITIALIZATION)
				System.out.println("  setting structure of " + v + " to " + type2); //$NON-NLS-1$ //$NON-NLS-2$
			setStructureAndPush(v, type2);
			return true;
		}

		boolean vStructured= vStructure != ParametricStructure.NONE;

		if (vStructured && !type2Structured) {
			// If the relation is <=, then it's ok for v to have structure while
			// type2 doesn't. On the other hand, if the relation is >= or ==, 'v'
			// must be made unstructured, since it cannot be structured and be a
			// supertype (or equal to) something unstructured.
			if (op == TypeOperator.Equals || op == TypeOperator.SuperType) {
				setStructureAndPush(v, type2);
				return true;
			}
		} else if (vStructured && type2Structured) { // both are structured (parametric types)
			// rmf 12/15/2004 - handle cases where different parametric types (e.g.
			// List and Map) flow into the same place. If base types are different,
			// conservatively make v unstructured.
			if (!vStructure.getBase().equals(type2.getBase())) { // different parametric types?
				if (op == TypeOperator.SuperType) { // if (v >= other), v can't have parametric structure
					setStructureAndPush(v, ParametricStructure.NONE);
					return true;
				}
			} else if (updateStructureOfType(vStructure, type2)) {
				fWorkList2.push(v);
				return true;
			}
		}
		return false;
	}

