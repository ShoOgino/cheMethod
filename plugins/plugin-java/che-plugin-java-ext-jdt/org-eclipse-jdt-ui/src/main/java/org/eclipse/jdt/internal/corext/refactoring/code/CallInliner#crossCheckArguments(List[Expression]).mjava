  /**
   * Checks whether arguments are passed to the method which do some assignments inside the
   * expression. If so these arguments can't be inlined into the calling method since the
   * assignments might be reorder. An example is: <code>
   *   add((field=args).length,field.hashCode());
   * </code> Field might not be initialized when the arguments are reorder in the called method.
   *
   * @param arguments the arguments
   * @return all arguments that cannot be inlined
   */
  private Set<Expression> crossCheckArguments(List<Expression> arguments) {
    final Set<IBinding> assigned = new HashSet<IBinding>();
    final Set<Expression> result = new HashSet<Expression>();
    for (Iterator<Expression> iter = arguments.iterator(); iter.hasNext(); ) {
      final Expression expression = iter.next();
      expression.accept(
          new ASTVisitor() {
            @Override
            public boolean visit(Assignment node) {
              Expression lhs = node.getLeftHandSide();
              if (lhs instanceof Name) {
                IBinding binding = ((Name) lhs).resolveBinding();
                if (binding instanceof IVariableBinding) {
                  assigned.add(binding);
                  result.add(expression);
                }
              }
              return true;
            }
          });
    }
    for (Iterator<Expression> iter = arguments.iterator(); iter.hasNext(); ) {
      final Expression expression = iter.next();
      if (!result.contains(expression)) {
        expression.accept(
            new HierarchicalASTVisitor() {
              @Override
              public boolean visit(Name node) {
                IBinding binding = node.resolveBinding();
                if (binding != null && assigned.contains(binding)) result.add(expression);
                return false;
              }
            });
      }
    }
    return result;
  }

