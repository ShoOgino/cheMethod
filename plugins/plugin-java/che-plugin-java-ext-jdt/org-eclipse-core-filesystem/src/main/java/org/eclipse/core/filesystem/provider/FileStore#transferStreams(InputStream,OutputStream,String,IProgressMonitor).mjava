	/**
	 * Transfers the contents of an input stream to an output stream, using a large
	 * buffer.
	 *
	 * @param source The input stream to transfer
	 * @param destination The destination stream of the transfer
	 * @param path A path representing the data being transferred for use in error
	 * messages.
	 * @param monitor A progress monitor.  The monitor is assumed to have
	 * already done beginWork with one unit of work allocated per buffer load
	 * of contents to be transferred.
	 * @throws CoreException
	 */
	private static final void transferStreams(InputStream source, OutputStream destination, String path, IProgressMonitor monitor)
			throws CoreException {
		monitor = Policy.monitorFor(monitor);
		try {
			/*
			 * Note: although synchronizing on the buffer is thread-safe,
			 * it may result in slower performance in the future if we want 
			 * to allow concurrent writes.
			 */
			synchronized (buffer) {
				while (true) {
					int bytesRead = -1;
					try {
						bytesRead = source.read(buffer);
					} catch (IOException e) {
						String msg = NLS.bind(Messages.failedReadDuringWrite, path);
						Policy.error(EFS.ERROR_READ, msg, e);
					}
					try {
						if (bytesRead == -1) {
							destination.close();
							break;
						}
						destination.write(buffer, 0, bytesRead);
					} catch (IOException e) {
						String msg = NLS.bind(Messages.couldNotWrite, path);
						Policy.error(EFS.ERROR_WRITE, msg, e);
					}
					monitor.worked(1);
				}
			}
		} finally {
			Policy.safeClose(source);
			Policy.safeClose(destination);
		}
	}

