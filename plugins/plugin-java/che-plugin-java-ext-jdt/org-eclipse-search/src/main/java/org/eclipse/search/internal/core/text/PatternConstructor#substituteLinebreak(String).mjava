  /**
   * Copied from {@link org.eclipse.jface.text.FindReplaceDocumentAdapter}' to support '\R'
   *
   * @param findString the string to substitute
   * @return the new string
   * @throws PatternSyntaxException if "\R" is at an illegal position
   */
  private static String substituteLinebreak(String findString) throws PatternSyntaxException {
    int length = findString.length();
    StringBuffer buf = new StringBuffer(length);

    int inCharGroup = 0;
    int inBraces = 0;
    boolean inQuote = false;
    for (int i = 0; i < length; i++) {
      char ch = findString.charAt(i);
      switch (ch) {
        case '[':
          buf.append(ch);
          if (!inQuote) inCharGroup++;
          break;

        case ']':
          buf.append(ch);
          if (!inQuote) inCharGroup--;
          break;

        case '{':
          buf.append(ch);
          if (!inQuote && inCharGroup == 0) inBraces++;
          break;

        case '}':
          buf.append(ch);
          if (!inQuote && inCharGroup == 0) inBraces--;
          break;

        case '\\':
          if (i + 1 < length) {
            char ch1 = findString.charAt(i + 1);
            if (inQuote) {
              if (ch1 == 'E') inQuote = false;
              buf.append(ch).append(ch1);
              i++;

            } else if (ch1 == 'R') {
              if (inCharGroup > 0 || inBraces > 0) {
                String msg = SearchMessages.PatternConstructor_error_line_delim_position;
                throw new PatternSyntaxException(msg, findString, i);
              }
              buf.append("(?>\\r\\n?|\\n)"); //$NON-NLS-1$
              i++;

            } else {
              if (ch1 == 'Q') {
                inQuote = true;
              }
              buf.append(ch).append(ch1);
              i++;
            }
          } else {
            buf.append(ch);
          }
          break;

        default:
          buf.append(ch);
          break;
      }
    }
    return buf.toString();
  }

