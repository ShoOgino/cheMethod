    /**
     * Interprets escaped characters in the given replace pattern.
     *
     * @param replaceText the replace pattern
     * @param foundText the found pattern to be replaced
     * @return a replace pattern with escaped characters substituted by the respective characters
     * @since 3.4
     */
    private String interpretReplaceEscapes(String replaceText, String foundText) {
      int length = replaceText.length();
      boolean inEscape = false;
      StringBuffer buf = new StringBuffer(length);

      /* every string we did not check looks mixed at first
       * so initialize retain case mode with RC_MIXED
       */
      fRetainCaseMode = RC_MIXED;

      for (int i = 0; i < length; i++) {
        final char ch = replaceText.charAt(i);
        if (inEscape) {
          i = interpretReplaceEscape(ch, i, buf, replaceText, foundText);
          inEscape = false;

        } else if (ch == '\\') {
          inEscape = true;

        } else if (ch == '$') {
          buf.append(ch);

          /*
           * Feature in java.util.regex.Matcher#replaceFirst(String):
           * $00, $000, etc. are interpreted as $0 and
           * $01, $001, etc. are interpreted as $1, etc. .
           * If we support \0 as replacement pattern for capturing group 0,
           * it would not be possible any more to write a replacement pattern
           * that appends 0 to a capturing group (like $0\0).
           * The fix is to interpret \00 and $00 as $0\0, and
           * \01 and $01 as $0\1, etc.
           */
          if (i + 2 < length) {
            char ch1 = replaceText.charAt(i + 1);
            char ch2 = replaceText.charAt(i + 2);
            if (ch1 == '0' && '0' <= ch2 && ch2 <= '9') {
              buf.append("0\\"); // $NON-NLS-1$
              i++; // consume the 0
            }
          }
        } else {
          interpretRetainCase(buf, ch);
        }
      }

      if (inEscape) {
        // '\' as last character is invalid, but we still add it to get an error message
        buf.append('\\');
      }
      return buf.toString();
    }

