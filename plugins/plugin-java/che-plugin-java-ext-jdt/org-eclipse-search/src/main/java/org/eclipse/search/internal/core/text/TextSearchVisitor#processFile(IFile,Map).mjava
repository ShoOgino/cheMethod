  /** // * @return returns a map from IFile to IDocument for all open, dirty editors // */
  //	private Map evalNonFileBufferDocuments() {
  //		Map result = new HashMap();
  //		IWorkbench workbench = SearchPlugin.getDefault().getWorkbench();
  //		IWorkbenchWindow[] windows = workbench.getWorkbenchWindows();
  //		for (int i = 0; i < windows.length; i++) {
  //			IWorkbenchPage[] pages = windows[i].getPages();
  //			for (int x = 0; x < pages.length; x++) {
  //				IEditorReference[] editorRefs = pages[x].getEditorReferences();
  //				for (int z = 0; z < editorRefs.length; z++) {
  //					IEditorPart ep = editorRefs[z].getEditor(false);
  //					if (ep instanceof ITextEditor && ep.isDirty()) { // only dirty editors
  //						evaluateTextEditor(result, ep);
  //					}
  //				}
  //			}
  //		}
  //		return result;
  //	}

  //	private void evaluateTextEditor(Map result, IEditorPart ep) {
  //		IEditorInput input= ep.getEditorInput();
  //		if (input instanceof IFileEditorInput) {
  //			IFile file= ((IFileEditorInput) input).getFile();
  //			if (!result.containsKey(file)) { // take the first editor found
  //				ITextFileBufferManager bufferManager= FileBuffers.getTextFileBufferManager();
  //				ITextFileBuffer textFileBuffer= bufferManager.getTextFileBuffer(file.getFullPath(), LocationKind.IFILE);
  //				if (textFileBuffer != null) {
  //					// file buffer has precedence
  //					result.put(file, textFileBuffer.getDocument());
  //				} else {
  //					// use document provider
  //					IDocument document= ((ITextEditor) ep).getDocumentProvider().getDocument(input);
  //					if (document != null) {
  //						result.put(file, document);
  //					}
  //				}
  //			}
  //		}
  //	}

  public boolean processFile(IFile file, Map documentsInEditors) {
    try {
      if (!fCollector.acceptFile(file) || fMatcher == null) {
        return true;
      }

      IDocument document = getOpenDocument(file, documentsInEditors);

      if (document != null) {
        DocumentCharSequence documentCharSequence = new DocumentCharSequence(document);
        // assume all documents are non-binary
        locateMatches(file, documentCharSequence);
      } else {
        CharSequence seq = null;
        try {
          seq = fFileCharSequenceProvider.newCharSequence(file);
          if (hasBinaryContent(seq, file) && !fCollector.reportBinaryFile(file)) {
            return true;
          }
          locateMatches(file, seq);
        } catch (FileCharSequenceProvider.FileCharSequenceException e) {
          e.throwWrappedException();
        } finally {
          if (seq != null) {
            try {
              fFileCharSequenceProvider.releaseCharSequence(seq);
            } catch (IOException e) {
              SearchPlugin.log(e);
            }
          }
        }
      }
    } catch (UnsupportedCharsetException e) {
      String[] args = {getCharSetName(file), file.getFullPath().makeRelative().toString()};
      String message = Messages.format(SearchMessages.TextSearchVisitor_unsupportedcharset, args);
      fStatus.add(new Status(IStatus.ERROR, NewSearchUI.PLUGIN_ID, IStatus.ERROR, message, e));
    } catch (IllegalCharsetNameException e) {
      String[] args = {getCharSetName(file), file.getFullPath().makeRelative().toString()};
      String message = Messages.format(SearchMessages.TextSearchVisitor_illegalcharset, args);
      fStatus.add(new Status(IStatus.ERROR, NewSearchUI.PLUGIN_ID, IStatus.ERROR, message, e));
    } catch (IOException e) {
      String[] args = {getExceptionMessage(e), file.getFullPath().makeRelative().toString()};
      String message = Messages.format(SearchMessages.TextSearchVisitor_error, args);
      fStatus.add(new Status(IStatus.ERROR, NewSearchUI.PLUGIN_ID, IStatus.ERROR, message, e));
    } catch (CoreException e) {
      String[] args = {getExceptionMessage(e), file.getFullPath().makeRelative().toString()};
      String message = Messages.format(SearchMessages.TextSearchVisitor_error, args);
      fStatus.add(new Status(IStatus.ERROR, NewSearchUI.PLUGIN_ID, IStatus.ERROR, message, e));
    } catch (StackOverflowError e) {
      String message = SearchMessages.TextSearchVisitor_patterntoocomplex0;
      fStatus.add(new Status(IStatus.ERROR, NewSearchUI.PLUGIN_ID, IStatus.ERROR, message, e));
      return false;
    } finally {
      fNumberOfScannedFiles++;
    }
    if (fProgressMonitor.isCanceled())
      throw new OperationCanceledException(SearchMessages.TextSearchVisitor_canceled);

    return true;
  }

