	private UndoEdit performEdits(ITextFileBuffer buffer, final IDocument document, final boolean[] setContentStampSuccess) throws MalformedTreeException, BadLocationException, CoreException {
		if (! buffer.isSynchronizationContextRequested()) {
			return doPerformEdits(document, setContentStampSuccess);
		}
		
		ITextFileBufferManager fileBufferManager= FileBuffers.getTextFileBufferManager();
		
		/** The lock for waiting for computation in the UI thread to complete. */
		final Lock completionLock= new Lock();
		final UndoEdit[] result= new UndoEdit[1];
		final BadLocationException[] badLocationException= new BadLocationException[1];
		final MalformedTreeException[] malformedTreeException= new MalformedTreeException[1];
		final CoreException[] coreException= new CoreException[1];
		Runnable runnable= new Runnable() {
			public void run() {
				synchronized (completionLock) {
					try {
						result[0]= doPerformEdits(document, setContentStampSuccess);
					} catch (BadLocationException e) {
						badLocationException[0]= e;
					} catch (MalformedTreeException e) {
						malformedTreeException[0]= e;
					} catch (CoreException e) {
						coreException[0]= e;
					} finally {
						completionLock.fDone= true;
						completionLock.notifyAll();
					}
				}
			}
		};
		
		synchronized (completionLock) {
			fileBufferManager.execute(runnable);
			while (! completionLock.fDone) {
				try {
					completionLock.wait(500);
				} catch (InterruptedException x) {
				}
			}
		}
		
		if (badLocationException[0] != null) {
			throw badLocationException[0];
		} else if (malformedTreeException[0] != null) {
			throw malformedTreeException[0];
		} else if (coreException[0] != null) {
			throw coreException[0];
		}
		return result[0];
	}

