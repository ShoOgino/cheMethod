  /* (non-Javadoc)
   * @see org.eclipse.ltk.core.refactoring.Change#perform(org.eclipse.core.runtime.IProgressMonitor)
   */
  public Change perform(IProgressMonitor pm) throws CoreException {
    if (pm == null) pm = new NullProgressMonitor();

    pm.beginTask("", 10); // $NON-NLS-1$
    pm.setTaskName(RefactoringCoreMessages.DeleteResourceChange_deleting);

    try {
      IResource resource = getResource();
      if (resource == null || !resource.exists()) {
        if (fDeleteContent) return null; // see https://bugs.eclipse.org/343584
        String message =
            Messages.format(
                RefactoringCoreMessages.DeleteResourceChange_error_resource_not_exists,
                BasicElementLabels.getPathLabel(fResourcePath.makeRelative(), false));
        throw new CoreException(
            new Status(IStatus.ERROR, RefactoringCorePlugin.getPluginId(), message));
      }

      // make sure all files inside the resource are saved so restoring works
      if (resource.isAccessible()) {
        resource.accept(
            new IResourceVisitor() {
              public boolean visit(IResource curr) throws CoreException {
                try {
                  if (curr instanceof IFile) {
                    // progress is covered outside.
                    saveFileIfNeeded((IFile) curr, new NullProgressMonitor());
                  }
                } catch (CoreException e) {
                  // ignore
                }
                return true;
              }
            },
            IResource.DEPTH_INFINITE,
            false);
      }

      ResourceUndoState desc = ResourceUndoState.fromResource(resource);
      if (resource instanceof IProject) {
        ((IProject) resource)
            .delete(fDeleteContent, fForceOutOfSync, new SubProgressMonitor(pm, 10));
      } else {
        int updateFlags;
        if (fForceOutOfSync) {
          updateFlags = IResource.KEEP_HISTORY | IResource.FORCE;
        } else {
          updateFlags = IResource.KEEP_HISTORY;
        }
        resource.delete(updateFlags, new SubProgressMonitor(pm, 5));
        desc.recordStateFromHistory(resource, new SubProgressMonitor(pm, 5));
      }
      return new UndoDeleteResourceChange(desc);
    } finally {
      pm.done();
    }
  }

