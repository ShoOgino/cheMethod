  @Override
  public void delete(int updateFlags, IProgressMonitor monitor) throws CoreException {
    monitor = Policy.monitorFor(monitor);
    try {
      //            String message = NLS.bind(Messages.resources_deleting, getFullPath());
      //            monitor.beginTask("", Policy.totalWork * 1000); //$NON-NLS-1$
      //            monitor.subTask(message);
      final ISchedulingRule rule = workspace.getRuleFactory().deleteRule(this);
      try {
        workspace.prepareOperation(rule, monitor);
        // if there is no resource then there is nothing to delete so just return
        if (!exists()) return;
        workspace.beginOperation(true);
        //                broadcastPreDeleteEvent();

        // when a project is being deleted, flush the build order in case there is a problem
        //                if (this.getType() == IResource.PROJECT)
        //                    workspace.flushBuildOrder();

        //                final IFileStore originalStore = getStore();
        //                boolean wasLinked = isLinked();
        //                message = Messages.resources_deleteProblem;
        //                MultiStatus status = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_DELETE_LOCAL, message, null);
        WorkManager workManager = workspace.getWorkManager();
        //                ResourceTree tree = new ResourceTree(workspace.getFileSystemManager(), workManager.getLock(), status, updateFlags);
        int depth = 0;
        try {
          depth = workManager.beginUnprotected();
          workspace.delete(this);
          //                    unprotectedDelete(tree, updateFlags, monitor);
        } finally {
          workManager.endUnprotected(depth);
        }
        if (getType() == ROOT) {
          //                    // need to clear out the root info
          //                    workspace.getMarkerManager().removeMarkers(this, IResource.DEPTH_ZERO);
          //                    getPropertyManager().deleteProperties(this, IResource.DEPTH_ZERO);
          //                    getResourceInfo(false, false).clearSessionProperties();
        }
        // Invalidate the tree for further use by clients.
        //                tree.makeInvalid();
        //                if (!tree.getStatus().isOK())
        //                    throw new ResourceException(tree.getStatus());
        //update any aliases of this resource
        //note that deletion of a linked resource cannot affect other resources
        //                if (!wasLinked)
        //                    workspace.getAliasManager().updateAliases(this, originalStore, IResource.DEPTH_INFINITE, monitor);
        //                if (getType() == PROJECT) {
        //                     make sure the rule factory is cleared on project deletion
        //                    ((Rules) workspace.getRuleFactory()).setRuleFactory((IProject) this, null);
        //                     make sure project deletion is remembered
        //                    workspace.getSaveManager().requestSnapshot();
        //                }
      } catch (OperationCanceledException e) {
        workspace.getWorkManager().operationCanceled();
        throw e;
      } finally {
        workspace.endOperation(rule, true, Policy.subMonitorFor(monitor, Policy.endOpWork * 1000));
      }
    } finally {
      monitor.done();
    }
  }

