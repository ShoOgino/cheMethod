  /*
   * Do the real flushing in a non-synchronized internal method so sub-classes
   * (mainly ProjectPreferences and ProfilePreferences) don't cause deadlocks.
   *
   * If this node is not responsible for persistence (a load level), then this method
   * returns the node that should be flushed. Returns null if this method performed
   * the flush.
   */
  protected IEclipsePreferences internalFlush() throws BackingStoreException {
    //         illegal state if this node has been removed
    //        checkRemoved();

    //        IEclipsePreferences loadLevel = null;//getLoadLevel();

    //        // if this node or a parent is not the load level, then flush the children
    //        if (loadLevel == null) {
    //            String[] childrenNames = childrenNames();
    //            for (int i = 0; i < childrenNames.length; i++)
    //                node(childrenNames[i]).flush();
    //            return null;
    //        }
    //
    //        // a parent is the load level for this node
    //        if (this != loadLevel)
    //            return loadLevel;

    // this node is a load level
    // any work to do?
    if (!dirty) return null;
    //remove dirty bit before saving, to ensure that concurrent
    //changes during save mark the store as dirty
    dirty = false;
    try {
      save();
    } catch (BackingStoreException e) {
      //mark it dirty again because the save failed
      dirty = true;
      throw e;
    }
    return null;
  }

