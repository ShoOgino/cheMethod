	/**
	 * Deletes the given resources.
	 * <p>
	 * This method can be expressed as a series of calls to
	 * <code>IResource.delete(int,IProgressMonitor)</code>.
	 * </p>
	 * <p>
	 * The semantics of multiple deletion are:
	 * <ul>
	 * <li>Resources are deleted in the order presented, using the given update
	 * flags.</li>
	 * <li>Resources that do not exist are ignored.</li>
	 * <li>An individual deletion fails if the resource still exists
	 * afterwards.</li>
	 * <li>The failure of an individual deletion does not prevent the method
	 * from attempting to delete other resources.</li>
	 * <li>This method fails if one or more of the individual resource
	 * deletions fails; that is, if at least one of the resources in the list
	 * still exists at the end of this method.</li>
	 * </ul>
	 * </p>
	 * <p>
	 * This method changes resources; these changes will be reported in a
	 * subsequent resource change event.
	 * </p>
	 * <p>
	 * This method is long-running; progress and cancellation are provided by
	 * the given progress monitor.
	 * </p>
	 * 
	 * @param resources the resources to delete
	 * @param updateFlags bit-wise or of update flag constants
	 * @param monitor a progress monitor, or <code>null</code> if progress
	 * reporting is not desired
	 * @return status with code <code>OK</code> if there were no problems;
	 * otherwise a description (possibly a multi-status) consisting of
	 * low-severity warnings or informational messages
	 * @exception CoreException if the method fails to delete some resource. The
	 * status contained in the exception is a multi-status indicating where the
	 * individual failures occurred.
	 * @exception OperationCanceledException if the operation is canceled. 
	 * Cancelation can occur even if no progress monitor is provided.
	 * @see IResource#delete(int,IProgressMonitor)
	 * @see IResourceRuleFactory#deleteRule(IResource)
	 * @since 2.0
	 */
	public IStatus delete(IResource[] resources, int updateFlags, IProgressMonitor monitor) throws CoreException;

