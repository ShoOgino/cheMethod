  /**
   * End an operation (group of resource changes). Notify interested parties that resource changes
   * have taken place. All registered resource change listeners are notified. If autobuilding is
   * enabled, a build is run.
   */
  public void endOperation(ISchedulingRule rule, boolean build, IProgressMonitor monitor)
      throws CoreException {
    WorkManager workManager = getWorkManager();
    //don't do any end operation work if we failed to check in
    if (workManager.checkInFailed(rule)) return;
    // This is done in a try finally to ensure that we always decrement the operation count
    // and release the workspace lock.  This must be done at the end because snapshot
    // and "hasChanges" comparison have to happen without interference from other threads.
    boolean hasTreeChanges = false;
    boolean depthOne = false;
    try {
      workManager.setBuild(build);
      // if we are not exiting a top level operation then just decrement the count and return
      depthOne = workManager.getPreparedOperationDepth() == 1;
      //            if (!(notificationManager.shouldNotify() || depthOne)) {
      //                notificationManager.requestNotify();
      //                return;
      //            }
      // do the following in a try/finally to ensure that the operation tree is nulled at the end
      // as we are completing a top level operation.
      try {
        //                notificationManager.beginNotify();
        // check for a programming error on using beginOperation/endOperation
        Assert.isTrue(
            workManager.getPreparedOperationDepth() > 0,
            "Mismatched begin/endOperation"); //$NON-NLS-1$

        // At this time we need to re-balance the nested operations. It is necessary because
        // build() and snapshot() should not fail if they are called.
        workManager.rebalanceNestedOperations();

        //find out if any operation has potentially modified the tree
        //                hasTreeChanges = workManager.shouldBuild();
        //double check if the tree has actually changed
        //                if (hasTreeChanges)
        //                    hasTreeChanges = operationTree != null && ElementTree.hasChanges(tree, operationTree, ResourceComparator
        // .getBuildComparator(), true);
        //                broadcastPostChange();
        //                // Request a snapshot if we are sufficiently out of date.
        //                saveManager.snapshotIfNeeded(hasTreeChanges);
      } finally {
        //                // make sure the tree is immutable if we are ending a top-level operation.
        //                if (depthOne) {
        //                    tree.immutable();
        //                    operationTree = null;
        //                } else
        //                    newWorkingTree();
      }
    } finally {
      workManager.checkOut(rule);
    }
    //        if (depthOne)
    //            buildManager.endTopLevel(hasTreeChanges);
  }

