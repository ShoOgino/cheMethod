  @Override
  public IStatus delete(IResource[] resources, int updateFlags, IProgressMonitor monitor)
      throws CoreException {
    monitor = Policy.monitorFor(monitor);
    try {
      int opWork = Math.max(resources.length, 1);
      int totalWork = Policy.totalWork * opWork / Policy.opWork;
      String message = Messages.resources_deleting_0;
      monitor.beginTask(message, totalWork);
      message = Messages.resources_deleteProblem;
      MultiStatus result =
          new MultiStatus(
              ResourcesPlugin.PI_RESOURCES, IResourceStatus.INTERNAL_ERROR, message, null);
      if (resources.length == 0) return result;
      resources = resources.clone(); // to avoid concurrent changes to this array
      try {
        prepareOperation(getRoot(), monitor);
        beginOperation(true);
        for (int i = 0; i < resources.length; i++) {
          Policy.checkCanceled(monitor);
          Resource resource = (Resource) resources[i];
          if (resource == null) {
            monitor.worked(1);
            continue;
          }
          try {
            resource.delete(updateFlags, Policy.subMonitorFor(monitor, 1));
          } catch (CoreException e) {
            // Don't really care about the exception unless the resource is still around.
            ResourceInfo info = resource.getResourceInfo(false, false);
            if (resource.exists(resource.getFlags(info), false)) {
              message = NLS.bind(Messages.resources_couldnotDelete, resource.getFullPath());
              result.merge(
                  new org.eclipse.core.internal.resources.ResourceStatus(
                      IResourceStatus.FAILED_DELETE_LOCAL, resource.getFullPath(), message));
              result.merge(e.getStatus());
            }
          }
        }
        if (result.matches(IStatus.ERROR)) throw new ResourceException(result);
        return result;
      } catch (OperationCanceledException e) {
        getWorkManager().operationCanceled();
        throw e;
      } finally {
        endOperation(getRoot(), true, Policy.subMonitorFor(monitor, totalWork - opWork));
      }
    } finally {
      monitor.done();
    }
  }

