	/**
	 * Computes a total ordering of the given projects based on both static and
	 * dynamic project references. If an existing and open project P references
	 * another existing and open project Q also included in the list, then Q
	 * should come before P in the resulting ordering. Closed and non-existent
	 * projects are ignored, and will not appear in the result. References to
	 * non-existent or closed projects are also ignored, as are any
	 * self-references. The total ordering is always consistent with the global
	 * total ordering of all open projects in the workspace.
	 * <p>
	 * When there are choices, the choice is made in a reasonably stable way.
	 * For example, given an arbitrary choice between two projects, the one with
	 * the lower collating project name is usually selected.
	 * </p>
	 * <p>
	 * When the project reference graph contains cyclic references, it is
	 * impossible to honor all of the relationships. In this case, the result
	 * ignores as few relationships as possible. For example, if P2 references
	 * P1, P4 references P3, and P2 and P3 reference each other, then exactly
	 * one of the relationships between P2 and P3 will have to be ignored. The
	 * outcome will be either [P1, P2, P3, P4] or [P1, P3, P2, P4]. The result
	 * also contains complete details of any cycles present.
	 * </p>
	 * <p>
	 * This method is time-consuming and should not be called unnecessarily.
	 * There are a very limited set of changes to a workspace that could affect
	 * the outcome: creating, renaming, or deleting a project; opening or
	 * closing a project; adding or removing a project reference.
	 * </p>
	 * 
	 * @param projects the projects to order
	 * @return result describing the project order
	 * @since 2.1
	 */
	public ProjectOrder computeProjectOrder(IProject[] projects);

