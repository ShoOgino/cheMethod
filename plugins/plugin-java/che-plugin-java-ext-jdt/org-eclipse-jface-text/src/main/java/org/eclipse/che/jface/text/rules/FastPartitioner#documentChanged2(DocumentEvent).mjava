  /**
   * {@inheritDoc}
   *
   * <p>May be extended by subclasses.
   */
  public IRegion documentChanged2(DocumentEvent e) {

    if (!fIsInitialized) return null;

    try {
      Assert.isTrue(e.getDocument() == fDocument);

      Position[] category = getPositions();
      IRegion line = fDocument.getLineInformationOfOffset(e.getOffset());
      int reparseStart = line.getOffset();
      int partitionStart = -1;
      String contentType = null;
      int newLength = e.getText() == null ? 0 : e.getText().length();

      int first = fDocument.computeIndexInCategory(fPositionCategory, reparseStart);
      if (first > 0) {
        TypedPosition partition = (TypedPosition) category[first - 1];
        if (partition.includes(reparseStart)) {
          partitionStart = partition.getOffset();
          contentType = partition.getType();
          if (e.getOffset() == partition.getOffset() + partition.getLength())
            reparseStart = partitionStart;
          --first;
        } else if (reparseStart == e.getOffset()
            && reparseStart == partition.getOffset() + partition.getLength()) {
          partitionStart = partition.getOffset();
          contentType = partition.getType();
          reparseStart = partitionStart;
          --first;
        } else {
          partitionStart = partition.getOffset() + partition.getLength();
          contentType = IDocument.DEFAULT_CONTENT_TYPE;
        }
      }

      fPositionUpdater.update(e);
      for (int i = first; i < category.length; i++) {
        Position p = category[i];
        if (p.isDeleted) {
          rememberDeletedOffset(e.getOffset());
          break;
        }
      }
      clearPositionCache();
      category = getPositions();

      fScanner.setPartialRange(
          fDocument,
          reparseStart,
          fDocument.getLength() - reparseStart,
          contentType,
          partitionStart);

      int behindLastScannedPosition = reparseStart;
      IToken token = fScanner.nextToken();

      while (!token.isEOF()) {

        contentType = getTokenContentType(token);

        if (!isSupportedContentType(contentType)) {
          token = fScanner.nextToken();
          continue;
        }

        int start = fScanner.getTokenOffset();
        int length = fScanner.getTokenLength();

        behindLastScannedPosition = start + length;
        int lastScannedPosition = behindLastScannedPosition - 1;

        // remove all affected positions
        while (first < category.length) {
          TypedPosition p = (TypedPosition) category[first];
          if (lastScannedPosition >= p.offset + p.length
              || (p.overlapsWith(start, length)
                  && (!fDocument.containsPosition(fPositionCategory, start, length)
                      || !contentType.equals(p.getType())))) {

            rememberRegion(p.offset, p.length);
            fDocument.removePosition(fPositionCategory, p);
            ++first;

          } else break;
        }

        // if position already exists and we have scanned at least the
        // area covered by the event, we are done
        if (fDocument.containsPosition(fPositionCategory, start, length)) {
          if (lastScannedPosition >= e.getOffset() + newLength) return createRegion();
          ++first;
        } else {
          // insert the new type position
          try {
            fDocument.addPosition(fPositionCategory, new TypedPosition(start, length, contentType));
            rememberRegion(start, length);
          } catch (BadPositionCategoryException x) {
          } catch (BadLocationException x) {
          }
        }

        token = fScanner.nextToken();
      }

      first = fDocument.computeIndexInCategory(fPositionCategory, behindLastScannedPosition);

      clearPositionCache();
      category = getPositions();
      TypedPosition p;
      while (first < category.length) {
        p = (TypedPosition) category[first++];
        fDocument.removePosition(fPositionCategory, p);
        rememberRegion(p.offset, p.length);
      }

    } catch (BadPositionCategoryException x) {
      // should never happen on connected documents
    } catch (BadLocationException x) {
    } finally {
      clearPositionCache();
    }

    return createRegion();
  }

