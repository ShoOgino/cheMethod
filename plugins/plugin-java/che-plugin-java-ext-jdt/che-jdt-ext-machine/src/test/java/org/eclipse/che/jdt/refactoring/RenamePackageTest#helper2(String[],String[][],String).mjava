    private RenamePackageProcessor helper2(String[] packageNames, String[][] packageFileNames, String newPackageName) throws Exception {
        ParticipantTesting.reset();
        IPackageFragment[] packages = new IPackageFragment[packageNames.length];
        ICompilationUnit[][] cus = new ICompilationUnit[packageFileNames.length][packageFileNames[0].length];
        for (int i = 0; i < packageNames.length; i++) {
            packages[i] = getRoot().createPackageFragment(packageNames[i], true, null);
            for (int j = 0; j < packageFileNames[i].length; j++) {
                cus[i][j] = createCUfromTestFile(packages[i], packageFileNames[i][j], packageNames[i].replace('.', '/') + "/");
            }
        }
        IPackageFragment thisPackage = packages[0];
        boolean hasSubpackages = thisPackage.hasSubpackages();

        IPath path = thisPackage.getParent().getPath();
        path = path.append(newPackageName.replace('.', '/'));
        IFolder target = ResourcesPlugin.getWorkspace().getRoot().getFolder(path);
        boolean targetExists = target.exists();
        boolean isRename =
                !targetExists && !thisPackage.hasSubpackages() && thisPackage.getResource().getParent().equals(target.getParent());

        String[] createHandles = null;
        String[] moveHandles = null;
        String[] deleteHandles = null;
        boolean doDelete = true;

        String[] renameHandles = null;
        if (isRename) {
            renameHandles = ParticipantTesting.createHandles(thisPackage, thisPackage.getResource());
        } else {
            renameHandles = ParticipantTesting.createHandles(thisPackage);
            IContainer loop = target;
            List handles = new ArrayList();
            while (loop != null && !loop.exists()) {
                handles.add(ParticipantTesting.createHandles(loop)[0]);
                loop = loop.getParent();
            }
            createHandles = (String[])handles.toArray(new String[handles.size()]);
            IFolder source = (IFolder)thisPackage.getResource();
            deleteHandles = ParticipantTesting.createHandles(source);
            IResource members[] = source.members();
            List movedObjects = new ArrayList();
            for (int i = 0; i < members.length; i++) {
                if (members[i] instanceof IFolder) {
                    doDelete = false;
                } else {
                    movedObjects.add(members[i]);
                }
            }
            moveHandles = ParticipantTesting.createHandles(movedObjects.toArray());
        }
        RenameJavaElementDescriptor descriptor = createRefactoringDescriptor(thisPackage, newPackageName);
        descriptor.setUpdateReferences(fUpdateReferences);
        descriptor.setUpdateTextualOccurrences(fUpdateTextualMatches);
        setFilePatterns(descriptor);
        Refactoring refactoring = createRefactoring(descriptor);
        RefactoringStatus result = performRefactoring(refactoring);
        assertEquals("preconditions were supposed to pass", null, result);

        if (isRename) {
            ParticipantTesting.testRename(renameHandles,
                                          new RenameArguments[]{
                                                  new RenameArguments(newPackageName, fUpdateReferences),
                                                  new RenameArguments(target.getName(), fUpdateReferences)
                                          }
                                         );
        } else {
            ParticipantTesting.testRename(renameHandles,
                                          new RenameArguments[]{
                                                  new RenameArguments(newPackageName, fUpdateReferences)});

            ParticipantTesting.testCreate(createHandles);

            List args = new ArrayList();
            for (int i = 0; i < packageFileNames[0].length; i++) {
                args.add(new MoveArguments(target, fUpdateReferences));
            }
            ParticipantTesting.testMove(moveHandles, (MoveArguments[])args.toArray(new MoveArguments[args.size()]));

            if (doDelete) {
                ParticipantTesting.testDelete(deleteHandles);
            } else {
                ParticipantTesting.testDelete(new String[0]);
            }
        }

        //---

        if (hasSubpackages) {
            assertTrue("old package does not exist anymore", getRoot().getPackageFragment(packageNames[0]).exists());
        } else {
            assertTrue("package not renamed", !getRoot().getPackageFragment(packageNames[0]).exists());
        }
        IPackageFragment newPackage = getRoot().getPackageFragment(newPackageName);
        assertTrue("new package does not exist", newPackage.exists());

        for (int i = 0; i < packageFileNames.length; i++) {
            String packageName = (i == 0)
                                 ? newPackageName.replace('.', '/') + "/"
                                 : packageNames[i].replace('.', '/') + "/";
            for (int j = 0; j < packageFileNames[i].length; j++) {
                String s1 = getFileContents(getOutputTestFileName(packageFileNames[i][j], packageName));
                ICompilationUnit cu =
                        (i == 0)
                        ? newPackage.getCompilationUnit(packageFileNames[i][j] + ".java")
                        : cus[i][j];
                //DebugUtils.dump("cu:" + cu.getElementName());
                String s2 = cu.getSource();

                //DebugUtils.dump("expected:" + s1);
                //DebugUtils.dump("was:" + s2);
                assertEqualLines("invalid update in file " + cu.getElementName(), s1, s2);
            }
        }
        RefactoringProcessor processor = ((ProcessorBasedRefactoring)refactoring).getProcessor();
        return (RenamePackageProcessor)processor;
    }

