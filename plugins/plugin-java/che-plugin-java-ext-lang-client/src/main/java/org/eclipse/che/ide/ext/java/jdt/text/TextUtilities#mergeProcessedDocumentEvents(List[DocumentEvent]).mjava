    /**
     * Returns a document event which is an accumulation of a list of document events, <code>null</code> if the list of document
     * events is empty. The document events being merged must all refer to the same document, to which the document changes have
     * been already applied.
     *
     * @param documentEvents
     *         the list of document events to merge
     * @return returns the merged document event
     * @throws BadLocationException
     *         might be thrown if document is not in the correct state with respect to document events
     */
    public static DocumentEvent mergeProcessedDocumentEvents(List<DocumentEvent> documentEvents) throws BadLocationException {

        if (documentEvents.size() == 0)
            return null;

        final ListIterator<DocumentEvent> iterator = documentEvents.listIterator(documentEvents.size());
        final DocumentEvent firstEvent = iterator.previous();

        // current merged event
        final Document document = firstEvent.getDocument();
        int offset = firstEvent.getOffset();
        int length = firstEvent.getLength();
        int textLength = firstEvent.getText() == null ? 0 : firstEvent.getText().length();

        while (iterator.hasPrevious()) {

            final int delta = length - textLength;

            final DocumentEvent event = (DocumentEvent)iterator.previous();
            final int eventOffset = event.getOffset();
            final int eventLength = event.getLength();
            final int eventTextLength = event.getText() == null ? 0 : event.getText().length();

            // event is right from merged event
            if (eventOffset > offset + textLength + delta) {
                length = (eventOffset - delta) - (offset + textLength) + length + eventLength;
                textLength = (eventOffset - delta) + eventTextLength - offset;

                // event is left from merged event
            } else if (eventOffset + eventTextLength < offset) {
                length = offset - (eventOffset + eventTextLength) + length + eventLength;
                textLength = offset + textLength - eventOffset;
                offset = eventOffset;

                // events overlap each other
            } else {
                final int start = Math.max(0, eventOffset - offset);
                final int end = Math.min(length, eventTextLength + eventOffset - offset);
                length += eventLength - (end - start);

                offset = Math.min(offset, eventOffset);
                final int totalDelta = delta + eventLength - eventTextLength;
                textLength = length - totalDelta;
            }
        }

        final String text = document.get(offset, textLength);
        return new DocumentEvent(document, offset, length, text);
    }

