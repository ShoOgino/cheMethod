  @Override
  protected Promise<List<Node>> getChildrenImpl() {
    return createFromAsyncRequest(
        callback -> {
          List<Node> children = new ArrayList<>();
          if (compilationUnit != null && type.isPrimary()) {
            for (ImportDeclaration importDeclaration : compilationUnit.getImports()) {
              createNodeForAllMatches(importDeclaration.getHandleIdentifier(), children);
            }
            for (Type subType : compilationUnit.getTypes()) {
              if (subType == type) {
                continue;
              }
              children.add(nodeFactory.create(subType, compilationUnit, classFile, matches));
            }
          }
          createNodeForAllMatches(type.getHandleIdentifier(), children);

          for (Initializer initializer : type.getInitializers()) {
            createNodeForAllMatches(initializer.getHandleIdentifier(), children);
          }

          for (Field field : type.getFields()) {
            createNodeForAllMatches(field.getHandleIdentifier(), children);
          }

          final List<Node> typeNodes =
              type.getTypes()
                  .stream()
                  .map(subType -> nodeFactory.create(subType, compilationUnit, classFile, matches))
                  .collect(Collectors.toList());
          children.addAll(typeNodes);

          final List<Node> methodNodes =
              type.getMethods()
                  .stream()
                  .map(method -> nodeFactory.create(method, matches, compilationUnit, classFile))
                  .collect(Collectors.toList());
          children.addAll(methodNodes);

          Collections.sort(children, new NodeComparator());
          callback.onSuccess(children);
        });
  }

