    /**
     * Returns a document event which is an accumulation of a list of document events, <code>null</code> if the list of
     * documentEvents is empty. The document of the document events are ignored.
     *
     * @param unprocessedDocument
     *         the document to which the document events would be applied
     * @param documentEvents
     *         the list of document events to merge
     * @return returns the merged document event
     * @throws BadLocationException
     *         might be thrown if document is not in the correct state with respect to document events
     */
    public static DocumentEvent mergeUnprocessedDocumentEvents(Document unprocessedDocument, List<DocumentEvent> documentEvents)
            throws BadLocationException {

        if (documentEvents.size() == 0)
            return null;

        final Iterator<DocumentEvent> iterator = documentEvents.iterator();
        final DocumentEvent firstEvent = iterator.next();

        // current merged event
        final Document document = unprocessedDocument;
        int offset = firstEvent.getOffset();
        int length = firstEvent.getLength();
        final StringBuffer text = new StringBuffer(firstEvent.getText() == null ? "" : firstEvent.getText()); //$NON-NLS-1$

        while (iterator.hasNext()) {

            final int delta = text.length() - length;

            final DocumentEvent event = (DocumentEvent)iterator.next();
            final int eventOffset = event.getOffset();
            final int eventLength = event.getLength();
            final String eventText = event.getText() == null ? "" : event.getText(); //$NON-NLS-1$

            // event is right from merged event
            if (eventOffset > offset + length + delta) {
                final String string = document.get(offset + length, (eventOffset - delta) - (offset + length));
                text.append(string);
                text.append(eventText);

                length = (eventOffset - delta) + eventLength - offset;

                // event is left from merged event
            } else if (eventOffset + eventLength < offset) {
                final String string = document.get(eventOffset + eventLength, offset - (eventOffset + eventLength));
                text.insert(0, string);
                text.insert(0, eventText);

                length = offset + length - eventOffset;
                offset = eventOffset;

                // events overlap each other
            } else {
                final int start = Math.max(0, eventOffset - offset);
                final int end = Math.min(text.length(), eventLength + eventOffset - offset);
                text.replace(start, end, eventText);

                offset = Math.min(offset, eventOffset);
                final int totalDelta = delta + eventText.length() - eventLength;
                length = text.length() - totalDelta;
            }
        }

        return new DocumentEvent(document, offset, length, text.toString());
    }

