  /**
   * Debug-only method that checks the differential offsets of the tree, starting at <code>node
   * </code> and continuing until <code>last</code>.
   *
   * @param node the first <code>Node</code> to check, may be <code>null</code>
   * @param offLen an array of length 2, with <code>offLen[0]</code> the expected offset of <code>
   *     node</code> and <code>offLen[1]</code> the expected line of <code>node</code>
   * @param last the last <code>Node</code> to check, may be <code>null</code>
   * @return an <code>int[]</code> of length 2, with the first element being the character length of
   *     <code>node</code>'s subtree, and the second element the number of lines in <code>node
   *     </code>'s subtree
   */
  private int[] checkTreeOffsets(Node node, int[] offLen, Node last) {
    if (node == last) return offLen;

    Assert.isTrue(node.offset == offLen[0]);
    Assert.isTrue(node.line == offLen[1]);

    if (node.right != null) {
      int[] result = checkTreeOffsets(successorDown(node.right), new int[2], node);
      offLen[0] += result[0];
      offLen[1] += result[1];
    }

    offLen[0] += node.length;
    offLen[1]++;
    return checkTreeOffsets(node.parent, offLen, last);
  }

