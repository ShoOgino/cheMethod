    /**
     * Computes the index in the list of positions at which a position with the given position would be inserted. The position to
     * insert is supposed to become the first in this list of all positions with the same position.
     *
     * @param positions
     *         the list in which the index is computed
     * @param offset
     *         the offset for which the index is computed
     * @param orderedByOffset
     *         <code>true</code> if ordered by offset, false if ordered by end position
     * @return the computed index
     * @since 3.4
     */
    protected int computeIndexInPositionList(List<Position> positions, int offset, boolean orderedByOffset) {
        if (positions.size() == 0)
            return 0;

        int left = 0;
        int right = positions.size() - 1;
        int mid = 0;
        Position p = null;

        while (left < right) {

            mid = (left + right) / 2;

            p = (Position)positions.get(mid);
            int pOffset = getOffset(orderedByOffset, p);
            if (offset < pOffset) {
                if (left == mid)
                    right = left;
                else
                    right = mid - 1;
            } else if (offset > pOffset) {
                if (right == mid)
                    left = right;
                else
                    left = mid + 1;
            } else if (offset == pOffset) {
                left = right = mid;
            }

        }

        int pos = left;
        p = (Position)positions.get(pos);
        int pPosition = getOffset(orderedByOffset, p);
        if (offset > pPosition) {
            // append to the end
            pos++;
        } else {
            // entry will become the first of all entries with the same offset
            do {
                --pos;
                if (pos < 0)
                    break;
                p = (Position)positions.get(pos);
                pPosition = getOffset(orderedByOffset, p);
            }
            while (offset == pPosition);
            ++pos;
        }

        Assert.isTrue(0 <= pos && pos <= positions.size());

        return pos;
    }

