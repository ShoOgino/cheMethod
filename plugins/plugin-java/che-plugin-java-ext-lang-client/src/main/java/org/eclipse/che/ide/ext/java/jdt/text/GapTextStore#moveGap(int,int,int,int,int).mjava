    /**
     * Moves the gap to <code>newGapStart</code>.
     *
     * @param offset
     *         the change offset
     * @param remove
     *         the number of removed / overwritten characters
     * @param oldGapSize
     *         the old gap size
     * @param newGapSize
     *         the gap size after the change
     * @param newGapStart
     *         the offset in the array to move the gap to
     * @return the new gap end
     * @since 3.3
     */
    private int moveGap(int offset, int remove, int oldGapSize, int newGapSize, int newGapStart) {
      /*
       * No re-allocation necessary. The area between the change offset and gap can be copied in at most one operation. Don't copy
       * parts that will be overwritten anyway.
       */
        final int newGapEnd = newGapStart + newGapSize;
        if (offset < fGapStart) {
            int afterRemove = offset + remove;
            if (afterRemove < fGapStart) {
                final int betweenSize = fGapStart - afterRemove;
                arrayCopy(afterRemove, fContent, newGapEnd, betweenSize);
            }
            // otherwise, only the gap gets enlarged
        } else {
            final int offsetShifted = offset + oldGapSize;
            final int betweenSize = offsetShifted - fGapEnd; // in the typing case, betweenSize is 0
            arrayCopy(fGapEnd, fContent, fGapStart, betweenSize);
        }
        return newGapEnd;
    }

