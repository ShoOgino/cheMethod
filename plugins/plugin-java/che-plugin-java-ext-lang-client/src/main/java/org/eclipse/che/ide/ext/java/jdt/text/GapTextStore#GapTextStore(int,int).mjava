  /**
   * Creates a new empty text store using the specified low and high watermarks.
   *
   * @param lowWatermark unused - at the lower bound, the array is only resized when the content
   *     does not fit
   * @param highWatermark if the gap is ever larger than this, it will automatically be shrunken
   *     (&gt;=&nbsp;0)
   * @deprecated use {@link GapTextStore#GapTextStore(int, int, float)} instead
   */
  public GapTextStore(int lowWatermark, int highWatermark) {
    /*
     * Legacy constructor. The API contract states that highWatermark is the upper bound for the gap size. Albeit this contract
     * was not previously adhered to, it is now: The allocated gap size is fixed at half the highWatermark. Since the threshold
     * is always twice the allocated gap size, the gap will never grow larger than highWatermark. Previously, the gap size was
     * initialized to highWatermark, causing re-allocation if the content length shrunk right after allocation. The fixed gap
     * size is now only half of the previous value, circumventing that problem (there was no API contract specifying the initial
     * gap size). The previous implementation did not allow the gap size to become smaller than lowWatermark, which doesn't make
     * any sense: that area of the gap was simply never ever used.
     */
    this(highWatermark / 2, highWatermark / 2, 0f);
  }

