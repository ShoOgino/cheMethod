    /**
     * Creates an empty text store that uses re-allocation thresholds relative to the content length. Re-allocation is controlled
     * by the <em>gap factor</em> , which is the quotient of the gap size and the array size. Re-allocation occurs if a change
     * causes the gap factor to go outside <code>[0,&nbsp;maxGapFactor]</code>. When re-allocation occurs, the array is sized such
     * that the gap factor is <code>0.5 * maxGapFactor</code>. The gap size computed in this manner is bounded by the
     * <code>minSize</code> and <code>maxSize</code> parameters.
     * <p>
     * A <code>maxGapFactor</code> of <code>0</code> creates a text store that never has a gap at all (if <code>minSize</code> is
     * 0); a <code>maxGapFactor</code> of <code>1</code> creates a text store that doubles its size with every re-allocation and
     * that never shrinks.
     * </p>
     * <p>
     * The <code>minSize</code> and <code>maxSize</code> parameters are absolute bounds to the allocated gap size. Use
     * <code>minSize</code> to avoid frequent re-allocation for small documents. Use <code>maxSize</code> to avoid a huge gap being
     * allocated for large documents.
     * </p>
     *
     * @param minSize
     *         the minimum gap size to allocate (&gt;=&nbsp;0; use 0 for no minimum)
     * @param maxSize
     *         the maximum gap size to allocate (&gt;=&nbsp;minSize; use {@link Integer#MAX_VALUE} for no maximum)
     * @param maxGapFactor
     *         is the maximum fraction of the array that is occupied by the gap (
     *         <code>0&nbsp;&lt;=&nbsp;maxGapFactor&nbsp;&lt;=&nbsp;1</code> )
     * @since 3.3
     */
    public GapTextStore(int minSize, int maxSize, float maxGapFactor) {
        Assert.isLegal(0f <= maxGapFactor && maxGapFactor <= 1f);
        Assert.isLegal(0 <= minSize && minSize <= maxSize);
        fMinGapSize = minSize;
        fMaxGapSize = maxSize;
        fSizeMultiplier = 1 / (1 - maxGapFactor / 2);
    }

