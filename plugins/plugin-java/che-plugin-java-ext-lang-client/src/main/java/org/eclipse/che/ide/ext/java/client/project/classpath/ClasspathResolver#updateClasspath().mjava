    /** Concatenates classpath entries and update classpath file. */
    public Promise<Void> updateClasspath() {

        final Resource resource = appContext.getResource();

        Preconditions.checkState(resource != null);

        final Optional<Project> project = resource.getRelatedProject();

        final List<ClasspathEntryDto> entries = new ArrayList<>();
        for (String path : libs) {
            entries.add(dtoFactory.createDto(ClasspathEntryDto.class).withPath(path).withEntryKind(LIBRARY));
        }
        for (ClasspathEntryDto container : containers) {
            entries.add(container);
        }
        for (String path : sources) {
            entries.add(dtoFactory.createDto(ClasspathEntryDto.class).withPath(path).withEntryKind(SOURCE));
        }
        for (String path : projects) {
            entries.add(dtoFactory.createDto(ClasspathEntryDto.class).withPath(path).withEntryKind(PROJECT));
        }
        Promise<Void> promise = classpathUpdater.setRawClasspath(project.get().getLocation().toString(), entries);

        promise.then(new Operation<Void>() {
            @Override
            public void apply(Void arg) throws OperationException {
                project.get().synchronize();
            }
        }).catchError(new Operation<PromiseError>() {
            @Override
            public void apply(PromiseError arg) throws OperationException {
                notificationManager.notify("Problems with updating classpath", arg.getMessage(), FAIL, EMERGE_MODE);
            }
        });

        return promise;
    }

