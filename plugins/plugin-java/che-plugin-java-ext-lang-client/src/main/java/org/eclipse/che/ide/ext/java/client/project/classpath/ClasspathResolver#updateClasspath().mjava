    /** Concatenates classpath entries and update classpath file. */
    public Promise<Void> updateClasspath() {
        final CurrentProject currentProject = appContext.getCurrentProject();
        if (currentProject == null) {
            return null;
        }

        List<ClasspathEntryDTO> entries = new ArrayList<>();
        for (String path : libs) {
            entries.add(dtoFactory.createDto(ClasspathEntryDTO.class).withPath(path).withEntryKind(LIBRARY));
        }
        for (String path : containers) {
            entries.add(dtoFactory.createDto(ClasspathEntryDTO.class).withPath(path).withEntryKind(CONTAINER));
        }
        for (String path : sources) {
            entries.add(dtoFactory.createDto(ClasspathEntryDTO.class).withPath(path).withEntryKind(SOURCE));
        }
        for (String path : projects) {
            entries.add(dtoFactory.createDto(ClasspathEntryDTO.class).withPath(path).withEntryKind(PROJECT));
        }
        Promise<Void> promise = classpathUpdater.setRawClasspath(currentProject.getProjectConfig().getPath(), entries);

        promise.then(new Operation<Void>() {
            @Override
            public void apply(Void arg) throws OperationException {
                projectService.getProject(appContext.getDevMachine(), currentProject.getProjectConfig().getPath()).then(
                        new Operation<ProjectConfigDto>() {
                            @Override
                            public void apply(ProjectConfigDto arg) throws OperationException {
                                eventBus.fireEvent(new ProjectUpdatedEvent(arg.getPath(), arg));
                            }
                        });
            }
        }).catchError(new Operation<PromiseError>() {
            @Override
            public void apply(PromiseError arg) throws OperationException {
                notificationManager.notify("Problems with updating classpath", arg.getMessage(), FAIL, EMERGE_MODE);
            }
        });

        return promise;
    }

