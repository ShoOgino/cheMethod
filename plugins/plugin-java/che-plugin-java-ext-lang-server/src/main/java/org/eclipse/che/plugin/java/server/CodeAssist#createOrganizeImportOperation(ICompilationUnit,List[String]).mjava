  private OrganizeImportResult createOrganizeImportOperation(
      ICompilationUnit compilationUnit, List<String> chosen) throws CoreException {
    CodeGenerationSettings settings =
        JavaPreferencesSettings.getCodeGenerationSettings(compilationUnit.getJavaProject());

    OrganizeImportsOperation operation =
        new OrganizeImportsOperation(
            compilationUnit,
            null,
            settings.importIgnoreLowercase,
            !compilationUnit.isWorkingCopy(),
            true,
            chosen,
            null);

    NullProgressMonitor monitor = new NullProgressMonitor();
    TextEdit edit = operation.createTextEdit(monitor);
    OrganizeImportResult result = DtoFactory.newDto(OrganizeImportResult.class);
    TypeNameMatch[][] choices = operation.getChoices();
    //Apply organize import declarations if operation doesn't have conflicts (choices.length == 0)
    //or all conflicts were resolved (!chosen.isEmpty())
    if ((chosen != null && !chosen.isEmpty()) || choices == null || choices.length == 0) {
      IBuffer buffer = compilationUnit.getBuffer();
      IDocument document = new Document(buffer.getContents());
      DocumentChangeListener documentChangeListener = new DocumentChangeListener(document);
      try {
        edit.apply(document);
      } catch (BadLocationException e) {
        LOG.debug("Applying Organize import text edits goes wrong:", e);
      }
      result.setChanges(documentChangeListener.getChanges());
      return result;
    }

    result.setConflicts(createListOfDTOMatches(choices));
    return result;
  }

