  // $ANTLR start "unaryExpressionNotPlusMinus"
  // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:951:1: unaryExpressionNotPlusMinus : ( NOT unaryExpression -> ^(
  // NOT unaryExpression ) | LOGICAL_NOT unaryExpression -> ^( LOGICAL_NOT unaryExpression ) | LPAREN type RPAREN unaryExpression -> ^(
  // CAST_EXPR[$LPAREN, \"CAST_EXPR\"] type unaryExpression ) | postfixedExpression );
  public final JavaParser.unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus()
      throws RecognitionException {
    JavaParser.unaryExpressionNotPlusMinus_return retval =
        new JavaParser.unaryExpressionNotPlusMinus_return();
    retval.start = input.LT(1);
    int unaryExpressionNotPlusMinus_StartIndex = input.index();
    CommonTree root_0 = null;

    Token NOT438 = null;
    Token LOGICAL_NOT440 = null;
    Token LPAREN442 = null;
    Token RPAREN444 = null;
    JavaParser.unaryExpression_return unaryExpression439 = null;

    JavaParser.unaryExpression_return unaryExpression441 = null;

    JavaParser.type_return type443 = null;

    JavaParser.unaryExpression_return unaryExpression445 = null;

    JavaParser.postfixedExpression_return postfixedExpression446 = null;

    CommonTree NOT438_tree = null;
    CommonTree LOGICAL_NOT440_tree = null;
    CommonTree LPAREN442_tree = null;
    CommonTree RPAREN444_tree = null;
    RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
    RewriteRuleTokenStream stream_LOGICAL_NOT =
        new RewriteRuleTokenStream(adaptor, "token LOGICAL_NOT");
    RewriteRuleTokenStream stream_NOT = new RewriteRuleTokenStream(adaptor, "token NOT");
    RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
    RewriteRuleSubtreeStream stream_unaryExpression =
        new RewriteRuleSubtreeStream(adaptor, "rule unaryExpression");
    RewriteRuleSubtreeStream stream_type = new RewriteRuleSubtreeStream(adaptor, "rule type");
    try {
      if (state.backtracking > 0 && alreadyParsedRule(input, 103)) {
        return retval;
      }
      // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:952:5: ( NOT unaryExpression -> ^( NOT unaryExpression ) |
      // LOGICAL_NOT unaryExpression -> ^( LOGICAL_NOT unaryExpression ) | LPAREN type RPAREN unaryExpression -> ^(
      // CAST_EXPR[$LPAREN, \"CAST_EXPR\"] type unaryExpression ) | postfixedExpression )
      int alt127 = 4;
      alt127 = dfa127.predict(input);
      switch (alt127) {
        case 1:
          // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:952:9: NOT unaryExpression
          {
            NOT438 = (Token) match(input, NOT, FOLLOW_NOT_in_unaryExpressionNotPlusMinus11693);
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_NOT.add(NOT438);

            pushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus11695);
            unaryExpression439 = unaryExpression();

            state._fsp--;
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_unaryExpression.add(unaryExpression439.getTree());

            // AST REWRITE
            // elements: unaryExpression, NOT
            // token labels:
            // rule labels: retval
            // token list labels:
            // rule list labels:
            // wildcard labels:
            if (state.backtracking == 0) {
              retval.tree = root_0;
              RewriteRuleSubtreeStream stream_retval =
                  new RewriteRuleSubtreeStream(
                      adaptor, "rule retval", retval != null ? retval.tree : null);

              root_0 = (CommonTree) adaptor.nil();
              // 952:57: -> ^( NOT unaryExpression )
              {
                // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:952:61: ^( NOT unaryExpression )
                {
                  CommonTree root_1 = (CommonTree) adaptor.nil();
                  root_1 = (CommonTree) adaptor.becomeRoot(stream_NOT.nextNode(), root_1);

                  adaptor.addChild(root_1, stream_unaryExpression.nextTree());

                  adaptor.addChild(root_0, root_1);
                }
              }

              retval.tree = root_0;
            }
          }
          break;
        case 2:
          // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:953:9: LOGICAL_NOT unaryExpression
          {
            LOGICAL_NOT440 =
                (Token)
                    match(
                        input, LOGICAL_NOT, FOLLOW_LOGICAL_NOT_in_unaryExpressionNotPlusMinus11742);
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_LOGICAL_NOT.add(LOGICAL_NOT440);

            pushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus11744);
            unaryExpression441 = unaryExpression();

            state._fsp--;
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_unaryExpression.add(unaryExpression441.getTree());

            // AST REWRITE
            // elements: LOGICAL_NOT, unaryExpression
            // token labels:
            // rule labels: retval
            // token list labels:
            // rule list labels:
            // wildcard labels:
            if (state.backtracking == 0) {
              retval.tree = root_0;
              RewriteRuleSubtreeStream stream_retval =
                  new RewriteRuleSubtreeStream(
                      adaptor, "rule retval", retval != null ? retval.tree : null);

              root_0 = (CommonTree) adaptor.nil();
              // 953:57: -> ^( LOGICAL_NOT unaryExpression )
              {
                // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:953:61: ^( LOGICAL_NOT unaryExpression )
                {
                  CommonTree root_1 = (CommonTree) adaptor.nil();
                  root_1 = (CommonTree) adaptor.becomeRoot(stream_LOGICAL_NOT.nextNode(), root_1);

                  adaptor.addChild(root_1, stream_unaryExpression.nextTree());

                  adaptor.addChild(root_0, root_1);
                }
              }

              retval.tree = root_0;
            }
          }
          break;
        case 3:
          // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:954:9: LPAREN type RPAREN unaryExpression
          {
            LPAREN442 =
                (Token) match(input, LPAREN, FOLLOW_LPAREN_in_unaryExpressionNotPlusMinus11783);
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_LPAREN.add(LPAREN442);

            pushFollow(FOLLOW_type_in_unaryExpressionNotPlusMinus11785);
            type443 = type();

            state._fsp--;
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_type.add(type443.getTree());
            RPAREN444 =
                (Token) match(input, RPAREN, FOLLOW_RPAREN_in_unaryExpressionNotPlusMinus11787);
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_RPAREN.add(RPAREN444);

            pushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus11789);
            unaryExpression445 = unaryExpression();

            state._fsp--;
            if (state.failed) return retval;
            if (state.backtracking == 0) stream_unaryExpression.add(unaryExpression445.getTree());

            // AST REWRITE
            // elements: type, unaryExpression
            // token labels:
            // rule labels: retval
            // token list labels:
            // rule list labels:
            // wildcard labels:
            if (state.backtracking == 0) {
              retval.tree = root_0;
              RewriteRuleSubtreeStream stream_retval =
                  new RewriteRuleSubtreeStream(
                      adaptor, "rule retval", retval != null ? retval.tree : null);

              root_0 = (CommonTree) adaptor.nil();
              // 954:57: -> ^( CAST_EXPR[$LPAREN, \"CAST_EXPR\"] type unaryExpression )
              {
                // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:954:61: ^( CAST_EXPR[$LPAREN,
                // \"CAST_EXPR\"] type unaryExpression )
                {
                  CommonTree root_1 = (CommonTree) adaptor.nil();
                  root_1 =
                      (CommonTree)
                          adaptor.becomeRoot(
                              (CommonTree) adaptor.create(CAST_EXPR, LPAREN442, "CAST_EXPR"),
                              root_1);

                  adaptor.addChild(root_1, stream_type.nextTree());
                  adaptor.addChild(root_1, stream_unaryExpression.nextTree());

                  adaptor.addChild(root_0, root_1);
                }
              }

              retval.tree = root_0;
            }
          }
          break;
        case 4:
          // org/eclipse/che/ide/ext/java/jdi/server/expression/Java.g:955:9: postfixedExpression
          {
            root_0 = (CommonTree) adaptor.nil();

            pushFollow(FOLLOW_postfixedExpression_in_unaryExpressionNotPlusMinus11824);
            postfixedExpression446 = postfixedExpression();

            state._fsp--;
            if (state.failed) return retval;
            if (state.backtracking == 0) adaptor.addChild(root_0, postfixedExpression446.getTree());
          }
          break;
      }
      retval.stop = input.LT(-1);

      if (state.backtracking == 0) {

        retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
      }
    } catch (RecognitionException re) {
      reportError(re);
      recover(input, re);
      retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

    } finally {
      if (state.backtracking > 0) {
        memoize(input, 103, unaryExpressionNotPlusMinus_StartIndex);
      }
    }
    return retval;
  }
  // $ANTLR end "unaryExpressionNotPlusMinus"

