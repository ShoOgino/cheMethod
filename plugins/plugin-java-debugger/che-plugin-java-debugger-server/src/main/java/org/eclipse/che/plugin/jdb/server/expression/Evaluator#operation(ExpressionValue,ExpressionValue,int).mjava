  public ExpressionValue operation(
      ExpressionValue leftExpression, ExpressionValue rightExpression, int op) {
    if (JavaParser.ASSIGN == op) {
      leftExpression.setValue(rightExpression.getValue());
      return leftExpression;
    }

    Value leftValue = leftExpression.getValue();
    Value rightValue = rightExpression.getValue();
    if (leftValue instanceof StringReference || rightValue instanceof StringReference) {
      if (JavaParser.PLUS == op) {
        return value(valueToString(leftValue) + valueToString(rightValue));
      }
    }

    if (leftValue instanceof ObjectReference || rightValue instanceof ObjectReference) {
      switch (op) {
        case JavaParser.EQUAL:
          return value(leftValue != null ? leftValue.equals(rightValue) : rightValue == null);
        case JavaParser.NOT_EQUAL:
          return value(!(leftValue != null ? leftValue.equals(rightValue) : rightValue == null));
        default:
          throw new ExpressionException(
              "Unsupported operation "
                  + JavaParser.tokenNames[op]
                  + " for "
                  + leftValue
                  + " and "
                  + rightValue);
      }
    }

    if (leftValue == null || rightValue == null) {
      // Neither one is object and operation is not assignation.
      throw new ExpressionException(
          "Unsupported operation "
              + JavaParser.tokenNames[op]
              + " for "
              + leftValue
              + " and "
              + rightValue);
    }

    PrimitiveValue lp = (PrimitiveValue) leftValue;
    PrimitiveValue rp = (PrimitiveValue) rightValue;

    if (lp instanceof BooleanValue && rp instanceof BooleanValue) {
      switch (op) {
        case JavaParser.LOGICAL_AND:
          return value(lp.booleanValue() && rp.booleanValue());
        case JavaParser.LOGICAL_OR:
          return value(lp.booleanValue() || rp.booleanValue());
        case JavaParser.EQUAL:
          return value(lp.booleanValue() == rp.booleanValue());
        case JavaParser.NOT_EQUAL:
          return value(lp.booleanValue() != rp.booleanValue());
        case JavaParser.OR:
          return value(lp.booleanValue() | rp.booleanValue());
        case JavaParser.XOR:
          return value(lp.booleanValue() ^ rp.booleanValue());
        case JavaParser.AND:
          return value(lp.booleanValue() & rp.booleanValue());
        case JavaParser.OR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.booleanValue() | rp.booleanValue()));
          return leftExpression;
        case JavaParser.XOR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.booleanValue() ^ rp.booleanValue()));
          return leftExpression;
        case JavaParser.AND_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.booleanValue() & rp.booleanValue()));
          return leftExpression;
        default:
          throw new ExpressionException(
              "Unsupported operation "
                  + JavaParser.tokenNames[op]
                  + " for "
                  + leftValue
                  + " and "
                  + rightValue);
      }
    }

    switch (op) {
      case JavaParser.EQUAL:
        return value(lp.doubleValue() == rp.doubleValue());
      case JavaParser.NOT_EQUAL:
        return value(lp.doubleValue() != rp.doubleValue());
      case JavaParser.GREATER_THAN:
        return value(lp.doubleValue() > rp.doubleValue());
      case JavaParser.LESS_THAN:
        return value(lp.doubleValue() < rp.doubleValue());
      case JavaParser.GREATER_OR_EQUAL:
        return value(lp.doubleValue() >= rp.doubleValue());
      case JavaParser.LESS_OR_EQUAL:
        return value(lp.doubleValue() <= rp.doubleValue());
    }

    if (lp instanceof DoubleValue || rp instanceof DoubleValue) {
      switch (op) {
        case JavaParser.PLUS:
          return value(lp.doubleValue() + rp.doubleValue());
        case JavaParser.MINUS:
          return value(lp.doubleValue() - rp.doubleValue());
        case JavaParser.STAR:
          return value(lp.doubleValue() * rp.doubleValue());
        case JavaParser.DIV:
          return value(lp.doubleValue() / rp.doubleValue());
        case JavaParser.MOD:
          return value(lp.doubleValue() % rp.doubleValue());
        case JavaParser.PLUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.doubleValue() + rp.doubleValue()));
          return leftExpression;
        case JavaParser.MINUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.doubleValue() - rp.doubleValue()));
          return leftExpression;
        case JavaParser.STAR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.doubleValue() * rp.doubleValue()));
          return leftExpression;
        case JavaParser.DIV_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.doubleValue() / rp.doubleValue()));
          return leftExpression;
        case JavaParser.MOD_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.doubleValue() % rp.doubleValue()));
          return leftExpression;
        default:
          throw new ExpressionException(
              "Unsupported operation "
                  + JavaParser.tokenNames[op]
                  + " for "
                  + leftValue
                  + " and "
                  + rightValue);
      }
    }
    if (lp instanceof FloatValue || rp instanceof FloatValue) {
      switch (op) {
        case JavaParser.PLUS:
          return value(lp.floatValue() + rp.floatValue());
        case JavaParser.MINUS:
          return value(lp.floatValue() - rp.floatValue());
        case JavaParser.STAR:
          return value(lp.floatValue() * rp.floatValue());
        case JavaParser.DIV:
          return value(lp.floatValue() / rp.floatValue());
        case JavaParser.MOD:
          return value(lp.floatValue() % rp.floatValue());
        case JavaParser.PLUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.floatValue() + rp.floatValue()));
          return leftExpression;
        case JavaParser.MINUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.floatValue() - rp.floatValue()));
          return leftExpression;
        case JavaParser.STAR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.floatValue() * rp.longValue()));
          return leftExpression;
        case JavaParser.DIV_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.floatValue() / rp.floatValue()));
          return leftExpression;
        case JavaParser.MOD_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.floatValue() % rp.floatValue()));
          return leftExpression;
        default:
          throw new ExpressionException(
              "Unsupported operation "
                  + JavaParser.tokenNames[op]
                  + " for "
                  + leftValue
                  + " and "
                  + rightValue);
      }
    }
    if (lp instanceof LongValue || rp instanceof LongValue) {
      switch (op) {
        case JavaParser.PLUS:
          return value(lp.longValue() + rp.longValue());
        case JavaParser.MINUS:
          return value(lp.longValue() - rp.longValue());
        case JavaParser.STAR:
          return value(lp.longValue() * rp.longValue());
        case JavaParser.DIV:
          return value(lp.longValue() / rp.longValue());
        case JavaParser.MOD:
          return value(lp.longValue() % rp.longValue());
        case JavaParser.SHIFT_LEFT:
          return value(lp.longValue() << rp.longValue());
        case JavaParser.SHIFT_RIGHT:
          return value(lp.longValue() >> rp.longValue());
        case JavaParser.BIT_SHIFT_RIGHT:
          return value(lp.longValue() >>> rp.longValue());
        case JavaParser.OR:
          return value(lp.longValue() | rp.longValue());
        case JavaParser.XOR:
          return value(lp.longValue() ^ rp.longValue());
        case JavaParser.AND:
          return value(lp.longValue() & rp.longValue());
        case JavaParser.PLUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() + rp.longValue()));
          return leftExpression;
        case JavaParser.MINUS_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() - rp.longValue()));
          return leftExpression;
        case JavaParser.STAR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() * rp.longValue()));
          return leftExpression;
        case JavaParser.DIV_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() / rp.longValue()));
          return leftExpression;
        case JavaParser.OR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() | rp.longValue()));
          return leftExpression;
        case JavaParser.XOR_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() ^ rp.longValue()));
          return leftExpression;
        case JavaParser.AND_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() & rp.longValue()));
          return leftExpression;
        case JavaParser.SHIFT_LEFT_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() << rp.longValue()));
          return leftExpression;
        case JavaParser.SHIFT_RIGHT_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() >> rp.longValue()));
          return leftExpression;
        case JavaParser.BIT_SHIFT_RIGHT_ASSIGN:
          leftExpression.setValue(vm.mirrorOf(lp.longValue() >>> rp.longValue()));
          return leftExpression;
        default:
          throw new ExpressionException(
              "Unsupported operation "
                  + JavaParser.tokenNames[op]
                  + " for "
                  + leftValue
                  + " and "
                  + rightValue);
      }
    }
    switch (op) {
      case JavaParser.PLUS:
        return value(lp.intValue() + rp.intValue());
      case JavaParser.MINUS:
        return value(lp.intValue() - rp.intValue());
      case JavaParser.STAR:
        return value(lp.intValue() * rp.intValue());
      case JavaParser.DIV:
        return value(lp.intValue() / rp.intValue());
      case JavaParser.MOD:
        return value(lp.intValue() % rp.intValue());
      case JavaParser.SHIFT_LEFT:
        return value(lp.intValue() << rp.intValue());
      case JavaParser.SHIFT_RIGHT:
        return value(lp.intValue() >> rp.intValue());
      case JavaParser.BIT_SHIFT_RIGHT:
        return value(lp.intValue() >>> rp.intValue());
      case JavaParser.OR:
        return value(lp.intValue() | rp.intValue());
      case JavaParser.XOR:
        return value(lp.intValue() ^ rp.intValue());
      case JavaParser.AND:
        return value(lp.intValue() & rp.intValue());
      case JavaParser.PLUS_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() + rp.intValue()));
        return leftExpression;
      case JavaParser.MINUS_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() - rp.intValue()));
        return leftExpression;
      case JavaParser.STAR_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() * rp.intValue()));
        return leftExpression;
      case JavaParser.DIV_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() / rp.intValue()));
        return leftExpression;
      case JavaParser.OR_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() | rp.intValue()));
        return leftExpression;
      case JavaParser.XOR_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() ^ rp.intValue()));
        return leftExpression;
      case JavaParser.AND_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() & rp.intValue()));
        return leftExpression;
      case JavaParser.SHIFT_LEFT_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() << rp.intValue()));
        return leftExpression;
      case JavaParser.SHIFT_RIGHT_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() >> rp.intValue()));
        return leftExpression;
      case JavaParser.BIT_SHIFT_RIGHT_ASSIGN:
        leftExpression.setValue(vm.mirrorOf(lp.intValue() >>> rp.intValue()));
        return leftExpression;
      default:
        throw new ExpressionException(
            "Unsupported operation "
                + JavaParser.tokenNames[op]
                + " for "
                + leftValue
                + " and "
                + rightValue);
    }
  }

