    /**
     *
     * @param file
     *         path of the file
     * @param status
     *         status of the file
     * @param revisionA
     *         hash of the first revision or branch.
     *         If it is set to {@code null}, compare with empty repository state will be performed
     * @param revisionB
     *         hash of the second revision or branch.
     *         If it is set to {@code null}, compare with latest repository state will be performed
     */
    public void showCompareBetweenRevisions(final Path file,
                                            final Status status,
                                            @Nullable final String revisionA,
                                            @Nullable final String revisionB) {
        this.compareWithLatest = false;

        final DevMachine devMachine = appContext.getDevMachine();
        final Path projectLocation = appContext.getRootProject().getLocation();

        view.setTitle(file.toString());
        if (status == Status.ADDED) {
            service.showFileContent(devMachine, projectLocation, file, revisionB)
                   .then(new Operation<ShowFileContentResponse>() {
                       @Override
                       public void apply(ShowFileContentResponse response) throws OperationException {
                           view.setColumnTitles(revisionB + locale.compareReadOnlyTitle(),
                                                revisionA == null ? "" : revisionA + locale.compareReadOnlyTitle());
                           view.show("", response.getContent(), file.toString(), true);
                       }
                   })
                   .catchError(new Operation<PromiseError>() {
                       @Override
                       public void apply(PromiseError error) throws OperationException {
                           notificationManager.notify(error.getMessage(), FAIL, NOT_EMERGE_MODE);
                       }
                   });
        } else if (status == Status.DELETED) {
            service.showFileContent(devMachine, projectLocation, file, revisionA)
                   .then(new Operation<ShowFileContentResponse>() {
                       @Override
                       public void apply(ShowFileContentResponse response) throws OperationException {
                           view.setColumnTitles(revisionB + locale.compareReadOnlyTitle(), revisionA + locale.compareReadOnlyTitle());
                           view.show(response.getContent(), "", file.toString(), true);
                       }
                   })
                   .catchError(new Operation<PromiseError>() {
                       @Override
                       public void apply(PromiseError error) throws OperationException {
                           notificationManager.notify(error.getMessage(), FAIL, NOT_EMERGE_MODE);
                       }
                   });
        } else {
            service.showFileContent(devMachine, projectLocation, file, revisionA)
                   .then(new Operation<ShowFileContentResponse>() {
                       @Override
                       public void apply(final ShowFileContentResponse contentAResponse) throws OperationException {
                           service.showFileContent(devMachine, projectLocation, file, revisionB)
                                  .then(new Operation<ShowFileContentResponse>() {
                                      @Override
                                      public void apply(ShowFileContentResponse contentBResponse) throws OperationException {
                                          view.setColumnTitles(revisionB + locale.compareReadOnlyTitle(),
                                                               revisionA + locale.compareReadOnlyTitle());
                                          view.show(contentAResponse.getContent(), contentBResponse.getContent(), file.toString(), true);
                                      }
                                  })
                                  .catchError(new Operation<PromiseError>() {
                                      @Override
                                      public void apply(PromiseError error) throws OperationException {
                                          notificationManager.notify(error.getMessage(), FAIL, NOT_EMERGE_MODE);
                                      }
                                  });
                       }
                   });
        }
    }

