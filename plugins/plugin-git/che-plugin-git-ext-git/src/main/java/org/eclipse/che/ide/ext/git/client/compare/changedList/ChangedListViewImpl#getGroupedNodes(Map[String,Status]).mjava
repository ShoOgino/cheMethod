    private List<Node> getGroupedNodes(Map<String, Status> items) {
        List<String> allFiles = new ArrayList<>(items.keySet());
        List<String> allPaths = new ArrayList<>();
        for (String file : allFiles) {
            String path = file.substring(0, file.lastIndexOf("/"));
            if (!allPaths.contains(path)) {
                allPaths.add(path);
            }
        }
        String commonPath = getCommonPath(allPaths);
        boolean needToAddCommonFolder = !commonPath.isEmpty() && !allPaths.contains(commonPath);
        if (needToAddCommonFolder) {
            allPaths.add(commonPath);
        }
        int commonPathDirectoriesAmount = Path.valueOf(commonPath).segmentCount();

        Map<String, Node> preparedNodes = new HashMap<>();
        for (int i = getMaxNestedLevel(allFiles); i > 0; i--) {

            //Collect child files of all folders of current nesting level and map them to their folders
            Map<String, List<Node>> currentChildNodes = new HashMap<>();
            for (String file : allFiles) {
                Path pathName = Path.valueOf(file);
                if (pathName.segmentCount() != i) {
                    continue;
                }
                Node fileNode = new ChangedFileNode(file, items.get(file), nodesResources, delegate, true);
                String filePath = pathName.removeLastSegments(1).toString();
                if (currentChildNodes.keySet().contains(filePath)) {
                    currentChildNodes.get(filePath).add(fileNode);
                } else {
                    List<Node> listFiles = new ArrayList<>();
                    listFiles.add(fileNode);
                    currentChildNodes.put(filePath, listFiles);
                }
            }

            //Set collected files to new folders that they are related to and add them to prepared earlier map
            if (needToAddCommonFolder && commonPathDirectoriesAmount == i) {
                preparedNodes.put(commonPath, new ChangedFolderNode(commonPath, nodesResources));
            } else {
                for (String path : currentChildNodes.keySet()) {
                    Node folder = new ChangedFolderNode(getFolders(allPaths, path), nodesResources);
                    folder.setChildren(currentChildNodes.get(path));
                    preparedNodes.put(path, folder);
                }
            }

            //Take all child folders and nest them to related parent folders of current nesting level
            List<String> currentPaths = new ArrayList<>(preparedNodes.keySet());
            for (String parentPath : currentPaths) {
                List<Node> nodesToNest = new ArrayList<>();
                for (String nestedItem : currentPaths) {
                    if (!parentPath.equals(nestedItem) && (nestedItem.startsWith(parentPath + "/") || parentPath.isEmpty())) {
                        nodesToNest.add(preparedNodes.remove(nestedItem));
                    }
                }
                if (nodesToNest.isEmpty()) {
                    continue;
                }
                Collections.sort(nodesToNest, new NameComparator());
                if (!needToAddCommonFolder || commonPathDirectoriesAmount != i) {
                    nodesToNest.addAll(currentChildNodes.get(parentPath));
                }
                if (parentPath.isEmpty()) {
                    return nodesToNest;
                } else {
                    preparedNodes.get(parentPath).setChildren(nodesToNest);
                }
            }
        }
        return new ArrayList<>(preparedNodes.values());
    }

