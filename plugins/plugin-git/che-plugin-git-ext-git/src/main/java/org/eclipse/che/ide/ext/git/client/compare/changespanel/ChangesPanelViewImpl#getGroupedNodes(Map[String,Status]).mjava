  private List<Node> getGroupedNodes(Map<String, Status> items) {
    List<String> allFiles = new ArrayList<>(items.keySet());
    List<String> allFolders = new ArrayList<>();
    for (String file : allFiles) {
      nodePaths.add(Path.valueOf(file));
      String path = file.substring(0, file.lastIndexOf("/"));
      if (!allFolders.contains(path)) {
        allFolders.add(path);
      }
    }
    List<String> commonPaths = getCommonPaths(allFolders);
    for (String commonPath : commonPaths) {
      if (!allFolders.contains(commonPath)) {
        allFolders.add(commonPath);
      }
    }

    Map<String, Node> preparedNodes = new HashMap<>();
    for (int i = getMaxNestedLevel(allFiles); i > 0; i--) {

      // Collect child files of all folders of current nesting level
      Map<String, List<Node>> currentChildNodes = new HashMap<>();
      for (String file : allFiles) {
        Path pathName = Path.valueOf(file);
        if (pathName.segmentCount() != i) {
          continue;
        }
        Node fileNode = new ChangedFileNode(file, items.get(file), res, delegate, true);
        String filePath = pathName.removeLastSegments(1).toString();
        if (currentChildNodes.keySet().contains(filePath)) {
          currentChildNodes.get(filePath).add(fileNode);
        } else {
          List<Node> listFiles = new ArrayList<>();
          listFiles.add(fileNode);
          currentChildNodes.put(filePath, listFiles);
        }
      }

      // Map child files to related folders of current nesting level or just create a common folder
      for (String path : allFolders) {
        nodePaths.add(Path.valueOf(path));
        if (!(Path.valueOf(path).segmentCount() == i - 1)) {
          continue;
        }
        Node folder =
            new ChangedFolderNode(
                getTransitFolderName(allFolders, path), Path.valueOf(path), nodesResources);
        if (currentChildNodes.keySet().contains(path)) {
          folder.setChildren(currentChildNodes.get(path));
        }
        preparedNodes.put(path, folder);
      }

      // Take all child folders and nest them to related parent folders of current nesting level
      List<String> currentPaths = new ArrayList<>(preparedNodes.keySet());
      for (String parentPath : currentPaths) {
        List<Node> nodesToNest = new ArrayList<>();
        for (String nestedItem : currentPaths) {
          if (!parentPath.equals(nestedItem)
              && (nestedItem.startsWith(parentPath + "/") || parentPath.isEmpty())) {
            nodesToNest.add(preparedNodes.remove(nestedItem));
          }
        }
        if (nodesToNest.isEmpty() && !parentPath.isEmpty()) {
          continue;
        }
        nodesToNest.sort(new NameComparator());
        if (currentChildNodes.keySet().contains(parentPath)) {
          nodesToNest.addAll(currentChildNodes.get(parentPath));
        }
        if (parentPath.isEmpty()) {
          return nodesToNest;
        } else {
          preparedNodes.get(parentPath).setChildren(nodesToNest);
        }
      }
    }
    ArrayList<Node> nodes = new ArrayList<>(preparedNodes.values());
    nodes.sort(new NameComparator());
    return new ArrayList<>(nodes);
  }

