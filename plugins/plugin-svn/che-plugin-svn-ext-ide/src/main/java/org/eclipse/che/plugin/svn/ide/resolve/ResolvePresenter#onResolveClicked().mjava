  @Override
  public void onResolveClicked() {

    final Project project = appContext.getRootProject();

    checkState(project != null);

    HashMap<String, String> filesConflictResolutionActions = new HashMap<String, String>();
    Iterator<String> iterConflicts = conflictsList.iterator();

    while (iterConflicts.hasNext()) {
      String path = iterConflicts.next();
      String resolutionActionText = view.getConflictResolutionAction(path);
      if (!resolutionActionText.equals(ConflictResolutionAction.POSTPONE.getText())) {
        filesConflictResolutionActions.put(path, resolutionActionText);
        iterConflicts.remove();
      }
    }

    if (filesConflictResolutionActions.size() > 0) {
      service
          .resolve(project.getLocation(), filesConflictResolutionActions, "infinity")
          .then(
              new Operation<CLIOutputResponseList>() {
                @Override
                public void apply(CLIOutputResponseList response) throws OperationException {
                  for (CLIOutputResponse outputResponse : response.getCLIOutputResponses()) {
                    printResponse(
                        outputResponse.getCommand(),
                        outputResponse.getOutput(),
                        null,
                        constants.commandResolve());
                  }
                }
              })
          .catchError(
              new Operation<PromiseError>() {
                @Override
                public void apply(PromiseError error) throws OperationException {
                  notificationManager.notify(error.getMessage(), FAIL, FLOAT_MODE);
                }
              });
    }
    view.close();
  }

