  @PostConstruct
  public void start() {
    eventService.subscribe(
        new EventSubscriber<MachineStatusEvent>() {
          @Override
          public void onEvent(MachineStatusEvent event) {
            if (event.getEventType() == MachineStatus.RUNNING) {
              /*final Instance machine;
              try {
                  machine = environmentEngine.getMachine(event.getWorkspaceId(),
                                                         event.getMachineId());
              } catch (NotFoundException e) {
                  LOG.error("Unable to find machine: " + e.getLocalizedMessage(), e);
                  return;
              }*/

              /*try {
                  // get machine keypairs
                  List<SshPairImpl> sshPairs = sshManager.getPairs(machine.getOwner(), "machine");
                  final List<String> publicMachineKeys = sshPairs.stream()
                                                       .filter(sshPair -> sshPair.getPublicKey() != null)
                                                       .map(SshPairImpl::getPublicKey)
                                                       .collect(Collectors.toList());

                  // get workspace keypair (if any)
                  SshPairImpl sshWorkspacePair = null;
                  try {
                      sshWorkspacePair = sshManager.getPair(machine.getOwner(), "workspace", event.getWorkspaceId());
                  } catch (NotFoundException e) {
                      LOG.debug("No ssh key associated to the workspace", e);
                  }

                  // build list of all pairs.
                  final List<String> publicKeys;
                  if (sshWorkspacePair != null && sshWorkspacePair.getPublicKey() != null) {
                      publicKeys = new ArrayList<>(publicMachineKeys.size() + 1);
                      publicKeys.add(sshWorkspacePair.getPublicKey());
                      publicKeys.addAll(publicMachineKeys);
                  } else {
                      publicKeys = publicMachineKeys;
                  }

                  if (publicKeys.isEmpty()) {
                      return;
                  }

                  final String containerId = machine.getRuntime().getProperties().get("id");
                  StringBuilder command = new StringBuilder("mkdir ~/.ssh/ -p");
                  for (String publicKey : publicKeys) {
                      command.append("&& echo '")
                             .append(publicKey)
                             .append("' >> ~/.ssh/authorized_keys");
                  }

                  final Exec exec = docker.createExec(CreateExecParams.create(containerId,
                                                                              new String[] {"/bin/bash",
                                                                                            "-c",
                                                                                            command.toString()})
                                                                      .withDetach(true));
                  docker.startExec(StartExecParams.create(exec.getId()), logMessage -> {
                      if (logMessage.getType() == LogMessage.Type.STDERR) {
                          try {
                              machine.getLogger().writeLine("Error of injection public ssh keys. " + logMessage.getContent());
                          } catch (IOException ignore) {
                          }
                      }
                  });
              } catch (IOException | ServerException e) {
                  LOG.error(e.getLocalizedMessage(), e);
              }*/
            }
          }
        });
  }

