  private int collectQuickFixableAnnotations(
      final LinearRange range,
      Document document,
      final Map<Annotation, org.eclipse.che.ide.api.editor.text.Position> annotations,
      final boolean goToClosest,
      List<Diagnostic> resultingDiagnostics) {
    int invocationLocation = range.getStartOffset();
    if (goToClosest) {
      LinearRange line =
          document.getLinearRangeForLine(
              document.getPositionFromIndex(range.getStartOffset()).getLine());
      int rangeStart = line.getStartOffset();
      int rangeEnd = rangeStart + line.getLength();

      List<org.eclipse.che.ide.api.editor.text.Position> allPositions = new LinkedList<>();
      List<DiagnosticAnnotation> allAnnotations = new LinkedList<>();
      int bestOffset = Integer.MAX_VALUE;
      for (Annotation a : annotations.keySet()) {
        org.eclipse.che.ide.api.editor.text.Position pos = annotations.get(a);
        if (pos != null && isInside(pos.offset, rangeStart, rangeEnd)) { // inside our range?
          allAnnotations.add((DiagnosticAnnotation) a);
          allPositions.add(pos);
          bestOffset = processAnnotation(a, pos, invocationLocation, bestOffset);
        }
      }
      if (bestOffset == Integer.MAX_VALUE) {
        return invocationLocation;
      }
      for (int i = 0; i < allPositions.size(); i++) {
        org.eclipse.che.ide.api.editor.text.Position pos = allPositions.get(i);
        if (isInside(bestOffset, pos.offset, pos.offset + pos.length)) {
          resultingDiagnostics.add(allAnnotations.get(i).getDiagnostic());
        }
      }

      return bestOffset;
    } else {
      // iteration with range never returns anything; need to filter ourselves.
      // https://github.com/eclipse/che/issues/4338
      resultingDiagnostics.addAll(
          annotations
              .entrySet()
              .stream()
              .filter((e) -> e.getValue().overlapsWith(range.getStartOffset(), range.getLength()))
              .map(Entry::getKey)
              .map(a -> (DiagnosticAnnotation) a)
              .map(DiagnosticAnnotation::getDiagnostic)
              .collect(Collectors.toList()));
    }
    return invocationLocation;
  }

