    private Instance createInstance(final String containerName,
                                    final Machine machine,
                                    final String imageName,
                                    final LineConsumer outputConsumer)
            throws MachineException {
        String containerIdCopy = null;
        try {
            final Map<String, Map<String, String>> portsToExpose;
            final String[] volumes;
            final List<String> env;
            if (machine.getConfig().isDev()) {
                portsToExpose = new HashMap<>(devMachinePortsToExpose);

                final String projectFolderVolume = format("%s:%s:Z",
                                                          workspaceFolderPathProvider.getPath(machine.getWorkspaceId()),
                                                          projectFolderPath);
                volumes = ObjectArrays.concat(devMachineSystemVolumes,
                                              SystemInfo.isWindows() ? escapePath(projectFolderVolume) : projectFolderVolume);

                env = new ArrayList<>(devMachineEnvVariables);
                env.add(DockerInstanceRuntimeInfo.CHE_WORKSPACE_ID + '=' + machine.getWorkspaceId());
                env.add(DockerInstanceRuntimeInfo.USER_TOKEN + '=' + getUserToken(machine.getWorkspaceId()));
            } else {
                portsToExpose = new HashMap<>(commonMachinePortsToExpose);
                volumes = commonMachineSystemVolumes;
                env = new ArrayList<>(commonMachineEnvVariables);
            }

            final long machineMemory = machine.getConfig().getLimits().getRam() * 1024L * 1024L;
            final long machineMemorySwap = memorySwapMultiplier == -1 ? -1 : (long)(machineMemory * memorySwapMultiplier);

            machine.getConfig()
                   .getServers()
                   .stream()
                   .forEach(serverConf -> portsToExpose.put(serverConf.getPort(), Collections.emptyMap()));

            machine.getConfig()
                   .getEnvVariables()
                   .entrySet()
                   .stream()
                   .map(entry -> entry.getKey() + "=" + entry.getValue())
                   .forEach(env::add);

            final HostConfig hostConfig = new HostConfig().withBinds(volumes)
                                                          .withExtraHosts(allMachinesExtraHosts)
                                                          .withPublishAllPorts(true)
                                                          .withMemorySwap(machineMemorySwap)
                                                          .withMemory(machineMemory)
                                                          .withPrivileged(privilegeMode);
            final ContainerConfig config = new ContainerConfig().withImage(imageName)
                                                                .withExposedPorts(portsToExpose)
                                                                .withHostConfig(hostConfig)
                                                                .withEnv(env.toArray(new String[env.size()]));

            final String containerId = docker.createContainer(CreateContainerParams.create(config)
                                                                                   .withContainerName(containerName))
                                                                                   .getId();
            containerIdCopy = containerId;

            docker.startContainer(StartContainerParams.create(containerId));

            executor.execute(() -> {
                long lastProcessedLogDate = 0;
                boolean isContainerRunning = true;
                while (isContainerRunning) {
                    try {
                        docker.getContainerLogs(GetContainerLogsParams.create(containerId)
                                                                      .withFollow(true)
                                                                      .withSince(lastProcessedLogDate),
                                                new LogMessagePrinter(outputConsumer));
                        isContainerRunning = false;
                    } catch (SocketTimeoutException ste) {
                        lastProcessedLogDate = System.currentTimeMillis() / 1000L;
                        // reconnect to container
                    } catch (ContainerNotFoundException e) {
                        isContainerRunning = false;
                    } catch (IOException e) {
                        LOG.error("Failed to get logs from machine {} backed by container {} with {} id",
                                  machine,
                                  containerName,
                                  containerId);
                    }
                }
            });

            final DockerNode node = dockerMachineFactory.createNode(machine.getWorkspaceId(), containerId);
            if (machine.getConfig().isDev()) {
                node.bindWorkspace();
                LOG.info("Machine with id '{}' backed by container '{}' has been deployed on node '{}'",
                         machine.getId(), containerId, node.getHost());
            }

            dockerInstanceStopDetector.startDetection(containerId,
                                                      machine.getId(),
                                                      machine.getWorkspaceId());

            return dockerMachineFactory.createInstance(machine,
                                                       containerId,
                                                       imageName,
                                                       node,
                                                       outputConsumer);
        } catch (IOException e) {
            cleanUpContainer(containerIdCopy);
            throw new MachineException(e.getLocalizedMessage(), e);
        } catch (MachineException e) {
            cleanUpContainer(containerIdCopy);
            throw e;
        }
    }

