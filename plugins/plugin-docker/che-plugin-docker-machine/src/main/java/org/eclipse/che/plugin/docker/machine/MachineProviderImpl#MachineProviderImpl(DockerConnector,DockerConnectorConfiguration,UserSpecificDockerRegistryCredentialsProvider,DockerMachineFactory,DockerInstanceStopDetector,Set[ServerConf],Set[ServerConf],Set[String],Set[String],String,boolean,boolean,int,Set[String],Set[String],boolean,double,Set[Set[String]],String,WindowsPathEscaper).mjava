    @Inject
    public MachineProviderImpl(DockerConnector docker,
                               DockerConnectorConfiguration dockerConnectorConfiguration,
                               UserSpecificDockerRegistryCredentialsProvider dockerCredentials,
                               DockerMachineFactory dockerMachineFactory,
                               DockerInstanceStopDetector dockerInstanceStopDetector,
                               @Named("machine.docker.dev_machine.machine_servers") Set<ServerConf> devMachineServers,
                               @Named("machine.docker.machine_servers") Set<ServerConf> allMachinesServers,
                               @Named("machine.docker.dev_machine.machine_volumes") Set<String> devMachineSystemVolumes,
                               @Named("machine.docker.machine_volumes") Set<String> allMachinesSystemVolumes,
                               @Nullable @Named("che.workspace.hosts") String allMachinesExtraHosts,
                               @Named("che.docker.always_pull_image") boolean doForcePullOnBuild,
                               @Named("che.docker.privilege") boolean privilegeMode,
                               @Named("che.docker.pids_limit") int pidsLimit,
                               @Named("machine.docker.dev_machine.machine_env") Set<String> devMachineEnvVariables,
                               @Named("machine.docker.machine_env") Set<String> allMachinesEnvVariables,
                               @Named("che.docker.registry_for_snapshots") boolean snapshotUseRegistry,
                               @Named("che.docker.swap") double memorySwapMultiplier,
                               @Named("machine.docker.networks") Set<Set<String>> additionalNetworks,
                               @Nullable @Named("che.docker.network_driver") String networkDriver,
                               WindowsPathEscaper windowsPathEscaper)
            throws IOException {
        this.docker = docker;
        this.dockerCredentials = dockerCredentials;
        this.dockerMachineFactory = dockerMachineFactory;
        this.dockerInstanceStopDetector = dockerInstanceStopDetector;
        this.doForcePullOnBuild = doForcePullOnBuild;
        this.privilegeMode = privilegeMode;
        this.snapshotUseRegistry = snapshotUseRegistry;
        // use-cases:
        //  -1  enable unlimited swap
        //  0   disable swap
        //  0.5 enable swap with size equal to half of current memory size
        //  1   enable swap with size equal to current memory size
        //
        //  according to docker docs field  memorySwap should be equal to memory+swap
        //  we calculate this field as memorySwap=memory * (1 + multiplier) so we just add 1 to multiplier
        this.memorySwapMultiplier = memorySwapMultiplier == -1 ? -1 : memorySwapMultiplier + 1;
        this.networkDriver = networkDriver;
        this.windowsPathEscaper = windowsPathEscaper;
        this.pidsLimit = pidsLimit;

        allMachinesSystemVolumes = removeEmptyAndNullValues(allMachinesSystemVolumes);
        devMachineSystemVolumes = removeEmptyAndNullValues(devMachineSystemVolumes);

        allMachinesSystemVolumes = allMachinesSystemVolumes.stream()
                                                           .map(line -> line.split(";"))
                                                           .flatMap(Arrays::stream)
                                                           .distinct()
                                                           .collect(toSet());

        devMachineSystemVolumes = devMachineSystemVolumes.stream()
                                                         .map(line -> line.split(";"))
                                                         .flatMap(Arrays::stream)
                                                         .distinct()
                                                         .collect(toSet());

        if (SystemInfo.isWindows()) {
            allMachinesSystemVolumes = escapePaths(allMachinesSystemVolumes);
            devMachineSystemVolumes = escapePaths(devMachineSystemVolumes);
        }
        this.commonMachineSystemVolumes = new ArrayList<>(allMachinesSystemVolumes);
        List<String> devMachineVolumes = new ArrayList<>(allMachinesSystemVolumes.size()
                                                         + devMachineSystemVolumes.size());
        devMachineVolumes.addAll(allMachinesSystemVolumes);
        devMachineVolumes.addAll(devMachineSystemVolumes);
        this.devMachineSystemVolumes = devMachineVolumes;

        this.devMachinePortsToExpose = new ArrayList<>(allMachinesServers.size() + devMachineServers.size());
        this.commonMachinePortsToExpose = new ArrayList<>(allMachinesServers.size());
        for (ServerConf serverConf : devMachineServers) {
            devMachinePortsToExpose.add(serverConf.getPort());
        }
        for (ServerConf serverConf : allMachinesServers) {
            commonMachinePortsToExpose.add(serverConf.getPort());
            devMachinePortsToExpose.add(serverConf.getPort());
        }

        allMachinesEnvVariables = removeEmptyAndNullValues(allMachinesEnvVariables);
        devMachineEnvVariables = removeEmptyAndNullValues(devMachineEnvVariables);
        this.commonMachineEnvVariables = new HashMap<>();
        this.devMachineEnvVariables = new HashMap<>();
        allMachinesEnvVariables.forEach(envVar -> {
            String[] split = envVar.split("=", 2);
            this.commonMachineEnvVariables.put(split[0], split[1]);
            this.devMachineEnvVariables.put(split[0], split[1]);
        });
        devMachineEnvVariables.forEach(envVar -> {
            String[] split = envVar.split("=", 2);
            this.devMachineEnvVariables.put(split[0], split[1]);
        });

        // always add Che server to hosts list
        String cheHost = dockerConnectorConfiguration.getDockerHostIp();
        String cheHostAlias = DockerInstanceRuntimeInfo.CHE_HOST.concat(":").concat(cheHost);
        if (isNullOrEmpty(allMachinesExtraHosts)) {
            this.allMachinesExtraHosts = new String[] {cheHostAlias};
        } else {
            this.allMachinesExtraHosts = ObjectArrays.concat(allMachinesExtraHosts.split(","), cheHostAlias);
        }

        this.additionalNetworks = additionalNetworks.stream()
                                                    .flatMap(Set::stream)
                                                    .collect(toSet());

        // TODO single point of failure in case of highly loaded system
        executor = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("MachineLogsStreamer-%d")
                                                                           .setUncaughtExceptionHandler(
                                                                                   LoggingUncaughtExceptionHandler.getInstance())
                                                                           .setDaemon(true)
                                                                           .build());
    }

