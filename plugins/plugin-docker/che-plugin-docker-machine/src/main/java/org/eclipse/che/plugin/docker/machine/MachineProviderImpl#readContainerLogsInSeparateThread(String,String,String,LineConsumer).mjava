  @VisibleForTesting
  void readContainerLogsInSeparateThread(
      String container, String workspaceId, String machineId, LineConsumer outputConsumer) {
    executor.execute(
        ThreadLocalPropagateContext.wrap(
            () -> {
              long lastProcessedLogDate = 0;
              boolean isContainerRunning = true;
              int errorsCounter = 0;
              long lastErrorTime = 0;
              while (isContainerRunning) {
                try {
                  docker.getContainerLogs(
                      GetContainerLogsParams.create(container)
                          .withFollow(true)
                          .withSince(lastProcessedLogDate),
                      new LogMessagePrinter(outputConsumer));
                  isContainerRunning = false;
                } catch (SocketTimeoutException ste) {
                  lastProcessedLogDate = System.currentTimeMillis() / 1000L;
                  // reconnect to container
                } catch (ContainerNotFoundException e) {
                  isContainerRunning = false;
                } catch (IOException e) {
                  long errorTime = System.currentTimeMillis();
                  lastProcessedLogDate = errorTime / 1000L;
                  LOG.warn(
                      "Failed to get logs from machine {} of workspace {} backed by container {}, because: {}.",
                      machineId,
                      workspaceId,
                      container,
                      e.getMessage(),
                      e);
                  if (errorTime - lastErrorTime
                      < 20_000L) { // if new error occurs less than 20 seconds after previous
                    if (++errorsCounter == 5) {
                      LOG.error(
                          "Too many errors while streaming logs from machine {} of workspace {} backed by container {}. "
                              + "Logs streaming is closed. Last error: {}.",
                          machineId,
                          workspaceId,
                          container,
                          e.getMessage(),
                          e);
                      break;
                    }
                  } else {
                    errorsCounter = 1;
                  }
                  lastErrorTime = errorTime;

                  try {
                    sleep(1_000);
                  } catch (InterruptedException ie) {
                    return;
                  }
                }
              }
            }));
  }

