  /**
   * Creates a pod with {@code command} and reports whether it succeeded
   *
   * @param workspacesPvcName name of the PVC to mount
   * @param projectNamespace OpenShift namespace
   * @param jobNamePrefix prefix used for pod metadata name. Name structure will normally be {@code
   *     <prefix><workspaceDirs>} if only one path is passed, or {@code <prefix>batch} if multiple
   *     paths are provided
   * @param command command to execute in PVC.
   * @param workspaceDirs list of arguments attached to command. A list of directories to
   *     create/delete.
   * @return true if Pod terminates with phase "Succeeded" or mkdir command issued for already
   *     created worksapce, false otherwise.
   * @see Command
   */
  protected boolean createJobPod(
      String workspacesPvcName,
      String projectNamespace,
      String jobNamePrefix,
      Command command,
      String... workspaceDirs) {

    if (workspaceDirs.length == 0) {
      return true;
    }

    List<String> logsDirs = Arrays.asList(workspaceDirs);
    logsDirs =
        logsDirs
            .stream()
            .map(dir -> dir + WORKSPACE_LOGS_FOLDER_SUFFIX)
            .collect(Collectors.toList());

    List<String> allDirs = new ArrayList<>();
    allDirs.addAll(Arrays.asList(workspaceDirs));
    allDirs.addAll(logsDirs);
    String[] allDirsArray = allDirs.toArray(new String[allDirs.size()]);

    if (Command.MAKE.equals(command)) {
      String[] dirsToCreate = filterDirsToCreate(allDirsArray);
      if (dirsToCreate.length == 0) {
        return true;
      }
      allDirsArray = dirsToCreate;
    }

    VolumeMount vm =
        new VolumeMountBuilder().withMountPath("/projects").withName(workspacesPvcName).build();

    PersistentVolumeClaimVolumeSource pvcs =
        new PersistentVolumeClaimVolumeSourceBuilder().withClaimName(workspacesPvcName).build();

    Volume volume =
        new VolumeBuilder().withPersistentVolumeClaim(pvcs).withName(workspacesPvcName).build();

    String[] jobCommand = getCommand(command, "/projects/", allDirsArray);
    LOG.info(
        "Executing command {} in PVC {} for {} dirs",
        jobCommand[0],
        workspacesPvcName,
        allDirs.size());

    Map<String, Quantity> limit = Collections.singletonMap("memory", new Quantity(jobMemoryLimit));

    String podName =
        workspaceDirs.length > 1 ? jobNamePrefix + "batch" : jobNamePrefix + workspaceDirs[0];

    Container container =
        new ContainerBuilder()
            .withName(podName)
            .withImage(jobImage)
            .withImagePullPolicy("IfNotPresent")
            .withNewSecurityContext()
            .withPrivileged(false)
            .endSecurityContext()
            .withCommand(jobCommand)
            .withVolumeMounts(vm)
            .withNewResources()
            .withLimits(limit)
            .endResources()
            .build();

    Pod podSpec =
        new PodBuilder()
            .withNewMetadata()
            .withName(podName)
            .endMetadata()
            .withNewSpec()
            .withContainers(container)
            .withVolumes(volume)
            .withRestartPolicy("Never")
            .endSpec()
            .build();

    try (OpenShiftClient openShiftClient = new DefaultOpenShiftClient()) {
      openShiftClient.pods().inNamespace(projectNamespace).create(podSpec);
      boolean completed = false;
      while (!completed) {
        Pod pod = openShiftClient.pods().inNamespace(projectNamespace).withName(podName).get();
        String phase = pod.getStatus().getPhase();
        switch (phase) {
          case POD_PHASE_FAILED:
            LOG.info("Pod command {} failed", Arrays.toString(jobCommand));
            // fall through
          case POD_PHASE_SUCCEEDED:
            openShiftClient.resource(pod).delete();
            updateCreatedDirs(command, phase, allDirsArray);
            return POD_PHASE_SUCCEEDED.equals(phase);
          default:
            Thread.sleep(1000);
        }
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }
    return false;
  }

