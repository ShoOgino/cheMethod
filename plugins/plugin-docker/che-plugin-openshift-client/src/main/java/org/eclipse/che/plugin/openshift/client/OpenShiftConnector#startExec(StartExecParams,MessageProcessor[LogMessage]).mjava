  @Override
  public void startExec(
      final StartExecParams params, @Nullable MessageProcessor<LogMessage> execOutputProcessor)
      throws IOException {
    String execId = params.getExecId();

    KubernetesExecHolder exec = execMap.get(execId);

    String podName = exec.getPod();
    String[] command = exec.getCommand();
    for (int i = 0; i < command.length; i++) {
      command[i] = URLEncoder.encode(command[i], "UTF-8");
    }

    ExecutorService executor = Executors.newFixedThreadPool(2);
    OpenShiftClient openShiftClient =
        new DefaultOpenShiftClient(
            openshiftWorkspaceEnvironmentProvider.getWorkspacesOpenshiftConfig());
    try (ExecWatch watch =
            openShiftClient
                .pods()
                .inNamespace(
                    openshiftWorkspaceEnvironmentProvider.getWorkspacesOpenshiftNamespace())
                .withName(podName)
                .redirectingOutput()
                .redirectingError()
                .exec(command);
        InputStreamPumper outputPump =
            new InputStreamPumper(
                watch.getOutput(),
                new KubernetesOutputAdapter(LogMessage.Type.STDOUT, execOutputProcessor));
        InputStreamPumper errorPump =
            new InputStreamPumper(
                watch.getError(),
                new KubernetesOutputAdapter(LogMessage.Type.STDERR, execOutputProcessor))) {
      Future<?> outFuture = executor.submit(outputPump);
      Future<?> errFuture = executor.submit(errorPump);
      // Short-term worksaround; the Futures above seem to never finish.
      Thread.sleep(2500);
    } catch (KubernetesClientException e) {
      throw new OpenShiftException(e.getMessage());
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    } finally {
      execMap.remove(execId);
      executor.shutdown();
      openShiftClient.close();
    }
  }

