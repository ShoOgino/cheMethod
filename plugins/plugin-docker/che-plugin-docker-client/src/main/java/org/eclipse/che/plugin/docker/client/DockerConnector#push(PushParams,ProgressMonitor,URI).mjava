    private String push(final PushParams params, final ProgressMonitor progressMonitor, URI dockerDaemonUri)
            throws IOException, InterruptedException {
        final String fullRepo = (params.getRegistry() != null) ?
                                params.getRegistry() + '/' + params.getRepository() : params.getRepository();
        final ValueHolder<String> digestHolder = new ValueHolder<>();

        try (DockerConnection connection = connectionFactory.openConnection(dockerDaemonUri)
                                                            .method("POST")
                                                            .path("/images/" + fullRepo + "/push")
                                                            .header("X-Registry-Auth", initialAuthConfig.getAuthConfigHeader())) {
            addQueryParamIfNotNull(connection, "tag", params.getTag());
            final DockerResponse response = connection.request();
            if (OK.getStatusCode() != response.getStatus()) {
                throw getDockerException(response);
            }
            try (InputStream responseStream = response.getInputStream()) {
                JsonMessageReader<ProgressStatus> progressReader = new JsonMessageReader<>(responseStream, ProgressStatus.class);

                final ValueHolder<IOException> errorHolder = new ValueHolder<>();
                //it is necessary to track errors during the push, this is useful in the case when docker API returns status 200 OK,
                //but in fact we have an error (e.g docker registry is not accessible but we are trying to push).
                final ValueHolder<String> exceptionHolder = new ValueHolder<>();
                // Here do some trick to be able interrupt push process. Basically for now it is not possible interrupt docker daemon while
                // it's pushing images but here we need just be able to close connection to the unix socket. Thread is blocking while read
                // from the socket stream so need one more thread that is able to close socket. In this way we can release thread that is
                // blocking on i/o.
                final Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            String digestPrefix = firstNonNull(params.getTag(), "latest") + ": digest: ";
                            ProgressStatus progressStatus;
                            while ((progressStatus = progressReader.next()) != null && exceptionHolder.get() == null) {
                                progressMonitor.updateProgress(progressStatus);
                                if (progressStatus.getError() != null) {
                                    exceptionHolder.set(progressStatus.getError());
                                }
                                String status = progressStatus.getStatus();
                                // Here we find string with digest which has following format:
                                // <tag>: digest: <digest> size: <size>
                                // for example:
                                // latest: digest: sha256:9a70e6222ded459fde37c56af23887467c512628eb8e78c901f3390e49a800a0 size: 62189
                                if (status != null && status.startsWith(digestPrefix)) {
                                    String digest = status.substring(digestPrefix.length(), status.indexOf(" ", digestPrefix.length()));
                                    digestHolder.set(digest);
                                }
                            }
                        } catch (IOException e) {
                            errorHolder.set(e);
                        }
                        synchronized (this) {
                            notify();
                        }
                    }
                };
                executor.execute(runnable);
                // noinspection SynchronizationOnLocalVariableOrMethodParameter
                synchronized (runnable) {
                    runnable.wait();
                }
                if (exceptionHolder.get() != null) {
                    throw new DockerException(exceptionHolder.get(), 500);
                }
                if (digestHolder.get() == null) {
                    LOG.error("Docker image {}:{} was successfully pushed, but its digest wasn't obtained",
                              fullRepo,
                              firstNonNull(params.getTag(), "latest"));
                    throw new DockerException("Docker image was successfully pushed, but its digest wasn't obtained", 500);
                }
                final IOException ioe = errorHolder.get();
                if (ioe != null) {
                    throw ioe;
                }
            }
        }
        return digestHolder.get();
    }

