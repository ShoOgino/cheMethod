    /**
     * Pull an image from registry.
     * To pull from private registry use registry.address:port/image as image.
     *
     * @param progressMonitor
     *         ProgressMonitor for images creation process
     * @param dockerDaemonUri
     *         docker service URI
     * @throws IOException
     *          when a problem occurs with docker api calls
     */
    protected void pull(final PullParams params,
                        final ProgressMonitor progressMonitor,
                        final URI dockerDaemonUri) throws IOException {
        try (DockerConnection connection = connectionFactory.openConnection(dockerDaemonUri)
                                                            .method("POST")
                                                            .path(apiVersionPathPrefix + "/images/create")
                                                            .query("fromImage", params.getFullRepo())
                                                            .header("X-Registry-Auth",
                                                                    authResolver.getXRegistryAuthHeaderValue(
                                                                            params.getRegistry(),
                                                                            params.getAuthConfigs()))) {
            addQueryParamIfNotNull(connection, "tag", params.getTag());
            final DockerResponse response = connection.request();
            if (OK.getStatusCode() != response.getStatus()) {
                throw getDockerException(response);
            }

            try (InputStream responseStream = response.getInputStream()) {
                JsonMessageReader<ProgressStatus> progressReader = new JsonMessageReader<>(responseStream, ProgressStatus.class);

                // Here do some trick to be able interrupt output streaming process.
                // Current unix socket implementation of DockerConnection doesn't react to interruption.
                // So to be able to close unix socket connection and free resources we use main thread.
                // In case of any exception main thread cancels future and close connection.
                // If Docker connection implementation supports interrupting it will stop streaming on interruption,
                // if not it will be stopped by closure of unix socket
                Future<Object> pullFuture = executor.submit(() -> {
                    ProgressStatus progressStatus;
                    while ((progressStatus = progressReader.next()) != null) {
                        progressMonitor.updateProgress(progressStatus);
                    }

                    return null;
                });

                // perform get to be able to get execution exception
                pullFuture.get();
            } catch (ExecutionException e) {
                // unwrap exception thrown by task with .getCause()
                throw new DockerException(e.getCause().getLocalizedMessage(), 500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new DockerException("Docker image pulling was interrupted", 500);
            }
        }
    }

