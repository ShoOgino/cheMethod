    /**
     * Builds new docker image from specified tar archive that must contain Dockerfile.
     *
     * @param repository
     *         full repository name to be applied to newly created image
     * @param tar
     *         archived files that are needed for creation docker images (e.g. file of directories used in ADD instruction in Dockerfile).
     *         One of them must be Dockerfile.
     * @param progressMonitor
     *         ProgressMonitor for images creation process
     * @param dockerDaemonUri
     *         Uri for remote access to docker API
     * @param authConfigs
     *         Authentication configuration for private registries. Can be null.
     * @param memoryLimit
     *         Memory limit for build in bytes
     * @param memorySwapLimit
     *         Total memory in bytes (memory + swap), -1 to enable unlimited swap
     * @return image id
     * @throws IOException
     * @throws InterruptedException
     *         if build process was interrupted
     */
    protected String doBuildImage(String repository,
                                  File tar,
                                  final ProgressMonitor progressMonitor,
                                  URI dockerDaemonUri,
                                  AuthConfigs authConfigs,
                                  boolean doForcePull,
                                  long memoryLimit,
                                  long memorySwapLimit) throws IOException, InterruptedException {
        if (authConfigs == null) {
            authConfigs = initialAuthConfig.getAuthConfigs();
        }
        final List<Pair<String, ?>> headers = new ArrayList<>(3);
        headers.add(Pair.of("Content-Type", "application/x-compressed-tar"));
        headers.add(Pair.of("Content-Length", tar.length()));
        headers.add(Pair.of("X-Registry-Config", Base64.encodeBase64String(JsonHelper.toJson(authConfigs).getBytes())));

        try (InputStream tarInput = new FileInputStream(tar);
             DockerConnection connection = connectionFactory.openConnection(dockerDaemonUri)
                                                            .method("POST")
                                                            .path("/build")
                                                            .query("rm", 1)
                                                            .query("pull", doForcePull)
                                                            .headers(headers)
                                                            .entity(tarInput)) {
            if (repository != null) {
                connection.query("t", repository);
            }
            if (memoryLimit != 0 ) {
                connection.query("memory", memoryLimit);
            }
            if (memorySwapLimit != 0) {
                connection.query("memswap", memorySwapLimit);
            }
            final DockerResponse response = connection.request();
            final int status = response.getStatus();
            if (OK.getStatusCode() != status) {
                throw getDockerException(response);
            }
            try (InputStream responseStream = response.getInputStream()) {
                JsonMessageReader<ProgressStatus> progressReader = new JsonMessageReader<>(responseStream, ProgressStatus.class);

                final ValueHolder<IOException> errorHolder = new ValueHolder<>();
                final ValueHolder<String> imageIdHolder = new ValueHolder<>();
                // Here do some trick to be able interrupt build process. Basically for now it is not possible interrupt docker daemon while
                // it's building images but here we need just be able to close connection to the unix socket. Thread is blocking while read
                // from the socket stream so need one more thread that is able to close socket. In this way we can release thread that is
                // blocking on i/o.
                final Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            ProgressStatus progressStatus;
                            while ((progressStatus = progressReader.next()) != null) {
                                final String buildImageId = getBuildImageId(progressStatus);
                                if (buildImageId != null) {
                                    imageIdHolder.set(buildImageId);
                                }
                                progressMonitor.updateProgress(progressStatus);
                            }
                        } catch (IOException e) {
                            errorHolder.set(e);
                        }
                        synchronized (this) {
                            notify();
                        }
                    }
                };
                executor.execute(runnable);
                // noinspection SynchronizationOnLocalVariableOrMethodParameter
                synchronized (runnable) {
                    runnable.wait();
                }
                final IOException ioe = errorHolder.get();
                if (ioe != null) {
                    throw ioe;
                }
                if (imageIdHolder.get() == null) {
                    throw new IOException("Docker image build failed");
                }
                return imageIdHolder.get();
            }
        }
    }

