    private String buildImage(final DockerConnection dockerConnection,
                              final BuildImageParams params,
                              final ProgressMonitor progressMonitor) throws IOException {
        final AuthConfigs authConfigs = params.getAuthConfigs();
        final String repository = params.getRepository();
        final String tag = params.getTag();

        try (DockerConnection connection = dockerConnection.method("POST")
                                                           .path(apiVersionPathPrefix + "/build")
                                                           .query("rm", 1)
                                                           .query("forcerm", 1)
                                                           .header("X-Registry-Config",
                                                                   authResolver.getXRegistryConfigHeaderValue(authConfigs))) {
            if (tag == null) {
                addQueryParamIfNotNull(connection, "t", repository);
            } else {
                addQueryParamIfNotNull(connection, "t", repository == null ? null : repository + ':' + tag);
            }
            addQueryParamIfNotNull(connection, "memory", params.getMemoryLimit());
            addQueryParamIfNotNull(connection, "memswap", params.getMemorySwapLimit());
            addQueryParamIfNotNull(connection, "pull", params.isDoForcePull());
            addQueryParamIfNotNull(connection, "dockerfile", params.getDockerfile());

            final DockerResponse response = connection.request();
            if (OK.getStatusCode() != response.getStatus()) {
                throw getDockerException(response);
            }

            try (InputStream responseStream = response.getInputStream()) {
                JsonMessageReader<ProgressStatus> progressReader = new JsonMessageReader<>(responseStream, ProgressStatus.class);

                // Here do some trick to be able interrupt output streaming process.
                // Current unix socket implementation of DockerConnection doesn't react to interruption.
                // So to be able to close unix socket connection and free resources we use main thread.
                // In case of any exception main thread cancels future and close connection.
                // If Docker connection implementation supports interrupting it will stop streaming on interruption,
                // if not it will be stopped by closure of unix socket
                Future<String> imageIdFuture = executor.submit(() -> {
                    ProgressStatus progressStatus;
                    while ((progressStatus = progressReader.next()) != null) {
                        final String buildImageId = getBuildImageId(progressStatus);
                        if (buildImageId != null) {
                            return buildImageId;
                        }
                        progressMonitor.updateProgress(progressStatus);
                    }

                    throw new DockerException("Docker image build failed. Image id not found in build output.", 500);
                });

                return imageIdFuture.get();
            } catch (ExecutionException e) {
                // unwrap exception thrown by task with .getCause()
                throw new DockerException(e.getCause().getLocalizedMessage(), 500);
            } catch (InterruptedException e) {
                throw new DockerException("Docker image build was interrupted", 500);
            }
        }
    }

