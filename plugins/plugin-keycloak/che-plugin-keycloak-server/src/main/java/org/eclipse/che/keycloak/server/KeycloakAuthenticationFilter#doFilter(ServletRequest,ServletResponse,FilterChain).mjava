  @Override
  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
      throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    final String token = tokenExtractor.getToken(request);
    if (request.getScheme().startsWith("ws") || (token != null && token.startsWith("machine"))) {
      chain.doFilter(req, res);
      return;
    } else {
      final String requestURI = request.getRequestURI();
      if (token == null) {
        LOG.debug("No 'Authorization' header for {}", requestURI);
        send403(res);
        return;
      }

      Jws<Claims> jwt;
      try {
        jwt = Jwts.parser().setSigningKey(getJwtPublicKey(false)).parseClaimsJws(token);
        LOG.debug("JWT = " + jwt.toString());
        //OK, we can trust this JWT
      } catch (SignatureException
          | NoSuchAlgorithmException
          | InvalidKeySpecException
          | IllegalArgumentException e) {
        //don't trust the JWT!
        LOG.error("Failed verifying the JWT token", e);
        try {
          LOG.info("Retrying after updating the public key", e);
          jwt = Jwts.parser().setSigningKey(getJwtPublicKey(true)).parseClaimsJws(token);
          LOG.debug("JWT = " + jwt.toString());
          //OK, we can trust this JWT
        } catch (SignatureException
            | NoSuchAlgorithmException
            | InvalidKeySpecException
            | IllegalArgumentException ee) {
          //don't trust the JWT!
          LOG.error("Failed verifying the JWT token after public key update", e);
          send403(res);
          return;
        }
      }
      request.setAttribute("token", jwt);
      chain.doFilter(req, res);
    }
  }

