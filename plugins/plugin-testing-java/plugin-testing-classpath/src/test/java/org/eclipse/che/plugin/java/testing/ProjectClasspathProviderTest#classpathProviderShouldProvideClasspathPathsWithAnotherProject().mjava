  @Test
  public void classpathProviderShouldProvideClasspathPathsWithAnotherProject() throws Exception {
    JavaModel model = mock(JavaModel.class);
    Field javaModel = JavaModelManager.class.getDeclaredField("javaModel");
    javaModel.setAccessible(true);
    javaModel.set(JavaModelManager.getJavaModelManager(), model);
    IClasspathEntry entry =
        mockClasspathEntry(
            IClasspathEntry.CPE_SOURCE, "/anotherProject/src", "/anotherProject/target/classes");

    IJavaProject anotherProject = mock(IJavaProject.class);
    when(anotherProject.getResolvedClasspath(false)).thenReturn(new IClasspathEntry[] {entry});
    when(model.getJavaProject("/anotherProject")).thenReturn(anotherProject);

    IClasspathEntry classpathEntry =
        mockClasspathEntry(IClasspathEntry.CPE_SOURCE, "", "/testProject/target/classes");
    IClasspathEntry jarClasspathEntry =
        mockClasspathEntry(IClasspathEntry.CPE_LIBRARY, "/absolute/path/to/jar.file", null);
    IClasspathEntry projectEntry =
        mockClasspathEntry(IClasspathEntry.CPE_PROJECT, "/anotherProject", null);

    IClasspathEntry[] entries =
        new IClasspathEntry[] {classpathEntry, jarClasspathEntry, projectEntry};
    when(javaProject.getResolvedClasspath(false)).thenReturn(entries);

    Set<String> classPath = classpathProvider.getProjectClassPath(javaProject);

    assertThat(classPath)
        .isNotNull()
        .isNotEmpty()
        .contains(
            PROJECTS_PATH + "/testProject/target/classes",
            "/absolute/path/to/jar.file",
            PROJECTS_PATH + "/anotherProject/target/classes");
  }

