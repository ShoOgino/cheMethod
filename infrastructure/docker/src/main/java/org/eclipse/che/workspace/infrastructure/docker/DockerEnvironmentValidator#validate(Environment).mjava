    public Environment validate(Environment env) throws ValidationException,
                                                        ServerException {
        checkNotNull(env.getRecipe(), "Environment recipe should not be null");
        checkArgument(SUPPORTED_RECIPE_TYPES.contains(env.getRecipe().getType()),
                      "Environment type '%s' is not supported. Supported types: %s",
                      env.getRecipe().getType(),
                      SUPPORTED_RECIPE_TYPES_STRING);
        checkArgument(env.getRecipe().getContent() != null || env.getRecipe().getLocation() != null,
                      "Recipe of environment must contain location or content");
        checkArgument(env.getRecipe().getContent() == null || env.getRecipe().getLocation() == null,
                      "Recipe of environment contains mutually exclusive fields location and content");

        DockerEnvironment dockerEnvironment;
        try {
            dockerEnvironment = dockerEnvironmentParser.parse(env);
        } catch (ServerException e) {
            throw new ServerException(
                    format("Parsing of recipe of environment failed. Error: %s", e.getLocalizedMessage()));
        } catch (IllegalArgumentException e) {
            throw new ValidationException(
                    format("Parsing of recipe of environment failed. Error: %s", e.getLocalizedMessage()));
        }

        checkArgument(dockerEnvironment.getServices() != null && !dockerEnvironment.getServices().isEmpty(),
                      "Environment should contain at least 1 machine");

        checkArgument(env.getMachines() != null && !env.getMachines().isEmpty(),
                      "Environment doesn't contain machine with 'org.eclipse.che.ws-agent' agent");

        List<String> missingServices = env.getMachines()
                                          .keySet()
                                          .stream()
                                          .filter(machineName -> !dockerEnvironment.getServices()
                                                                                   .containsKey(machineName))
                                          .collect(toList());
        checkArgument(missingServices.isEmpty(),
                      "Environment 'contains machines that are missing in environment recipe: %s",
                      Joiner.on(", ").join(missingServices));

        List<String> devMachines = env.getMachines()
                                      .entrySet()
                                      .stream()
                                      .filter(entry -> entry.getValue().getAgents() != null &&
                                                       entry.getValue().getAgents()
                                                            .contains("org.eclipse.che.ws-agent"))
                                      .map(Map.Entry::getKey)
                                      .collect(toList());

        checkArgument(devMachines.size() == 1,
                      "Environment should contain exactly 1 machine with agent 'org.eclipse.che.ws-agent', but contains '%s'. " +
                      "All machines with this agent: %s",
                      devMachines.size(), Joiner.on(", ").join(devMachines));

        // needed to validate different kinds of dependencies in services to other services
        Set<String> servicesNames = dockerEnvironment.getServices().keySet();

        for (Map.Entry<String, DockerService> entry : dockerEnvironment.getServices().entrySet()) {
            validateMachine(entry.getKey(),
                            env.getMachines().get(entry.getKey()),
                            entry.getValue(),
                            servicesNames);
        }

        // check that order can be resolved
        try {
            startStrategy.order(dockerEnvironment);
        } catch (IllegalArgumentException e) {
            throw new ValidationException(
                    format("Start order of machine in environment is not resolvable. Error: %s",
                           e.getLocalizedMessage()));
        }

        return env;
    }

