    /**
     * Parses {@link Environment} into {@link DockerEnvironment}.
     *
     * @param environment
     *         environment to parse
     * @return environment representation as compose environment
     * @throws IllegalArgumentException
     *         if provided environment is illegal
     * @throws ServerException
     *         if fetching of environment recipe content fails
     */
    public DockerEnvironment parse(Environment environment) throws IllegalArgumentException,
                                                                   ServerException, ValidationException {

        checkNotNull(environment, "Environment should not be null");
        Recipe recipe = environment.getRecipe();
        checkNotNull(recipe, "Environment recipe should not be null");
        checkNotNull(recipe.getType(), "Environment recipe type should not be null");
        checkArgument(recipe.getContent() != null || recipe.getLocation() != null,
                      "OldRecipe of environment must contain location or content");

        String envType = recipe.getType();
        Set<String> envTypes = getEnvironmentTypes();

        if (!envTypes.contains(envType)) {
            throw new IllegalArgumentException(format("Environment type '%s' is not supported. " +
                                                      "Supported environment types: %s",
                                                      envType,
                                                      Joiner.on(", ").join(envTypes)));
        }

        TypeSpecificEnvironmentParser parser = environmentParsers.get(envType);
        DockerEnvironment cheServicesEnvironment = parser.parse(environment);

        cheServicesEnvironment.getServices().forEach((name, service) -> {
            MachineConfig machineConfig = environment.getMachines().get(name);
            if (machineConfig != null) {
                normalizeMachine(name, service, machineConfig);
            }
        });

        return cheServicesEnvironment;
    }

