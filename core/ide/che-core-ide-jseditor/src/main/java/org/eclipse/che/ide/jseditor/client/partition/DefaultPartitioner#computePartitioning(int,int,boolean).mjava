    private List<TypedRegion> computePartitioning(final int offset,
                                                  final int length,
                                                  final boolean includeZeroLengthPartitions) {
        final List<TypedRegion> result = new ArrayList<>();

        final int contentLength = getContentLength();
        try {

            final int endOffset = offset + length;

            final List<TypedPosition> category = getPositions();

            TypedPosition previous = null;
            TypedPosition current = null;
            int start, end, gapOffset;
            final Position gap = new Position(0);

            final int startIndex = getFirstIndexEndingAfterOffset(category, offset);
            final int endIndex = getFirstIndexStartingAfterOffset(category, endOffset);
            for (int i = startIndex; i < endIndex; i++) {

                current = category.get(i);

                gapOffset = (previous != null) ? previous.getOffset() + previous.getLength() : 0;
                gap.setOffset(gapOffset);
                gap.setLength(current.getOffset() - gapOffset);
                if ((includeZeroLengthPartitions && overlapsOrTouches(gap, offset, length))
                    || (gap.getLength() > 0 && gap.overlapsWith(offset, length))) {
                    start = Math.max(offset, gapOffset);
                    end = Math.min(endOffset, gap.getOffset() + gap.getLength());
                    result.add(new TypedRegionImpl(start, end - start, DEFAULT_CONTENT_TYPE));
                }

                if (current.overlapsWith(offset, length)) {
                    start = Math.max(offset, current.getOffset());
                    end = Math.min(endOffset, current.getOffset() + current.getLength());
                    result.add(new TypedRegionImpl(start, end - start, current.getType()));
                }

                previous = current;
            }

            if (previous != null) {
                gapOffset = previous.getOffset() + previous.getLength();
                gap.setOffset(gapOffset);
                gap.setLength(contentLength - gapOffset);
                if ((includeZeroLengthPartitions && overlapsOrTouches(gap, offset, length)) ||
                    (gap.getLength() > 0 && gap.overlapsWith(offset, length))) {
                    start = Math.max(offset, gapOffset);
                    end = Math.min(endOffset, contentLength);
                    result.add(new TypedRegionImpl(start, end - start, DEFAULT_CONTENT_TYPE));
                }
            }

            if (result.isEmpty()) {
                result.add(new TypedRegionImpl(offset, length, DEFAULT_CONTENT_TYPE));
            }

        } catch (final BadPositionCategoryException ex) {
            Logger.getLogger(DefaultPartitioner.class.getName()).fine("Bad position in computePartitioning.");
        } catch (final RuntimeException ex) {
            Logger.getLogger(DefaultPartitioner.class.getName()).warning("computePartitioning failed.");
            throw ex;
        }

        return result;
    }

