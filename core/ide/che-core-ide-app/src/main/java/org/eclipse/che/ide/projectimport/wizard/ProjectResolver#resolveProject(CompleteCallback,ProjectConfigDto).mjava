    /**
     * The method defines project type of passed project and take resolution should project be configured or not.
     *
     * @param callback
     *         callback which is necessary to inform that resolving completed
     * @param projectConfig
     *         project which will be resolved
     */
    public void resolveProject(@NotNull final CompleteCallback callback, @NotNull final ProjectConfigDto projectConfig) {
        final String projectName = projectConfig.getName();
        Unmarshallable<List<SourceEstimation>> unmarshaller = dtoUnmarshallerFactory.newListUnmarshaller(SourceEstimation.class);
        projectService.resolveSources(workspaceId, projectName, new AsyncRequestCallback<List<SourceEstimation>>(unmarshaller) {

            Function<SourceEstimation, ProjectTypeDto> estimateToType = new Function<SourceEstimation, ProjectTypeDto>() {
                @Nullable
                @Override
                public ProjectTypeDto apply(@Nullable SourceEstimation input) {
                    if (input != null) {
                        return projectTypeRegistry.getProjectType(input.getType());
                    }

                    return null;
                }
            };

            Predicate<ProjectTypeDto> isPrimaryable = new Predicate<ProjectTypeDto>() {
                @Override
                public boolean apply(@Nullable ProjectTypeDto input) {
                    return input != null && input.isPrimaryable();

                }
            };

            @Override
            protected void onSuccess(List<SourceEstimation> result) {
                Iterable<ProjectTypeDto> types = filter(transform(result, estimateToType), isPrimaryable);

                if (size(types) == 1) {
                    ProjectTypeDto typeDto = getFirst(types, null);

                    if (typeDto != null) {
                        projectConfig.withType(typeDto.getId());
                    }
                }

                boolean configRequire = false;

                if (isNullOrEmpty(projectConfig.getType())) {
                    projectConfig.withType(Constants.BLANK_ID);
                    configRequire = true;
                }

                projectUpdater.updateProject(callback, projectConfig, configRequire);
            }

            @Override
            protected void onFailure(Throwable exception) {
                projectNotificationSubscriber.onFailure(exception.getMessage());
                callback.onFailure(new Exception(exception.getMessage()));
            }
        });
    }

