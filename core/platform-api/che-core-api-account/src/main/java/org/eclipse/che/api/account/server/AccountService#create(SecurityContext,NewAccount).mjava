    /**
     * Creates new account and adds current user as member to created account
     * with role <i>"account/owner"</i>. Returns status <b>201 CREATED</b>
     * and {@link AccountDescriptor} of created account if account has been created successfully.
     * Each new account should contain at least name.
     *
     * @param newAccount
     *         new account
     * @return descriptor of created account
     * @throws NotFoundException
     *         when some error occurred while retrieving account
     * @throws ConflictException
     *         when new account is {@code null}
     *         or new account name is {@code null}
     *         or when any of new account attributes is not valid
     * @throws ServerException
     * @see AccountDescriptor
     * @see #getById(String, SecurityContext)
     */
    @ApiOperation(value = "Create a new account",
                  notes = "Create a new account",
                  response = Account.class,
                  position = 1)
    @ApiResponses(value = {
            @ApiResponse(code = 201, message = "CREATED"),
            @ApiResponse(code = 404, message = "Not Found"),
            @ApiResponse(code = 409, message = "Conflict Error"),
            @ApiResponse(code = 500, message = "Internal Server Error")})
    @POST
    @GenerateLink(rel = Constants.LINK_REL_CREATE_ACCOUNT)
    @RolesAllowed({"user", "system/admin"})
    @Consumes(APPLICATION_JSON)
    @Produces(APPLICATION_JSON)
    public Response create(@Context SecurityContext securityContext,
                           @Required NewAccount newAccount) throws NotFoundException,
                                                                   ConflictException,
                                                                   ServerException {
        requiredNotNull(newAccount, "New account");
        requiredNotNull(newAccount.getName(), "Account name");
        if (newAccount.getAttributes() != null) {
            for (String attributeName : newAccount.getAttributes().keySet()) {
                validateAttributeName(attributeName);
            }
        }
        User current = null;
        if (securityContext.isUserInRole("user")) {
            current = userDao.getByAlias(securityContext.getUserPrincipal().getName());
            //for now account <-One to One-> user
            if (accountDao.getByOwner(current.getId()).size() != 0) {
                throw new ConflictException(format("Account which owner is %s already exists", current.getId()));
            }
        }

        try {
            accountDao.getByName(newAccount.getName());
            throw new ConflictException(format("Account with name %s already exists", newAccount.getName()));
        } catch (NotFoundException ignored) {
        }
        final String accountId = NameGenerator.generate(Account.class.getSimpleName().toLowerCase(), Constants.ID_LENGTH);
        final Account account = new Account(accountId, newAccount.getName(), null, newAccount.getAttributes());

        accountDao.create(account);
        if (current != null) {
            final Member owner = new Member().withAccountId(accountId)
                                             .withUserId(current.getId())
                                             .withRoles(Arrays.asList("account/owner"));
            accountDao.addMember(owner);
            LOG.info("EVENT#account-add-member# ACCOUNT-ID#{}# USER-ID#{}# ROLES#{}#",
                     accountId,
                     current.getId(),
                     Arrays.asList("account/owner").toString());
        }
        return Response.status(Response.Status.CREATED)
                       .entity(toDescriptor(account))
                       .build();
    }

