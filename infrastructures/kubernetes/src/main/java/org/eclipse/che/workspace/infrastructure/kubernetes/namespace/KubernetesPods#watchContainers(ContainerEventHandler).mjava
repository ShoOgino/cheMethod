  /**
   * Registers a specified handler for handling events about changes in pods containers.
   *
   * @param handler pod container events handler
   * @throws InfrastructureException if any error occurs while watcher starting
   */
  public void watchContainers(ContainerEventHandler handler) throws InfrastructureException {
    if (containerWatch == null) {
      final Watcher<Event> watcher =
          new Watcher<Event>() {
            @Override
            public void eventReceived(Action action, Event event) {
              ObjectReference involvedObject = event.getInvolvedObject();
              String fieldPath = involvedObject.getFieldPath();

              // check that event related to
              if (POD_OBJECT_KIND.equals(involvedObject.getKind()) && fieldPath != null) {
                Matcher containerFieldMatcher = CONTAINER_FIELD_PATH_PATTERN.matcher(fieldPath);
                if (containerFieldMatcher.matches()) {

                  String podName = involvedObject.getName();
                  String containerName = containerFieldMatcher.group(CONTAINER_NAME_GROUP);

                  ContainerEvent containerEvent =
                      new ContainerEvent(
                          podName,
                          containerName,
                          event.getReason(),
                          event.getMessage(),
                          event.getMetadata().getCreationTimestamp(),
                          event.getLastTimestamp());

                  try {
                    if (happenedAfterWatcherInitialization(containerEvent)) {
                      containerEventsHandlers.forEach(h -> h.handle(containerEvent));
                    }
                  } catch (ParseException e) {
                    LOG.error("Failed to parse last timestamp of the event: {}", containerEvent);
                  }
                }
              }
            }

            @Override
            public void onClose(KubernetesClientException ignored) {}

            /**
             * Returns true if 'lastTimestamp' of the event is *after* the time of the watcher
             * initialization
             */
            private boolean happenedAfterWatcherInitialization(ContainerEvent event)
                throws ParseException {
              String eventLastTimestamp = event.getLastTimestamp();
              Date eventLastTimestampDate =
                  ContainerEvents.convertEventTimestampToDate(eventLastTimestamp);
              return eventLastTimestampDate.after(watcherInitializationDate);
            }
          };
      try {
        watcherInitializationDate = new Date();
        containerWatch =
            clientFactory.create(workspaceId).events().inNamespace(namespace).watch(watcher);
      } catch (KubernetesClientException ex) {
        throw new KubernetesInfrastructureException(ex);
      }
    }
    containerEventsHandlers.add(handler);
  }

