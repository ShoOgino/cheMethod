  @Override
  public void apply(
      RuntimeIdentity runtimeIdentity,
      InternalEnvironment internalEnvironment,
      Collection<ChePlugin> chePlugins)
      throws InfrastructureException {
    if (chePlugins.isEmpty()) {
      return;
    }

    KubernetesEnvironment k8sEnv = (KubernetesEnvironment) internalEnvironment;

    Map<String, PodData> pods = k8sEnv.getPodsData();
    switch (pods.size()) {
      case 0:
        addToolingPod(k8sEnv);
        pods = k8sEnv.getPodsData();
        break;
      case 1:
        break;
      default:
        throw new InfrastructureException(
            "Che plugins tooling configuration can be applied to a workspace with one pod only");
    }
    PodData pod = pods.values().iterator().next();

    CommandsResolver commandsResolver = new CommandsResolver(k8sEnv);
    for (ChePlugin chePlugin : chePlugins) {
      for (CheContainer container : chePlugin.getInitContainers()) {
        Container k8sInitContainer = toK8sContainer(container);
        pod.getSpec().getInitContainers().add(k8sInitContainer);
        chePluginsVolumeApplier.applyVolumes(pod, k8sInitContainer, container.getVolumes(), k8sEnv);
      }

      Collection<CommandImpl> pluginRelatedCommands = commandsResolver.resolve(chePlugin);

      for (CheContainer container : chePlugin.getContainers()) {
        addSidecar(pod, container, chePlugin, k8sEnv, pluginRelatedCommands, runtimeIdentity);
      }
    }

    chePlugins.forEach(chePlugin -> populateWorkspaceEnvVars(chePlugin, k8sEnv));

    if (isAuthEnabled) {
      // enable per-workspace security with JWT proxy for sidecar based workspaces
      // because it is the only workspace security implementation supported for now
      k8sEnv.getAttributes().putIfAbsent(SECURE_EXPOSER_IMPL_PROPERTY, "jwtproxy");
    }
  }

