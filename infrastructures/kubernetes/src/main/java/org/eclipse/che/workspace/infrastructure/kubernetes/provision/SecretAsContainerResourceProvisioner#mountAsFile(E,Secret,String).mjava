  private void mountAsFile(E env, Secret secret, String targetContainerName)
      throws InfrastructureException {
    final String mountPath = secret.getMetadata().getAnnotations().get(ANNOTATION_MOUNT_PATH);
    if (mountPath == null) {
      throw new InfrastructureException(
          format(
              "Unable to mount secret '%s': It is configured to be mounted as a file but the mount path was not specified. Please define the '%s' annotation on the secret to specify it.",
              secret.getMetadata().getName(), ANNOTATION_MOUNT_PATH));
    }

    Volume volumeFromSecret =
        new VolumeBuilder()
            .withName(secret.getMetadata().getName())
            .withSecret(
                new SecretVolumeSourceBuilder()
                    .withNewSecretName(secret.getMetadata().getName())
                    .build())
            .build();

    for (PodData podData : env.getPodsData().values()) {
      if (!podData.getRole().equals(PodRole.DEPLOYMENT)) {
        continue;
      }
      if (podData
          .getSpec()
          .getVolumes()
          .stream()
          .anyMatch(v -> v.getName().equals(volumeFromSecret.getName()))) {
        volumeFromSecret.setName(volumeFromSecret.getName() + "_" + NameGenerator.generate("", 6));
      }

      podData.getSpec().getVolumes().add(volumeFromSecret);

      for (Container container : podData.getSpec().getContainers()) {
        if (targetContainerName != null && !container.getName().equals(targetContainerName)) {
          continue;
        }
        secret
            .getData()
            .keySet()
            .forEach(
                secretFile ->
                    container
                        .getVolumeMounts()
                        .add(
                            new VolumeMountBuilder()
                                .withName(volumeFromSecret.getName())
                                .withMountPath(mountPath + "/" + secretFile)
                                .withSubPath(secretFile)
                                .withReadOnly(true)
                                .build()));
      }
    }
  }

