  /**
   * Creates {@link KubernetesEnvironment} with everything needed to deploy Plugin broker.
   *
   * @param pluginsMeta meta info of plugins that needs to be resolved by the broker
   * @param runtimeID ID of the runtime the broker would be started
   * @param brokersResult
   * @return kubernetes environment (or its extension) with the Plugin broker objects
   */
  public E create(Collection<PluginMeta> pluginsMeta, RuntimeIdentity runtimeID,
      BrokersResult brokersResult)
      throws InfrastructureException {

    BrokersConfigs brokersConfigs = new BrokersConfigs();
    Pod pod = brokersConfigs.pod = newPod();
    brokersConfigs.configMaps = new HashMap<>();
    brokersConfigs.machines = new HashMap<>();

    PodSpec spec = pod.getSpec();
    List<EnvVar> envVars = Stream.of(authEnableEnvVarProvider.get(runtimeID),
        machineTokenEnvVarProvider.get(runtimeID)).map(this::asEnvVar).collect(Collectors.toList());

    Multimap<String, PluginMeta> brokersImageToMetas = sortByBrokerImage(pluginsMeta);
    for (Entry<String, Collection<PluginMeta>> brokerImageToMetas : brokersImageToMetas.asMap().entrySet()) {
      BrokerConfig brokerConfig = createBrokerConfig(runtimeID,
          brokerImageToMetas.getValue(),
          envVars,
          brokerImageToMetas.getKey(),
          pod);

      brokersConfigs.machines.put(brokerConfig.machineName, brokerConfig.machineConfig);
      brokersConfigs.configMaps.put(brokerConfig.configMapName, brokerConfig.configMap);
      spec.getContainers().add(brokerConfig.container);
      spec.getVolumes().add(new VolumeBuilder()
          .withName(brokerConfig.configMapVolume)
          .withNewConfigMap()
          .withName(brokerConfig.configMapName)
          .endConfigMap()
          .build());

      brokersResult.oneMoreBroker();
    }
    return doCreate(brokersConfigs);
  }

