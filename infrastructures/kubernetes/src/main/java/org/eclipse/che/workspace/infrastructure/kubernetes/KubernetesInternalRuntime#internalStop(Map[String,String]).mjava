  @Override
  protected void internalStop(Map<String, String> stopOptions) throws InfrastructureException {
    if (startSynchronizer.interrupt()) {
      // runtime is STARTING. Need to wait until start will be interrupted properly
      try {
        if (!startSynchronizer.awaitInterruption(workspaceStartTimeoutMin, TimeUnit.MINUTES)) {
          // Runtime is not interrupted yet. It may occur when start was performing by another
          // Che Server that is crashed so start is hung up in STOPPING phase.
          // Need to clean up runtime resources
          RuntimeIdentity identity = getContext().getIdentity();
          probeScheduler.cancel(identity.getWorkspaceId());
          namespace.cleanUp();
        }
      } catch (InterruptedException e) {
        throw new InfrastructureException(
            "Interrupted while waiting for start task cancellation", e);
      }
    } else {
      // runtime is RUNNING. Clean up used resources
      RuntimeIdentity identity = getContext().getIdentity();
      // Cancels workspace servers probes if any
      probeScheduler.cancel(identity.getWorkspaceId());
      namespace.cleanUp();
    }
  }

