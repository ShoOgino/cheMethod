  @Override
  protected void internalStart(Map<String, String> startOptions) throws InfrastructureException {
    OpenShiftRuntimeContext context = getContext();
    String workspaceId = context.getIdentity().getWorkspaceId();
    try {
      final OpenShiftEnvironment osEnv = context.getEnvironment();
      volumesStrategy.prepare(osEnv, workspaceId);

      List<Service> createdServices = new ArrayList<>();
      for (Service service : osEnv.getServices().values()) {
        createdServices.add(project.services().create(service));
      }

      //      List<Route> createdRoutes = new ArrayList<>();
      //      for (Route route : osEnv.getRoutes().values()) {
      //        createdRoutes.add(project.routes().create(route));
      //      }
      // TODO https://github.com/eclipse/che/issues/7653
      // project.pods().watch(new AbnormalStopHandler());
      // project.pods().watchContainers(new MachineLogsPublisher());

      // needed for resolution later on, even though nroutes are actually created by ingress
      // /workspace{wsid}/server-{port} => service({wsid}):server-port => pod({wsid}):{port}
      List<Ingress> createdIngresses = new ArrayList<>();
      for (Ingress ingress : osEnv.getIngresses().values()) {
        // create
        createdIngresses.add(project.kubernetesIngress().create(ingress));
      }

      // wait for LB ip
      List<Ingress> actualIngresses = new ArrayList<>();
      for (Ingress ingress : osEnv.getIngresses().values()) {
        Ingress actualIngress =
            project
                .kubernetesIngress()
                .wait(
                    ingress.getMetadata().getName(),
                    machineStartTimeoutMin,
                    p -> (p.getStatus().getLoadBalancer().getIngress().size() > 0));
        actualIngresses.add(actualIngress);
      }

      createPods(createdServices, actualIngresses);

      // TODO Rework it to parallel waiting https://github.com/eclipse/che/issues/7067
      for (OpenShiftMachine machine : machines.values()) {
        try {
          machine.waitRunning(machineStartTimeoutMin);
          machine.setStatus(MachineStatus.RUNNING);
          sendRunningEvent(machine.getName());
          bootstrapMachine(machine);
          checkMachineServers(machine);
        } catch (InfrastructureException rethrow) {
          sendFailedEvent(machine.getName(), rethrow.getMessage());
          throw rethrow;
        }
      }
    } catch (InfrastructureException | RuntimeException | InterruptedException e) {
      LOG.warn(
          "Failed to start OpenShift runtime of workspace {}. Cause: {}",
          workspaceId,
          e.getMessage());
      boolean interrupted = Thread.interrupted() || e instanceof InterruptedException;
      // Cancels workspace servers probes if any
      probeScheduler.cancel(workspaceId);
      try {
        project.cleanUp();
      } catch (InfrastructureException ignored) {
      }
      if (interrupted) {
        throw new InfrastructureException("OpenShift environment start was interrupted");
      }
      try {
        throw e;
      } catch (InfrastructureException rethrow) {
        throw rethrow;
      } catch (Exception wrap) {
        throw new InternalInfrastructureException(e.getMessage(), wrap);
      }
    }
  }

