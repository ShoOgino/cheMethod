  /**
   * Push docker image to the registry.
   *
   * @param progressMonitor ProgressMonitor for images pushing process
   * @return digest of just pushed image
   * @throws IOException when a problem occurs with docker api calls
   */
  public String push(final PushParams params, final ProgressMonitor progressMonitor)
      throws IOException {
    final String fullRepo = params.getFullRepo();

    try (DockerConnection connection =
        connectionFactory
            .openConnection(dockerDaemonUri)
            .method("POST")
            .path(apiVersionPathPrefix + "/images/" + fullRepo + "/push")
            .header(
                "X-Registry-Auth",
                authResolver.getXRegistryAuthHeaderValue(
                    params.getRegistry(), params.getAuthConfigs()))) {
      addQueryParamIfNotNull(connection, "tag", params.getTag());
      final DockerResponse response = connection.request();
      if (OK.getStatusCode() != response.getStatus()) {
        throw getDockerException(response);
      }

      try (InputStream responseStream = response.getInputStream()) {
        JsonMessageReader<ProgressStatus> progressReader =
            new JsonMessageReader<>(responseStream, ProgressStatus.class);

        // Here do some trick to be able interrupt output streaming process.
        // Current unix socket implementation of DockerConnection doesn't react to interruption.
        // So to be able to close unix socket connection and free resources we use main thread.
        // In case of any exception main thread cancels future and close connection.
        // If Docker connection implementation supports interrupting it will stop streaming on interruption,
        // if not it will be stopped by closure of unix socket
        Future<String> digestFuture =
            executor.submit(
                () -> {
                  String digestPrefix = firstNonNull(params.getTag(), "latest") + ": digest: ";
                  ProgressStatus progressStatus;
                  while ((progressStatus = progressReader.next()) != null) {
                    progressMonitor.updateProgress(progressStatus);
                    if (progressStatus.getError() != null) {
                      throw new DockerException(progressStatus.getError(), 500);
                    }
                    String status = progressStatus.getStatus();
                    // Here we find string with digest which has following format:
                    // <tag>: digest: <digest> size: <size>
                    // for example:
                    // latest: digest: sha256:9a70e6222ded459fde37c56af23887467c512628eb8e78c901f3390e49a800a0 size: 62189
                    if (status != null && status.startsWith(digestPrefix)) {
                      return status.substring(
                          digestPrefix.length(), status.indexOf(" ", digestPrefix.length()));
                    }
                  }

                  LOG.error(
                      "Docker image {}:{} was successfully pushed, but its digest wasn't obtained",
                      fullRepo,
                      firstNonNull(params.getTag(), "latest"));
                  throw new DockerException(
                      "Docker push response doesn't contain image digest", 500);
                });

        return digestFuture.get();
      } catch (ExecutionException e) {
        // unwrap exception thrown by task with .getCause()
        throw new DockerException(
            "Docker image pushing failed. Cause: " + e.getCause().getLocalizedMessage(), 500);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new DockerException("Docker image pushing was interrupted", 500);
      }
    }
  }

