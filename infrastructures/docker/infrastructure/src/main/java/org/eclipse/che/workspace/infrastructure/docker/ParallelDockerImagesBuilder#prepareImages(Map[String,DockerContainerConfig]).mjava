  /**
   * Schedule parallel preparation of docker images for the set of docker containers.
   *
   * @param containers map of machine name and it's container config
   * @return map of machine names and theirs image names.
   * @throws InterruptedException if process is interrupted
   * @throws InfrastructureException if build failed
   */
  public Map<String, String> prepareImages(Map<String, DockerContainerConfig> containers)
      throws InterruptedException, InfrastructureException {
    if (executor.getActiveCount() + containers.size() > executor.getMaximumPoolSize()) {
      LOG.warn(
          String.format(
              "Maximum parallel images preparing threads reached. Some images will be queued.\n"
                  + " Workspace machines count is %s. If problem persists, increase %s property value.",
              containers.size(), PARALLEL_PULL_PROPERTY_NAME));
    }
    Map<String, String> machineToImageNames = new ConcurrentHashMap<>(containers.size());
    CompletableFuture<Void> firstFailed = new CompletableFuture<>();
    List<CompletableFuture<Void>> taskFutures =
        containers
            .entrySet()
            .stream()
            .map(
                e ->
                    CompletableFuture.runAsync(
                        () -> {
                          try {
                            machineToImageNames.put(
                                e.getKey(), prepareImage(e.getKey(), e.getValue()));
                          } catch (InternalInfrastructureException | SourceNotFoundException ex) {
                            firstFailed.completeExceptionally(ex);
                          }
                        },
                        executor))
            .collect(toList());

    CompletableFuture all =
        CompletableFuture.allOf(taskFutures.toArray(new CompletableFuture[taskFutures.size()]));
    try {
      CompletableFuture.anyOf(all, firstFailed).get();
    } catch (ExecutionException e) {
      try {
        throw e.getCause();
      } catch (InfrastructureException rethrow) {
        throw rethrow;
      } catch (Throwable thr) {
        throw new InternalInfrastructureException("Unable to build or pull image", thr);
      }
    }
    return machineToImageNames;
  }

