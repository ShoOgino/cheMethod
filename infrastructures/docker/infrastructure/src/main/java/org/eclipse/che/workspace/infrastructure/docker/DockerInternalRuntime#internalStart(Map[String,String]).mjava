  @Override
  protected void internalStart(Map<String, String> startOptions) throws InfrastructureException {
    startSynchronizer.setStartThread();
    try {
      networks.createNetwork(getContext().getEnvironment().getNetwork());

      for (Map.Entry<String, DockerContainerConfig> containerEntry :
          getContext().getEnvironment().getContainers().entrySet()) {
        checkInterruption();
        String machineName = containerEntry.getKey();
        final DockerContainerConfig config = containerEntry.getValue();
        sendStartingEvent(machineName);
        try {
          startMachine(machineName, config);
          sendRunningEvent(machineName);
        } catch (InfrastructureException e) {
          sendFailedEvent(machineName, e.getMessage());
          throw e;
        }
      }
      startSynchronizer.complete();
    } catch (InfrastructureException | InterruptedException | RuntimeException e) {
      boolean interrupted = Thread.interrupted() || e instanceof InterruptedException;

      // Cancels workspace servers probes if any
      probeScheduler.cancel(getContext().getIdentity().getWorkspaceId());

      try {
        destroyRuntime(emptyMap());
      } catch (InternalInfrastructureException destExc) {
        LOG.error(destExc.getMessage(), destExc);
      } catch (InfrastructureException ignore) {
      }

      if (interrupted) {
        final RuntimeStartInterruptedException ex =
            new RuntimeStartInterruptedException(getContext().getIdentity());
        startSynchronizer.completeExceptionally(ex);
        throw ex;
      }
      startSynchronizer.completeExceptionally(e);
      try {
        throw e;
      } catch (InfrastructureException rethrow) {
        throw rethrow;
      } catch (Exception wrap) {
        throw new InternalInfrastructureException(e.getMessage(), wrap);
      }
    }
  }

