    @BeforeMethod
    public void setUp() throws Exception {

        WorkspaceHolder workspaceHolder = new TestWorkspaceHolder();

        File root = new File(FS_PATH);

        if (root.exists()) {
            IoUtil.deleteRecursive(root);
        }
        root.mkdir();


        File indexDir = new File(INDEX_PATH);

        if (indexDir.exists()) {
            IoUtil.deleteRecursive(indexDir);
        }
        indexDir.mkdir();

        Set<PathMatcher> filters = new HashSet<>();
        filters.add(path -> true);
        FSLuceneSearcherProvider sProvider = new FSLuceneSearcherProvider(indexDir, filters);

        vfsProvider = new LocalVirtualFileSystemProvider(root, sProvider);

        final EventService eventService = new EventService();

        // PTs for test
        ProjectTypeDef chuck = new ProjectTypeDef("chuck_project_type", "chuck_project_type", true, false) {
            {
                addConstantDefinition("x", "attr description", new AttributeValue(Arrays.asList("a", "b")));
            }
        };

        Set<ProjectTypeDef> projectTypes = new HashSet<>();
        final LocalProjectType myProjectType = new LocalProjectType("my_project_type", "my project type");
        projectTypes.add(myProjectType);
        projectTypes.add(new LocalProjectType("module_type", "module type"));
        projectTypes.add(chuck);

        ptRegistry = new ProjectTypeRegistry(projectTypes);

        phRegistry = new ProjectHandlerRegistry(new HashSet<>());

        importerRegistry = new ProjectImporterRegistry(Collections.<ProjectImporter>emptySet());

        projectRegistry = new ProjectRegistry(workspaceHolder, vfsProvider, ptRegistry, phRegistry, eventService);
        projectRegistry.initProjects();

        FileWatcherNotificationHandler fileWatcherNotificationHandler = new DefaultFileWatcherNotificationHandler(vfsProvider);
        FileTreeWatcher fileTreeWatcher = new FileTreeWatcher(root, new HashSet<>(), fileWatcherNotificationHandler);

        pm = new ProjectManager(vfsProvider, null, ptRegistry, projectRegistry, phRegistry,
                                importerRegistry, fileWatcherNotificationHandler, fileTreeWatcher);
        pm.initWatcher();

        HttpJsonRequest httpJsonRequest = mock(HttpJsonRequest.class, new SelfReturningAnswer());

        //List<ProjectConfigDto> modules = new ArrayList<>();

        final ProjectConfigDto testProjectConfigMock = mock(ProjectConfigDto.class);
        when(testProjectConfigMock.getPath()).thenReturn("/my_project");
        when(testProjectConfigMock.getName()).thenReturn("my_project");
        when(testProjectConfigMock.getDescription()).thenReturn("my test project");
        when(testProjectConfigMock.getType()).thenReturn("my_project_type");
//        when(testProjectConfigMock.getModules()).thenReturn(modules);
        when(testProjectConfigMock.getSource()).thenReturn(DtoFactory.getInstance().createDto(SourceStorageDto.class));
//        when(testProjectConfigMock.findModule(anyString())).thenReturn(testProjectConfigMock);

        Map<String, List<String>> attr = new HashMap<>();
        for (Attribute attribute : myProjectType.getAttributes()) {
            attr.put(attribute.getName(), attribute.getValue().getList());
        }
        when(testProjectConfigMock.getAttributes()).thenReturn(attr);

        projects = new ArrayList<>();
        projects.add(testProjectConfigMock);
        when(httpJsonRequestFactory.fromLink(any())).thenReturn(httpJsonRequest);
        when(httpJsonRequest.request()).thenReturn(httpJsonResponse);
        when(httpJsonResponse.asDto(WorkspaceDto.class)).thenReturn(usersWorkspaceMock);
        when(usersWorkspaceMock.getConfig()).thenReturn(workspaceConfigMock);
        when(workspaceConfigMock.getProjects()).thenReturn(projects);

        pm.createProject(testProjectConfigMock, null);

//        verify(httpJsonRequestFactory).fromLink(eq(DtoFactory.newDto(Link.class)
//                                                             .withHref(apiEndpoint + "/workspace/" + workspace + "/project")
//                                                             .withMethod(PUT)));

        DependencySupplierImpl dependencies = new DependencySupplierImpl();


        dependencies.addComponent(ProjectTypeRegistry.class, ptRegistry);
        dependencies.addComponent(UserDao.class, userDao);
        dependencies.addComponent(ProjectManager.class, pm);
        dependencies.addComponent(ProjectImporterRegistry.class, importerRegistry);
        dependencies.addComponent(ProjectHandlerRegistry.class, phRegistry);
//        dependencies.addComponent(SearcherProvider.class, new TestSercherProvider());
        dependencies.addComponent(EventService.class, eventService);

        ResourceBinder resources = new ResourceBinderImpl();
        ProviderBinder providers = new ApplicationProviderBinder();
        EverrestProcessor processor = new EverrestProcessor(resources, providers, dependencies, new EverrestConfiguration(), null);
        launcher = new ResourceLauncher(processor);

        processor.addApplication(new Application() {
            @Override
            public Set<Class<?>> getClasses() {
                return java.util.Collections.<Class<?>>singleton(ProjectService.class);
            }

            @Override
            public Set<Object> getSingletons() {
                return new HashSet<>(Arrays.asList(/*new CodenvyJsonProvider(singleton(ContentStream.class)),*/
                                                   /*new ContentStreamWriter(),*/
                                                   new ApiExceptionMapper()));
            }
        });

        ApplicationContextImpl.setCurrent(new ApplicationContextImpl(null, null, ProviderBinder.getInstance()));

        env = org.eclipse.che.commons.env.EnvironmentContext.getCurrent();
//        env.setUser(new UserImpl(vfsUser, vfsUser, "dummy_token", vfsUserGroups, false));
//        env.setWorkspaceName(workspace);
//        env.setWorkspaceId(workspace);
    }

