  private boolean tryAcquire(Path path, int permits) {
    //System.err.printf(">>>>> acquire: %s : %d%n", path, permits);
    Node node = tail.prev;
    final Thread current = Thread.currentThread();
    while (node != null) {
      if (node.path.equals(path)) {
        if (node.threadId == current.getId()) {
          // Current thread already has direct lock for this path
          if (node.threadDeep > MAX_RECURSIVE_LOCKS) {
            throw new Error("Max number of recursive locks exceeded. ");
          }
          ++node.threadDeep;
          return true;
        }
        if (node.permits > permits) {
          // Lock already exists and current thread is not owner of this lock,
          // but lock is not exclusive and we can "share" it for other thread.
          node.permits -= permits; // decrement number of allowed concurrent threads
          return true;
        }
        // Lock is exclusive or max number of allowed concurrent thread is reached.
        return false;
      } else if ((node.path.isChild(path) || path.isChild(node.path)) && node.permits <= permits) {
        // Found some path which already has lock that prevents us to get required permits.
        // There is two possibilities:
        // 1. Parent of the path we try to lock already locked
        // 2. Child of the path we try to lock already locked
        // Need to check is such lock obtained by current thread or not.
        // If such lock obtained by other thread stop here immediately there is no reasons to continue.
        if (node.threadId != current.getId()) {
          return false;
        }
      }
      node = node.prev;
    }
    // If we are here there is no lock for path yet.
    tail.prev = new Node(path, maxThreads - permits, tail.prev);
    return true;
  }

