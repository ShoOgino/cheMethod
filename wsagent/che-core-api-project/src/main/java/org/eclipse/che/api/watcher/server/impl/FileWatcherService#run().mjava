  private void run() {
    suspended.compareAndSet(true, false);
    running.compareAndSet(false, true);

    outer:
    while (running.get()) {
      try {
        WatchKey watchKey = service.take();
        Path dir;
        synchronized (keys) {
          dir = keys.get(watchKey);
        }

        if (dir == null) {
          resetAndRemove(watchKey, dir);

          LOG.debug("Reported directory is not registered - skipping.");
          continue;
        }

        List<WatchEvent<?>> watchEvents = watchKey.pollEvents();
        while (!watchEvents.isEmpty()) {
          if (suspended.get()) {
            resetAndRemove(watchKey, dir);

            LOG.debug("File watchers are running in suspended mode - skipping.");
            continue outer;
          }

          for (WatchEvent<?> event : watchEvents) {
            Kind<?> kind = event.kind();

            if (kind == OVERFLOW) {
              LOG.warn("Detected file system events overflowing");
              continue outer;
            }

            WatchEvent<Path> ev = cast(event);
            Path item = ev.context();
            Path path = dir.resolve(item).toAbsolutePath();

            if (excludePatternsRegistry.isExcluded(path)) {
              LOG.debug("Path is within exclude list, skipping...");
              continue;
            }

            handler.handle(path, kind);
          }

          watchEvents = watchKey.pollEvents();
        }

        resetAndRemove(watchKey, dir);
      } catch (InterruptedException e) {
        running.compareAndSet(true, false);
        LOG.debug(
            "Interruption error when running file watcher, most likely caused by stopping it", e);
      } catch (ClosedWatchServiceException e) {
        running.compareAndSet(true, false);
        LOG.debug("Closing watch service while some of keys may be processing", e);
      }
    }
  }

