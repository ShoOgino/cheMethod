  /**
   * initializes all the attributes defined in myType and its ancestors recursively
   *
   * @param myType
   * @param typeId temporary type for recursive (started with initial type)
   * @throws ProjectTypeConstraintException
   */
  private final void initRecursively(ProjectTypeDef myType, String typeId)
      throws ProjectTypeConstraintException {
    ProjectTypeDef type = validatedData.get(typeId);

    for (String superTypeId : type.getParents()) {
      myType.addAncestor(superTypeId);

      ProjectTypeDef supertype = validatedData.get(superTypeId);
      for (Attribute supertypeAttr : supertype.getAttributes()) {
        // check attribute names
        for (Attribute attr : myType.getAttributes()) {
          if (supertypeAttr.getName().equals(attr.getName())) {

            ProjectTypeDef attrOriginProjectType = validatedData.get(attr.getProjectType());
            // myType can't add attribute with the same name as one of its ancestors already has
            if (attrOriginProjectType.getId().equals(myType.id)
                // check whether the attribute isn't inherited from an ancestor PT
                || !attrOriginProjectType.isTypeOf(supertypeAttr.getProjectType())) {
              throw new ProjectTypeConstraintException(
                  "Attribute name conflict. Project type "
                      + myType.getId()
                      + " could not be registered as attribute declaration "
                      + attr.getName()
                      + " is duplicated in its ancestor(s).");
            }
          }
        }
        myType.addAttributeDefinition(supertypeAttr);
      }
      initRecursively(myType, superTypeId);
    }
  }

