  @Override
  public void importSources(
      FolderEntry baseFolder, SourceStorage storage, LineConsumerFactory consumerFactory)
      throws ForbiddenException, ConflictException, UnauthorizedException, IOException,
          ServerException {
    GitConnection git = null;
    boolean credentialsHaveBeenSet = false;
    try {
      // For factory: checkout particular commit after clone
      String commitId = null;
      // For factory: github pull request feature
      String fetch = null;
      String branch = null;
      String startPoint = null;
      // For factory or probably for our projects templates:
      // If git repository contains more than one project need clone all repository but after
      // cloning keep just
      // sub-project that is specified in parameter "keepDir".
      String keepDir = null;
      // For factory and for our projects templates:
      // Keep all info related to the vcs. In case of Git: ".git" directory and ".gitignore" file.
      // Delete vcs info if false.
      String branchMerge = null;
      boolean keepVcs = true;
      boolean recursiveEnabled = false;
      boolean convertToTopLevelProject = false;

      Map<String, String> parameters = storage.getParameters();
      if (parameters != null) {
        commitId = parameters.get("commitId");
        branch = parameters.get("branch");
        startPoint = parameters.get("startPoint");
        fetch = parameters.get("fetch");
        keepDir = parameters.get("keepDir");
        if (parameters.containsKey("keepVcs")) {
          keepVcs = Boolean.parseBoolean(parameters.get("keepVcs"));
        }
        if (parameters.containsKey("recursive")) {
          recursiveEnabled = true;
        }
        // convertToTopLevelProject feature is working only if we don't need any git information
        // and when we are working in git sparse checkout mode.
        if (!keepVcs
            && !isNullOrEmpty(keepDir)
            && parameters.containsKey("convertToTopLevelProject")) {
          convertToTopLevelProject =
              Boolean.parseBoolean(parameters.get("convertToTopLevelProject"));
        }
        branchMerge = parameters.get("branchMerge");
        final String user = storage.getParameters().remove("username");
        final String pass = storage.getParameters().remove("password");
        if (user != null && pass != null) {
          credentialsHaveBeenSet = true;
          setCurrentCredentials(user, pass);
        }
      }
      // Get path to local file. Git works with local filesystem only.
      final String localPath = baseFolder.getVirtualFile().toIoFile().getAbsolutePath();
      final String location = storage.getLocation();
      final String projectName = baseFolder.getName();

      // Converting steps
      // 1. Clone to temporary folder on same device with /projects
      // 2. Remove git information
      // 3. Move to path requested by user.
      // Very important to have initial clone folder on the same drive with /project
      // otherwise we will have to replace atomic move with copy-delete operation.
      if (convertToTopLevelProject) {
        File tempDir = new File(new File(localPath).getParent(), NameGenerator.generate(".che", 6));
        git = gitConnectionFactory.getConnection(tempDir, consumerFactory);
      } else {
        git = gitConnectionFactory.getConnection(localPath, consumerFactory);
      }

      if (keepDir != null) {
        git.cloneWithSparseCheckout(keepDir, location);
        if (branch != null) {
          git.checkout(CheckoutParams.create(branch));
        }
      } else {
        if (baseFolder.getChildren().size() == 0) {
          cloneRepository(git, "origin", location, recursiveEnabled);
          if (commitId != null) {
            checkoutCommit(git, commitId);
          } else if (fetch != null) {
            git.getConfig().add("remote.origin.fetch", fetch);
            fetch(git, "origin");
            if (branch != null) {
              checkoutBranch(git, projectName, branch, startPoint);
            }
          } else if (branch != null) {
            checkoutBranch(git, projectName, branch, startPoint);
          }
        } else {
          git.init(false);
          addRemote(git, "origin", location);
          if (commitId != null) {
            fetchBranch(git, "origin", branch == null ? "*" : branch);
            checkoutCommit(git, commitId);
          } else if (fetch != null) {
            git.getConfig().add("remote.origin.fetch", fetch);
            fetch(git, "origin");
            if (branch != null) {
              checkoutBranch(git, projectName, branch, startPoint);
            }
          } else {
            fetchBranch(git, "origin", branch == null ? "*" : branch);

            List<Branch> branchList = git.branchList(LIST_REMOTE);
            if (!branchList.isEmpty()) {
              checkoutBranch(git, projectName, branch == null ? "master" : branch, startPoint);
            }
          }
        }
        if (branchMerge != null) {
          git.getConfig()
              .set("branch." + (branch == null ? "master" : branch) + ".merge", branchMerge);
        }
      }
      if (!keepVcs) {
        cleanGit(git.getWorkingDir());
      }
      if (convertToTopLevelProject) {
        Files.move(
            new File(git.getWorkingDir(), keepDir).toPath(),
            new File(localPath).toPath(),
            StandardCopyOption.ATOMIC_MOVE);
        IoUtil.deleteRecursive(git.getWorkingDir());
      }

    } catch (URISyntaxException e) {
      throw new ServerException(
          "Your project cannot be imported. The issue is either from git configuration, a malformed URL, "
              + "or file system corruption. Please contact support for assistance.",
          e);
    } finally {
      if (git != null) {
        git.close();
      }
      if (credentialsHaveBeenSet) {
        clearCredentials();
      }
    }
  }

