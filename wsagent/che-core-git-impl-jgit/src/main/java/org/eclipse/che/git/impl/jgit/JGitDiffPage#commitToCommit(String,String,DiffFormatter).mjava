    /**
     * Show changes between specified two revisions and index. If
     * <code>commitAId == null</code> then view changes between HEAD and revision commitBId.
     *
     * @param commitAId
     *            id of commit A, pass <code>null</code> is the same as pass HEAD
     * @param commitBId
     *            id of commit B
     * @param formatter
     *            diff formatter
     * @return list of diff entries
     * @throws IOException
     *             if any i/o errors occurs
     */
    private List<DiffEntry> commitToCommit(String commitAId, String commitBId, DiffFormatter formatter) throws IOException {
        if (commitAId == null) {
            commitAId = Constants.HEAD;
        }

        ObjectId commitA = repository.resolve(commitAId);
        if (commitA == null) {
            throw new IllegalArgumentException("Invalid commit id " + commitAId);
        }
        ObjectId commitB = repository.resolve(commitBId);
        if (commitB == null) {
            throw new IllegalArgumentException("Invalid commit id " + commitBId);
        }

        RevTree treeA;
        try (RevWalk revWalkA = new RevWalk(repository)) {
            treeA = revWalkA.parseTree(commitA);
        }

        RevTree treeB;
        try (RevWalk revWalkB = new RevWalk(repository)) {
            treeB = revWalkB.parseTree(commitB);
        }

        if (!request.isNoRenames()) {
            // Use embedded RenameDetector it works well with index and revision
            // history.
            formatter.setDetectRenames(true);
            int renameLimit = request.getRenameLimit();
            if (renameLimit > 0) {
                formatter.getRenameDetector().setRenameLimit(renameLimit);
            }
        }
        return formatter.scan(treeA, treeB);
    }

