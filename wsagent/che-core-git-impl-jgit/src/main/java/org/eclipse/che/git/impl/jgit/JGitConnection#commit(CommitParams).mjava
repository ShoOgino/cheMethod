  @Override
  public Revision commit(CommitParams params) throws GitException {
    try {
      // Check repository state
      RepositoryState repositoryState = repository.getRepositoryState();
      if (!repositoryState.canCommit()) {
        throw new GitException(
            format(MESSAGE_COMMIT_NOT_POSSIBLE, repositoryState.getDescription()));
      }
      if (params.isAmend() && !repositoryState.canAmend()) {
        throw new GitException(
            format(MESSAGE_COMMIT_AMEND_NOT_POSSIBLE, repositoryState.getDescription()));
      }

      // Check committer
      GitUser committer = getUser();
      if (committer == null) {
        throw new GitException("Committer can't be null");
      }
      String committerName = committer.getName();
      String committerEmail = committer.getEmail();
      if (committerName == null || committerEmail == null) {
        throw new GitException(
            "Git user name and (or) email wasn't set",
            ErrorCodes.NO_COMMITTER_NAME_OR_EMAIL_DEFINED);
      }

      // Check commit message
      String message = params.getMessage();
      if (message == null) {
        throw new GitException("Message wasn't set");
      }

      List<String> files = params.getFiles();
      Status status = status(files);
      List<String> specified = files;

      List<String> staged = new ArrayList<>();
      staged.addAll(status.getAdded());
      staged.addAll(status.getChanged());
      staged.addAll(status.getRemoved());

      List<String> changed = new ArrayList<>(staged);
      changed.addAll(status.getModified());
      changed.addAll(status.getMissing());

      List<String> specifiedStaged =
          specified
              .stream()
              .filter(path -> staged.stream().anyMatch(s -> s.startsWith(path)))
              .collect(toList());

      List<String> specifiedChanged =
          specified
              .stream()
              .filter(path -> changed.stream().anyMatch(c -> c.startsWith(path)))
              .collect(toList());

      // Check that there are changes present for commit, if 'isAmend' is disabled
      if (!params.isAmend()) {
        // Check that there are staged changes present for commit, or any changes if 'isAll' is
        // enabled
        if (status.isClean()) {
          throw new GitException("Nothing to commit, working directory clean");
        } else if (!params.isAll()
            && (specified.isEmpty() ? staged.isEmpty() : specifiedStaged.isEmpty())) {
          throw new GitException("No changes added to commit");
        }
      } else {
        /*
        By default Jgit doesn't allow to commit not changed specified paths. According to setAllowEmpty method documentation,
        setting this flag to true must allow such commit, but it won't because Jgit has a bug:
        https://bugs.eclipse.org/bugs/show_bug.cgi?id=510685. As a workaround, specified paths of the commit command will contain
        only changed and specified paths. If other changes are present, but the list of changed and specified paths is empty,
        throw exception to prevent committing other paths. TODO Remove this check when the bug will be fixed.
        */
        if (!specified.isEmpty()
            && !(params.isAll() ? changed.isEmpty() : staged.isEmpty())
            && specifiedChanged.isEmpty()) {
          throw new GitException(
              format(
                  "Changes are present but not changed path%s specified for commit.",
                  specified.size() > 1 ? "s were" : " was"));
        }
      }

      // TODO add 'setAllowEmpty(params.isAmend())' when
      // https://bugs.eclipse.org/bugs/show_bug.cgi?id=510685 will be fixed
      CommitCommand commitCommand =
          getGit()
              .commit()
              .setCommitter(committerName, committerEmail)
              .setAuthor(committerName, committerEmail)
              .setMessage(message)
              .setAll(params.isAll())
              .setAmend(params.isAmend());

      if (!params.isAll()) {
        // TODO change to 'specified.forEach(commitCommand::setOnly)' when
        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=510685 will be fixed. See description
        // above.
        specifiedChanged.forEach(commitCommand::setOnly);
      }

      // Check if repository is configured with Gerrit Support
      String gerritSupportConfigValue =
          repository
              .getConfig()
              .getString(
                  ConfigConstants.CONFIG_GERRIT_SECTION,
                  null,
                  ConfigConstants.CONFIG_KEY_CREATECHANGEID);
      boolean isGerritSupportConfigured =
          gerritSupportConfigValue != null ? Boolean.valueOf(gerritSupportConfigValue) : false;
      commitCommand.setInsertChangeId(isGerritSupportConfigured);
      String repositoryPath = getRepository().getDirectory().getPath();
      COMMITTING_REPOSITORIES.add(repositoryPath);
      RevCommit result = commitCommand.call();
      COMMITTING_REPOSITORIES.remove(repositoryPath);

      status = status(emptyList());
      Map<String, List<EditedRegion>> modifiedFiles = new HashMap<>();
      for (String file : status.getChanged()) {
        modifiedFiles.put(file, getEditedRegions(file));
      }
      // Need to fire this event because with the help of the file watchers we can not detect JGit's
      // commit operation completion.
      eventService.publish(
          newDto(StatusChangedEventDto.class)
              .withStatus(status)
              .withModifiedFiles(modifiedFiles)
              .withProjectName(repository.getWorkTree().getName()));

      GitUser gitUser = newDto(GitUser.class).withName(committerName).withEmail(committerEmail);

      return newDto(Revision.class)
          .withBranch(getCurrentReference().getName())
          .withId(result.getId().getName())
          .withMessage(result.getFullMessage())
          .withCommitTime(MILLISECONDS.convert(result.getCommitTime(), SECONDS))
          .withCommitter(gitUser);
    } catch (GitAPIException exception) {
      throw new GitException(exception.getMessage(), exception);
    } finally {
      COMMITTING_REPOSITORIES.remove(getRepository().getDirectory().getPath());
    }
  }

