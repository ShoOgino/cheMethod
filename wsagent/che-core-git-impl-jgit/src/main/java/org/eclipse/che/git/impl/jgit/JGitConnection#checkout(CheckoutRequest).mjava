    @Override
    public void checkout(CheckoutRequest request) throws GitException {
        CheckoutCommand checkoutCommand = getGit().checkout();
        String startPoint = request.getStartPoint();
        String name = request.getName();
        String trackBranch = request.getTrackBranch();

        // checkout files?
        List<String> files = request.getFiles();
        boolean shouldCheckoutToFile = name != null && new File(getWorkingDir(), name).exists();
        if (shouldCheckoutToFile || !files.isEmpty()) {
            if (shouldCheckoutToFile) {
                checkoutCommand.addPath(request.getName());
            } else {
                files.forEach(checkoutCommand::addPath);
            }
        } else {
            // checkout branch
            if (startPoint != null && trackBranch != null) {
                throw new GitException("Start point and track branch can not be used together.");
            }
            if (request.isCreateNew() && name == null) {
                throw new GitException("Branch name must be set when createNew equals to true.");
            }
            if (startPoint != null) {
                checkoutCommand.setStartPoint(startPoint);
            }
            if (request.isCreateNew()) {
                checkoutCommand.setCreateBranch(true);
                checkoutCommand.setName(name);
            } else if (name != null) {
                checkoutCommand.setName(name);
                List<String> localBranches =
                        branchList(newDto(BranchListRequest.class).withListMode(BranchListRequest.LIST_LOCAL)).stream()
                                                                                                              .map(Branch::getDisplayName)
                                                                                                              .collect(Collectors.toList());
                if (!localBranches.contains(name)) {
                    Optional<Branch> remoteBranch = branchList(newDto(BranchListRequest.class).withListMode(BranchListRequest.LIST_REMOTE))
                            .stream()
                            .filter(branch -> branch.getName().contains(name))
                            .findFirst();
                    if (remoteBranch.isPresent()) {
                        checkoutCommand.setCreateBranch(true);
                        checkoutCommand.setStartPoint(remoteBranch.get().getName());
                    }
                }
            }
            if (trackBranch != null) {
                if (name == null) {
                    checkoutCommand.setName(cleanRemoteName(trackBranch));
                }
                checkoutCommand.setCreateBranch(true);
                checkoutCommand.setStartPoint(trackBranch);
            }
            checkoutCommand.setUpstreamMode(SetupUpstreamMode.SET_UPSTREAM);
        }
        try {
            checkoutCommand.call();
        } catch (GitAPIException exception) {
            if (exception.getMessage().endsWith("already exists")) {
                throw new GitException(String.format(ERROR_BRANCH_NAME_EXISTS, name != null ? name : cleanRemoteName(trackBranch)));
            }
            throw new GitException(exception.getMessage(), exception);
        }
    }

