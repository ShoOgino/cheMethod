  @Override
  public List<Branch> branchList(BranchListMode listMode) throws GitException {
    ListBranchCommand listBranchCommand = getGit().branchList();
    if (LIST_ALL == listMode || listMode == null) {
      listBranchCommand.setListMode(ListMode.ALL);
    } else if (LIST_REMOTE == listMode) {
      listBranchCommand.setListMode(ListMode.REMOTE);
    }
    List<Ref> refs;
    String currentRef;
    try {
      refs = listBranchCommand.call();
      String headBranch = getRepository().getBranch();
      Optional<Ref> currentTag =
          getGit()
              .tagList()
              .call()
              .stream()
              .filter(tag -> tag.getObjectId().getName().equals(headBranch))
              .findFirst();
      if (currentTag.isPresent()) {
        currentRef = currentTag.get().getName();
      } else {
        currentRef = "refs/heads/" + headBranch;
      }

    } catch (GitAPIException | IOException exception) {
      throw new GitException(exception.getMessage(), exception);
    }
    List<Branch> branches = new ArrayList<>();
    for (Ref ref : refs) {
      String refName = ref.getName();
      boolean isCommitOrTag = Constants.HEAD.equals(refName);
      String branchName = isCommitOrTag ? currentRef : refName;
      String branchDisplayName;
      if (isCommitOrTag) {
        branchDisplayName = "(detached from " + Repository.shortenRefName(currentRef) + ")";
      } else {
        branchDisplayName = Repository.shortenRefName(refName);
      }
      Branch branch =
          newDto(Branch.class)
              .withName(branchName)
              .withActive(isCommitOrTag || refName.equals(currentRef))
              .withDisplayName(branchDisplayName)
              .withRemote(refName.startsWith("refs/remotes"));
      branches.add(branch);
    }
    return branches;
  }

