  @Override
  public RebaseResponse rebase(String operation, String branch) throws GitException {
    RebaseResult result;
    RebaseStatus status;
    List<String> failed;
    List<String> conflicts;
    try {
      RebaseCommand rebaseCommand = getGit().rebase();
      setRebaseOperation(rebaseCommand, operation);
      if (branch != null && !branch.isEmpty()) {
        rebaseCommand.setUpstream(branch);
      }
      result = rebaseCommand.call();
    } catch (GitAPIException exception) {
      throw new GitException(exception.getMessage(), exception);
    }
    switch (result.getStatus()) {
      case ABORTED:
        status = RebaseStatus.ABORTED;
        break;
      case CONFLICTS:
        status = RebaseStatus.CONFLICTING;
        break;
      case UP_TO_DATE:
        status = RebaseStatus.ALREADY_UP_TO_DATE;
        break;
      case FAST_FORWARD:
        status = RebaseStatus.FAST_FORWARD;
        break;
      case NOTHING_TO_COMMIT:
        status = RebaseStatus.NOTHING_TO_COMMIT;
        break;
      case OK:
        status = RebaseStatus.OK;
        break;
      case STOPPED:
        status = RebaseStatus.STOPPED;
        break;
      case UNCOMMITTED_CHANGES:
        status = RebaseStatus.UNCOMMITTED_CHANGES;
        break;
      case EDIT:
        status = RebaseStatus.EDITED;
        break;
      case INTERACTIVE_PREPARED:
        status = RebaseStatus.INTERACTIVE_PREPARED;
        break;
      case STASH_APPLY_CONFLICTS:
        status = RebaseStatus.STASH_APPLY_CONFLICTS;
        break;
      default:
        status = RebaseStatus.FAILED;
    }
    conflicts = result.getConflicts() != null ? result.getConflicts() : emptyList();
    failed =
        result.getFailingPaths() != null
            ? new ArrayList<>(result.getFailingPaths().keySet())
            : emptyList();
    return newDto(RebaseResponse.class)
        .withStatus(status)
        .withConflicts(conflicts)
        .withFailed(failed);
  }

