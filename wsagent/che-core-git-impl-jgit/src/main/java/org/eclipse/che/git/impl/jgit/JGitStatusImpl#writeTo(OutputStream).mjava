  @Override
  public void writeTo(OutputStream out) throws IOException {
    StringBuilder status = new StringBuilder();

    status
        .append(reference.getType() == BRANCH ? "On branch " : "HEAD detached at ")
        .append(
            reference.getType() == COMMIT
                ? reference.getName().substring(0, 8)
                : reference.getName())
        .append(lineSeparator());
    if (isClean()) {
      status.append(lineSeparator()).append("nothing to commit, working directory clean");
    } else {
      if (!added.isEmpty() || !changed.isEmpty() || !removed.isEmpty()) {
        status.append(lineSeparator()).append("Changes to be committed:").append(lineSeparator());
        added.forEach(file -> status.append(lineSeparator()).append("\tnew file:   ").append(file));
        changed.forEach(
            file -> status.append(lineSeparator()).append("\tmodified:   ").append(file));
        removed.forEach(
            file -> status.append(lineSeparator()).append("\tdeleted:    ").append(file));
        status.append(lineSeparator());
      }
      if (!untracked.isEmpty() || !modified.isEmpty() || !missing.isEmpty()) {
        status
            .append(lineSeparator())
            .append("Changes not staged for commit:")
            .append(lineSeparator());
        untracked.forEach(
            file -> status.append(lineSeparator()).append("\tnew file:   ").append(file));
        modified.forEach(
            file -> status.append(lineSeparator()).append("\tmodified:   ").append(file));
        missing.forEach(
            file -> status.append(lineSeparator()).append("\tdeleted:    ").append(file));
        status.append(lineSeparator());
      }
      if (!conflicting.isEmpty()) {
        status.append(lineSeparator()).append("Unmerged paths:").append(lineSeparator());
        conflicting.forEach(
            file -> status.append(lineSeparator()).append("\tboth modified:   ").append(file));
      }
    }

    out.write(status.toString().getBytes());
  }

