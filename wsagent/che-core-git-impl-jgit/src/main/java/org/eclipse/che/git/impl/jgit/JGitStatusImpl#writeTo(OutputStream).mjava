    @Override
    public void writeTo(OutputStream out) throws IOException {
        StringBuilder status = new StringBuilder();

        status.append("On branch ").append(branchName).append(lineSeparator());
        if (isClean()) {
            status.append(lineSeparator()).append("nothing to commit, working directory clean");
        } else {
            if (!added.isEmpty() || !changed.isEmpty() || !removed.isEmpty()) {
                status.append(lineSeparator()).append("Changes to be committed:").append(lineSeparator());
                added.forEach(file -> status.append(lineSeparator()).append("\tnew file:   ").append(file));
                changed.forEach(file -> status.append(lineSeparator()).append("\tmodified:   ").append(file));
                removed.forEach(file -> status.append(lineSeparator()).append("\tdeleted:    ").append(file));
                status.append(lineSeparator());
            }
            if (!untracked.isEmpty() || !modified.isEmpty() || !missing.isEmpty()) {
                status.append(lineSeparator()).append("Changes not staged for commit:").append(lineSeparator());
                untracked.forEach(file -> status.append(lineSeparator()).append("\tnew file:   ").append(file));
                modified.forEach(file -> status.append(lineSeparator()).append("\tmodified:   ").append(file));
                missing.forEach(file -> status.append(lineSeparator()).append("\tdeleted:    ").append(file));
                status.append(lineSeparator());
            }
            if (!conflicting.isEmpty()) {
                status.append(lineSeparator()).append("Unmerged paths:").append(lineSeparator());
                conflicting.forEach(file -> status.append(lineSeparator()).append("\tboth modified:   ").append(file));
            }
        }

        out.write(status.toString().getBytes());
    }

