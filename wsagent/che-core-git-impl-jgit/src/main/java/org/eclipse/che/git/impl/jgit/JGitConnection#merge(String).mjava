  @Override
  public MergeResult merge(String commit) throws GitException {
    org.eclipse.jgit.api.MergeResult jGitMergeResult;
    MergeResult.MergeStatus status;
    try {
      Ref ref = repository.findRef(commit);
      if (ref == null) {
        throw new GitException("Invalid reference to commit for merge " + commit);
      }
      // Shorten local branch names by removing '/refs/heads/' from the beginning
      String name = ref.getName();
      if (name.startsWith(R_HEADS)) {
        name = name.substring(R_HEADS.length());
      }
      jGitMergeResult = getGit().merge().include(name, ref.getObjectId()).call();
    } catch (CheckoutConflictException exception) {
      jGitMergeResult = new org.eclipse.jgit.api.MergeResult(exception.getConflictingPaths());
    } catch (IOException | GitAPIException exception) {
      throw new GitException(exception.getMessage(), exception);
    }

    switch (jGitMergeResult.getMergeStatus()) {
      case ALREADY_UP_TO_DATE:
        status = MergeResult.MergeStatus.ALREADY_UP_TO_DATE;
        break;
      case CONFLICTING:
        status = MergeResult.MergeStatus.CONFLICTING;
        break;
      case FAILED:
        status = MergeResult.MergeStatus.FAILED;
        break;
      case FAST_FORWARD:
        status = MergeResult.MergeStatus.FAST_FORWARD;
        break;
      case MERGED:
        status = MergeResult.MergeStatus.MERGED;
        break;
      case NOT_SUPPORTED:
        status = MergeResult.MergeStatus.NOT_SUPPORTED;
        break;
      case CHECKOUT_CONFLICT:
        status = MergeResult.MergeStatus.CONFLICTING;
        break;
      default:
        throw new IllegalStateException("Unknown merge status " + jGitMergeResult.getMergeStatus());
    }

    ObjectId[] jGitMergedCommits = jGitMergeResult.getMergedCommits();
    List<String> mergedCommits = new ArrayList<>();
    if (jGitMergedCommits != null) {
      for (ObjectId jGitMergedCommit : jGitMergedCommits) {
        mergedCommits.add(jGitMergedCommit.getName());
      }
    }

    List<String> conflicts;
    if (org.eclipse.jgit.api.MergeResult.MergeStatus.CHECKOUT_CONFLICT.equals(
        jGitMergeResult.getMergeStatus())) {
      conflicts = jGitMergeResult.getCheckoutConflicts();
    } else {
      Map<String, int[][]> jGitConflicts = jGitMergeResult.getConflicts();
      conflicts = jGitConflicts != null ? new ArrayList<>(jGitConflicts.keySet()) : emptyList();
    }

    Map<String, ResolveMerger.MergeFailureReason> jGitFailing = jGitMergeResult.getFailingPaths();
    ObjectId newHead = jGitMergeResult.getNewHead();

    return newDto(MergeResult.class)
        .withFailed(jGitFailing != null ? new ArrayList<>(jGitFailing.keySet()) : emptyList())
        .withNewHead(newHead != null ? newHead.getName() : null)
        .withMergeStatus(status)
        .withConflicts(conflicts)
        .withMergedCommits(mergedCommits);
  }

