  @Override
  public void checkout(CheckoutParams params) throws GitException {
    CheckoutCommand checkoutCommand = getGit().checkout();
    String startPoint = params.getStartPoint();
    String name = params.getName();
    String trackBranch = params.getTrackBranch();

    // checkout files?
    List<String> files = params.getFiles();
    boolean shouldCheckoutToFile = name != null && new File(getWorkingDir(), name).exists();
    if (shouldCheckoutToFile || !files.isEmpty()) {
      if (shouldCheckoutToFile) {
        checkoutCommand.addPath(params.getName());
      } else {
        files.forEach(checkoutCommand::addPath);
      }
    } else {
      // checkout branch
      if (startPoint != null && trackBranch != null) {
        throw new GitException("Start point and track branch can not be used together.");
      }
      if (params.isCreateNew() && name == null) {
        throw new GitException("Branch name must be set when createNew equals to true.");
      }
      if (startPoint != null) {
        checkoutCommand.setStartPoint(startPoint);
      }
      if (params.isCreateNew()) {
        checkoutCommand.setCreateBranch(true);
        checkoutCommand.setName(name);
      } else if (name != null) {
        checkoutCommand.setName(name);
        List<String> localBranches =
            branchList(LIST_LOCAL)
                .stream()
                .map(Branch::getDisplayName)
                .collect(Collectors.toList());
        if (!localBranches.contains(name)) {
          List<Branch> remoteBranchesWithGivenName =
              branchList(LIST_REMOTE)
                  .stream()
                  .filter(
                      branch -> {
                        String branchName = branch.getName();
                        return name.equals(branchName.substring(branchName.lastIndexOf("/") + 1));
                      })
                  .collect(Collectors.toList());
          if (remoteBranchesWithGivenName.size() > 1) {
            throw new GitException(
                String.format(ERROR_CHECKOUT_BRANCH_NAME_EXISTS_IN_SEVERAL_REMOTES, name));
          } else if (remoteBranchesWithGivenName.size() == 1) {
            checkoutCommand.setCreateBranch(true);
            checkoutCommand.setStartPoint(remoteBranchesWithGivenName.get(0).getName());
          }
        }
      }
      if (trackBranch != null) {
        if (name == null) {
          checkoutCommand.setName(cleanRemoteName(trackBranch));
        }
        checkoutCommand.setCreateBranch(true);
        checkoutCommand.setStartPoint(trackBranch);
      }
      checkoutCommand.setUpstreamMode(SetupUpstreamMode.SET_UPSTREAM);
    }
    try {
      checkoutCommand.call();
    } catch (CheckoutConflictException exception) {
      throw new GitConflictException(exception.getMessage(), exception.getConflictingPaths());
    } catch (RefAlreadyExistsException exception) {
      throw new GitRefAlreadyExistsException(exception.getMessage());
    } catch (RefNotFoundException exception) {
      throw new GitRefNotFoundException(exception.getMessage());
    } catch (InvalidRefNameException exception) {
      throw new GitInvalidRefNameException(exception.getMessage());
    } catch (GitAPIException exception) {
      if (exception.getMessage().endsWith("already exists")) {
        throw new GitException(
            format(
                ERROR_CHECKOUT_BRANCH_NAME_EXISTS,
                name != null ? name : cleanRemoteName(trackBranch)));
      }
      throw new GitException(exception.getMessage(), exception);
    }
  }

