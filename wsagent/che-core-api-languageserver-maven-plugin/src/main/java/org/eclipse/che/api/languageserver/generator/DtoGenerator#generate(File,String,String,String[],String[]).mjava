  /**
   * Generate dto classes.
   *
   * @param targetFolder the base folder to generate code to. This is the package folder root.
   * @param targetName the simple class name to use for the generated class
   * @param targetPackage the package name to use for the generated class
   * @param sourcePackages the source packages to use. THe packages must be on the class path at
   *     execution time.
   * @throws IOException
   */
  public void generate(
      File targetFolder,
      String targetName,
      String targetPackage,
      String[] sourcePackages,
      String[] classNames)
      throws IOException {
    File targetFile =
        new File(
            targetFolder,
            targetPackage.replace('.', File.separatorChar)
                + File.separatorChar
                + targetName
                + ".java");
    targetFile.getParentFile().mkdirs();
    Set<URL> urls = new HashSet<>();
    for (String pkg : sourcePackages) {
      urls.addAll(ClasspathHelper.forPackage(pkg));
    }
    Reflections reflection =
        new Reflections(
            new ConfigurationBuilder()
                .setUrls(urls)
                .setScanners(new SubTypesScanner(false))
                .filterInputsBy(
                    new Predicate<String>() {

                      @Override
                      public boolean apply(String input) {
                        for (String pkg : sourcePackages) {
                          if (input.startsWith(pkg)) {
                            return input.indexOf('.', pkg.length() + 1) == input.lastIndexOf('.');
                          }
                        }
                        return false;
                      }
                    }));
    Set<Class<?>> allTypes = reflection.getSubTypesOf(Object.class);
    for (String className : classNames) {
      try {
        allTypes.add(Class.forName(className));
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      }
    }

    allTypes = allTypes.stream().filter((cls) -> !cls.isInterface()).collect(Collectors.toSet());

    try (PrintWriter out = new PrintWriter(targetFile, "utf-8")) {

      out.print("package ");
      out.print(targetPackage);
      out.println(";");

      writeEnvImports(out);

      json.writeImports(out);

      out.println("import java.util.Map.Entry;");
      out.println("import java.util.ArrayList;");
      out.println("import java.util.HashMap;");
      out.println("import org.eclipse.lsp4j.jsonrpc.messages.Either;");
      out.println("import org.eclipse.che.api.languageserver.util.EitherUtil;");
      out.println("import org.eclipse.che.api.languageserver.util.JsonUtil;");
      out.println("import org.eclipse.che.api.languageserver.shared.util.JsonDecision;");

      for (Class<? extends Object> clazz : allTypes) {
        out.print("import ");
        out.print(clazz.getCanonicalName());
        out.println(";");
      }

      out.println();
      writeEnvClassAnnotations(out);

      out.println(String.format("public class %1$s implements DtoFactoryVisitor {", targetName));

      for (Class<? extends Object> clazz : allTypes) {
        writeDTOClass(INDENT, out, clazz, allTypes);
        out.println();
        writeDTOProvider(INDENT, out, clazz);
        out.println();
      }

      out.println(INDENT + "public void accept(DtoFactory dtoFactory) {");
      for (Class<? extends Object> clazz : allTypes) {
        out.println(
            INDENT
                + INDENT
                + String.format(
                    "dtoFactory.registerProvider(%1$s.class, new %2$s());",
                    clazz.getSimpleName(), dtoProviderName(clazz)));
      }
      out.println(INDENT + "}");

      ToDtoGenerator.generateMakeDto(INDENT, out, allTypes);

      out.println("}");
      out.flush();
    }
  }

