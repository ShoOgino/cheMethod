    /**
     * Executes the given operation in parallel for each element in the
     * collection. Failures in any of the operations are ignored.
     * 
     * @param collection
     * @param op
     * @param timeoutMillis
     */
    public static <C, R> void doInParallel(Collection<C> collection, LSOperation<C, R> op, long timeoutMillis) {
        Object lock = new Object();
        List<CompletableFuture<?>> pendingResponses = new ArrayList<>();

        for (C element : collection) {
            if (op.canDo(element)) {
                CompletableFuture<R> future = op.start(element);
                synchronized (lock) {
                    pendingResponses.add(future);
                    lock.notifyAll();
                }
                future.thenAccept(result -> {
                    synchronized (lock) {
                        if (!future.isCancelled()) {
                            op.handleResult(element, result);
                            pendingResponses.remove(future);
                            lock.notifyAll();
                        }
                    }
                }).exceptionally((t) -> {
                    LOG.info("Exception occurred in request", t);
                    synchronized (lock) {
                        pendingResponses.remove(future);
                        lock.notifyAll();
                    }
                    return null;
                });
            }
        }

        long endTime = System.currentTimeMillis() + 5000;

        try {
            synchronized (lock) {
                while (System.currentTimeMillis() < endTime && pendingResponses.size() > 0) {
                    lock.wait(endTime - System.currentTimeMillis());
                }
            }
        } catch (InterruptedException e) {
            LOG.info("Thread interrupted", e);
            Thread.currentThread().interrupt();
        }
        synchronized (lock) {
            for (CompletableFuture<?> pending : new ArrayList<>(pendingResponses)) {
                pending.cancel(true);
            }
            lock.notifyAll();
        }
    }

