  @BeforeMethod
  public void setUp() throws Exception {
    this.serverCapabilities = new ServerCapabilities();
    serverDescription =
        new LanguageServerDescription(
            "foo", Collections.singletonList("id"), Collections.emptyList());
    initializeResult = new InitializeResult(serverCapabilities);

    completableFuture = CompletableFuture.completedFuture(initializeResult);

    when(languageServerLauncher.isAbleToLaunch()).thenReturn(true);
    when(languageServerLauncher.getDescription()).thenReturn(serverDescription);
    when(languageDescription.getLanguageId()).thenReturn("id");
    when(languageDescription.getFileExtensions()).thenReturn(Collections.singletonList("txt"));
    when(languageDescription.getMimeType()).thenReturn("plain/text");

    when(languageServer.getTextDocumentService()).thenReturn(mock(TextDocumentService.class));
    when(languageServer.initialize(any(InitializeParams.class))).thenReturn(completableFuture);

    when(pmp.get()).thenReturn(pm);
    when(projectsRoot.getPath()).thenReturn(Path.of(PROJECTS_ROOT));
    when(pm.getProjectsRoot()).thenReturn(projectsRoot);

    when(clientFactory.create(anyString())).thenReturn(languageClient);

    registry =
        spy(
            new LanguageServerRegistryImpl(
                Collections.singleton(languageServerLauncher),
                Collections.singleton(languageDescription),
                pmp,
                initializer,
                null,
                clientFactory) {
              @Override
              protected String extractProjectPath(String filePath) throws LanguageServerException {
                return PROJECT_PATH;
              }
            });

    when(initializer.initialize(
            any(LanguageServerLauncher.class), any(LanguageClient.class), anyString()))
        .thenAnswer(
            invocation -> {
              return CompletableFuture.completedFuture(Pair.of(languageServer, initializeResult));
            });
  }

