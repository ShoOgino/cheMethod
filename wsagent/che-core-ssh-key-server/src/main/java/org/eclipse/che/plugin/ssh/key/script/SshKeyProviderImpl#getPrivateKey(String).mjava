  /**
   * Get private ssh key and upload public ssh key to repository hosting service.
   *
   * @param url url to the repository
   * @return private ssh key
   * @throws ServerException if an error occurs while generating or uploading keys
   */
  @Override
  public byte[] getPrivateKey(String url) throws ServerException {
    String host = UrlUtils.getHost(url);

    SshPair pair;
    try {
      pair = sshService.getPair("vcs", host);
    } catch (ServerException | NotFoundException e) {
      throw new ServerException(
          DtoFactory.newDto(ExtendedError.class)
              .withMessage("Unable get private ssh key")
              .withErrorCode(ErrorCodes.UNABLE_GET_PRIVATE_SSH_KEY));
    }

    // check keys existence
    String privateKey = pair.getPrivateKey();
    if (privateKey == null) {
      throw new ServerException(
          DtoFactory.newDto(ExtendedError.class)
              .withMessage("Unable get private ssh key")
              .withErrorCode(ErrorCodes.UNABLE_GET_PRIVATE_SSH_KEY));
    }

    final String publicKey = pair.getPublicKey();
    if (publicKey != null) {
      final Optional<SshKeyUploader> optionalKeyUploader =
          sshKeyUploaders.stream().filter(keyUploader -> keyUploader.match(url)).findFirst();
      if (optionalKeyUploader.isPresent()) {
        final SshKeyUploader uploader = optionalKeyUploader.get();
        try {
          uploader.uploadKey(publicKey);
        } catch (IOException e) {
          throw new ServerException(e.getMessage(), e);
        } catch (UnauthorizedException e) {
          // action might fail without uploaded public SSH key.
          LOG.warn(
              String.format(
                  "Unable upload public SSH key with %s", uploader.getClass().getSimpleName()),
              e);
        }
      } else {
        // action might fail without uploaded public SSH key.
        LOG.warn(String.format("Not found ssh key uploader for %s", host));
      }
    }
    return privateKey.getBytes();
  }

