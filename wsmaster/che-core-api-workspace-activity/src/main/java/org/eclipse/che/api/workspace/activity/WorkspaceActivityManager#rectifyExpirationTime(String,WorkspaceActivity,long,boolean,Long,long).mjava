  private void rectifyExpirationTime(
      String runningWsId,
      WorkspaceActivity activity,
      long now,
      boolean noLastRunningTime,
      Long lastKnownActivity,
      long idleTimeout) {
    // define the error message upfront to make it easier to follow the actual logic
    final String noActivityFoundWhileHandlingExpiration =
        "Found no expiration time on workspace {}. No prior activity was found on the  workspace."
            + " To restore the normal function, the expiration time has been set to {}.";
    final String noExpirationWithoutLastRunning =
        "Found no expiration time on workspace {} and no  record of the last time it started. The"
            + " expiration has been set to {}";
    final String noExpirationAfterThresholdTime =
        "Found no expiration time on workspace {}. This  was detected {}ms after the workspace has"
            + " been recorded running which is suspicious.  Please consider filing a bug report. To"
            + " restore the normal function, the expiration  time has been set to {}.";
    final String noExpirationBeforeThresholdTime =
        "Found no expiration time on workspace {}. This  was detected {}ms after the workspace has"
            + " been recorded running which is most probably caused by the schedule coinciding with"
            + " the workspace actually entering the running state. Not rectifying the expiration at"
            + " the moment and leaving that for the next iteration.";

    // if this happens within 1 second of the last transition to having been started,
    // let's just consider it a case of coincidence between this periodic check and the event
    // handler setting the expiration time. Let's just do our work here in either case,
    // because the difference in times set by this method and the event handler will be very
    // small and we make sure that we don't enter the state where a running workspace doesn't
    // have any expiry period in case there was a problem.

    // first figure out the expiration time. The last running time has been initialized
    // in the code above, so we can safely assume it is non-null, here.
    long lastTime = activity.getLastRunning();

    if (lastKnownActivity == null) {
      // here, we have no prior record of any activity. Even thought the code above tried to
      // fix that, we don't want to report on the half-way fixed state. Let's just fix the
      // expiration-related part of the problem and report that we fixed it from the original
      // "condition" of the activity record.
      update(runningWsId, lastTime);
      LOG.warn(noActivityFoundWhileHandlingExpiration, runningWsId, lastTime);
    } else if (noLastRunningTime) {
      // the DB contained no record of the last time the workspace was running, but we found
      // it running anyway. The last_running time was already set to "now" in the code above
      // but we want to report about the expiration being set regardless of that fact.
      update(runningWsId, lastTime);
      LOG.warn(noExpirationWithoutLastRunning, runningWsId, lastTime);
    } else {
      // we have a record of the workspace entering the running state in the DB but we don't
      // have any expiration timestamp yet. This looks like a coincidence between the schedule
      // of this method and the workspace actually starting. Let's just give the DB a second
      // leeway before we log a warning and fix the issue.
      long timeAfterRunning = now - lastTime;

      if (timeAfterRunning > 1000) {
        update(runningWsId, lastTime);
        LOG.warn(noExpirationAfterThresholdTime, runningWsId, timeAfterRunning, lastTime);
      } else {
        LOG.debug(noExpirationBeforeThresholdTime, runningWsId, timeAfterRunning, lastTime);
      }
    }
  }

