    private MachineImpl createMachine(MachineConfigImpl machineConfig,
                                      String workspaceId,
                                      String environmentName,
                                      MachineInstanceCreator instanceCreator,
                                      SnapshotImpl snapshot,
                                      LineConsumer outputConsumer)
            throws NotFoundException,
                   SnapshotException,
                   ConflictException,
                   BadRequestException,
                   MachineException {
        final MachineSourceImpl sourceCopy = machineConfig.getSource();
        final InstanceProvider instanceProvider = machineInstanceProviders.getProvider(machineConfig.getType());

        // Backward compatibility for source type 'Recipe'.
        // Only 'dockerfile' impl of source type existed when 'Recipe' was valid source type.
        // Changed in 4.2.0-RC1
        // todo remove that several versions later
        if ("recipe".equalsIgnoreCase(machineConfig.getSource().getType())) {
            machineConfig.getSource().setType("dockerfile");
        }
        if (!instanceProvider.getRecipeTypes().contains(machineConfig.getSource().getType().toLowerCase())) {
            throw new UnsupportedRecipeException(format("Recipe type %s of %s machine is unsupported",
                                                        machineConfig.getSource().getType(),
                                                        machineConfig.getName()));
        }

        if (!MACHINE_DISPLAY_NAME_PATTERN.matcher(machineConfig.getName()).matches()) {
            throw new BadRequestException("Invalid machine name " + machineConfig.getName());
        }

        for (MachineImpl machine : machineRegistry.getMachines()) {
            if (machine.getWorkspaceId().equals(workspaceId) && machine.getConfig().getName().equals(machineConfig.getName())) {
                throw new ConflictException("Machine with name " + machineConfig.getName() + " already exists");
            }
        }

        // recover key from snapshot if there is one
        if (snapshot != null) {
            machineConfig.setSource(snapshot.getMachineSource());
        }

        final String machineId = generateMachineId();
        final String creator = EnvironmentContext.getCurrent().getSubject().getUserId();

        if (machineConfig.getLimits().getRam() == 0) {
            machineConfig.setLimits(new LimitsImpl(defaultMachineMemorySizeMB));
        }

        final MachineImpl machine = new MachineImpl(machineConfig,
                                                    machineId,
                                                    workspaceId,
                                                    environmentName,
                                                    creator,
                                                    MachineStatus.CREATING,
                                                    null);

        createMachineLogsDir(machineId);
        final LineConsumer machineLogger = getMachineLogger(machineId, outputConsumer);

        try {
            machineRegistry.addMachine(machine);
            try {
                instanceCreator.createInstance(instanceProvider, machine, machineLogger);
            } catch (MachineException ex) {
                if (snapshot == null) {
                    throw ex;
                }
                if (ex.getCause() instanceof SourceNotFoundException) {
                    LOG.error("Image of snapshot for machine " + machineConfig.getName() + " not found. " +
                              "Machine will be created from origin source");
                    machine.getConfig().setSource(sourceCopy);
                    try {
                        machineRegistry.remove(machineId);
                    } catch (NotFoundException ignored) {
                        // machine is already removed, should never happen
                    }
                    machineRegistry.addMachine(machine);
                    instanceCreator.createInstance(instanceProvider, machine, outputConsumer);
                }
            }
            return machine;
        } catch (ApiException apiEx) {
            try {
                machineLogger.close();
            } catch (IOException ioEx) {
                LOG.error(ioEx.getLocalizedMessage(), ioEx);
            }
            try {
                machineRegistry.remove(machineId);
            } catch (NotFoundException ignored) {
                // machine is already removed
            }

            throw new MachineException(apiEx.getLocalizedMessage(), apiEx);
        }
    }

