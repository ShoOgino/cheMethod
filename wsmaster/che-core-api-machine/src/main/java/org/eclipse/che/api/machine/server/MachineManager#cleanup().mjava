    @PreDestroy
    private void cleanup() {
        eventService.unsubscribe(machineCleaner);

        boolean interrupted = false;

        executor.shutdown();

        final ExecutorService destroyMachinesExecutor =
                Executors.newFixedThreadPool(2 * Runtime.getRuntime().availableProcessors(),
                                             new ThreadFactoryBuilder().setNameFormat("DestroyMachine-%d")
                                                                       .setDaemon(false)
                                                                       .build());
        try {
            for (MachineImpl machine : machineRegistry.getMachines()) {
                destroyMachinesExecutor.execute(() -> {
                    try {
                        destroy(machine.getId(), false);
                    } catch (NotFoundException ignore) {
                        // it is ok, machine has been already destroyed
                    } catch (Exception e) {
                        LOG.warn(e.getMessage());
                    }
                });
            }
            destroyMachinesExecutor.shutdown();
            if (!destroyMachinesExecutor.awaitTermination(50, TimeUnit.SECONDS)) {
                destroyMachinesExecutor.shutdownNow();
                if (!destroyMachinesExecutor.awaitTermination(10, TimeUnit.SECONDS)) {
                    LOG.warn("Unable terminate destroy machines pool");
                }
            }
        } catch (InterruptedException e) {
            interrupted = true;
            destroyMachinesExecutor.shutdownNow();
        } catch (MachineException e) {
            LOG.error(e.getLocalizedMessage(), e);
        }

        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    LOG.warn("Unable terminate main pool");
                }
            }
        } catch (InterruptedException e) {
            interrupted = true;
            executor.shutdownNow();
        }

        final java.io.File[] files = machineLogsDir.listFiles();
        if (files != null && files.length > 0) {
            for (java.io.File f : files) {
                if (!IoUtil.deleteRecursive(f)) {
                    LOG.warn("Failed delete {}", f);
                }
            }
        }
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }

