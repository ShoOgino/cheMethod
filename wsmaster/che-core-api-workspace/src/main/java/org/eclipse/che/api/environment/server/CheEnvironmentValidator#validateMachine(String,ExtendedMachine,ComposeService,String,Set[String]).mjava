    protected void validateMachine(String machineName,
                                   @Nullable ExtendedMachine extendedMachine,
                                   ComposeService service,
                                   String envName,
                                   Set<String> servicesNames) throws IllegalArgumentException {
        checkArgument(MACHINE_NAME_PATTERN.matcher(machineName).matches(),
                      "Name of machine '%s' in environment '%s' is invalid",
                      machineName, envName);

        // TODO remove workaround with dockerfile content in context.dockerfile
        checkArgument(!isNullOrEmpty(service.getImage()) ||
                      (service.getBuild() != null && (!isNullOrEmpty(service.getBuild().getContext()) ||
                                                      !isNullOrEmpty(service.getBuild().getDockerfile()))),
                      "Field 'image' or 'build.context' is required in machine '%s' in environment '%s'",
                      machineName, envName);

        if (extendedMachine.getAttributes() != null &&
            extendedMachine.getAttributes().get("memoryLimitBytes") != null) {

            try {
                long memoryLimitBytes = Long.parseLong(extendedMachine.getAttributes().get("memoryLimitBytes"));
                checkArgument(memoryLimitBytes > 0,
                              "Value of attribute 'memoryLimitBytes' of machine '%s' in environment '%s' is illegal",
                              machineName, envName);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                        format("Value of attribute 'memoryLimitBytes' of machine '%s' in environment '%s' is illegal",
                               machineName, envName));
            }
        }

        if (extendedMachine.getServers() != null) {
            extendedMachine.getServers()
                           .entrySet()
                           .forEach(serverEntry -> {
                               String serverName = serverEntry.getKey();
                               ServerConf2 server = serverEntry.getValue();

                               checkArgument(server.getPort() != null && SERVER_PORT.matcher(server.getPort()).matches(),
                                             "Machine '%s' in environment '%s' contains server conf '%s' with invalid port '%s'",
                                             machineName, envName, serverName, server.getPort());
                               checkArgument(server.getProtocol() == null || SERVER_PROTOCOL.matcher(server.getProtocol()).matches(),
                                             "Machine '%s' in environment '%s' contains server conf '%s' with invalid protocol '%s'",
                                             machineName, envName, serverName, server.getProtocol());
                           });
        }

        service.getExpose()
               .forEach(expose -> checkArgument(EXPOSE_PATTERN.matcher(expose).matches(),
                                                "Exposed port '%s' in machine '%s' in environment '%s' is invalid",
                                                expose, machineName, envName));

        service.getLinks()
               .forEach(link -> {
                   Matcher matcher = LINK_PATTERN.matcher(link);

                   checkArgument(matcher.matches(),
                                 "Link '%s' in machine '%s' in environment '%s' is invalid",
                                 link, machineName, envName);

                   String serviceFromLink = matcher.group("serviceName");
                   checkArgument(servicesNames.contains(serviceFromLink),
                                 "Machine '%s' in environment '%s' contains link to non existing machine '%s'",
                                 machineName, envName, serviceFromLink);
               });

        service.getDependsOn()
               .forEach(depends -> {
                   checkArgument(MACHINE_NAME_PATTERN.matcher(depends).matches(),
                                 "Dependency '%s' in machine '%s' in environment '%s' is invalid",
                                 depends, machineName, envName);

                   checkArgument(servicesNames.contains(depends),
                                 "Machine '%s' in environment '%s' contains dependency to non existing machine '%s'",
                                 machineName, envName, depends);
               });

        service.getVolumesFrom()
               .forEach(volumesFrom -> {
                   Matcher matcher = VOLUME_FROM_PATTERN.matcher(volumesFrom);

                   checkArgument(matcher.matches(),
                                 "Machine name '%s' in field 'volumes_from' of machine '%s' in environment '%s' is invalid",
                                 volumesFrom, machineName, envName);

                   String serviceFromVolumesFrom = matcher.group("serviceName");
                   checkArgument(servicesNames.contains(serviceFromVolumesFrom),
                                 "Machine '%s' in environment '%s' contains non existing machine '%s' in 'volumes_from' field",
                                 machineName, envName, serviceFromVolumesFrom);
               });

        checkArgument(service.getPorts() == null || service.getPorts().isEmpty(),
                      "Ports binding is forbidden but found in machine '%s' of environment '%s'",
                      machineName, envName);

        checkArgument(service.getVolumes() == null || service.getVolumes().isEmpty(),
                      "Volumes binding is forbidden but found in machine '%s' of environment '%s'",
                      machineName, envName);
    }

