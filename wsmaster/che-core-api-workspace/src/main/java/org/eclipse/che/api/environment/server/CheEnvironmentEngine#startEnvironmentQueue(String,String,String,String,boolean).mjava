    /**
     * Starts all machine from machine queue of environment.
     */
    private void startEnvironmentQueue(String namespace,
                                       String workspaceId,
                                       String devMachineName,
                                       String networkId,
                                       boolean recover)
            throws ServerException {
        // Starting all machines in environment one by one by getting configs
        // from the corresponding starting queue.
        // Config will be null only if there are no machines left in the queue
        String envName;
        MessageConsumer<MachineLogMessage> envLogger;
        try (StripedLocks.ReadLock lock = stripedLocks.acquireReadLock(workspaceId)) {
            EnvironmentHolder environmentHolder = environments.get(workspaceId);
            if (environmentHolder == null) {
                throw new ServerException("Environment start is interrupted.");
            }
            envName = environmentHolder.name;
            envLogger = environmentHolder.logger;
        }

        try {
            composeProvider.createNetwork(networkId);

            String machineName = queuePeekOrFail(workspaceId);
            while (machineName != null) {
                boolean isDev = devMachineName.equals(machineName);
                // Environment start is failed when any machine start is failed, so if any error
                // occurs during machine creation then environment start fail is reported and
                // start resources such as queue and descriptor must be cleaned up
                String machineId = generateMachineId();
                String creator = EnvironmentContext.getCurrent().getSubject().getUserId();

                ComposeServiceImpl composeService;
                try (StripedLocks.ReadLock lock = stripedLocks.acquireReadLock(workspaceId)) {
                    EnvironmentHolder environmentHolder = environments.get(workspaceId);
                    if (environmentHolder == null) {
                        throw new ServerException("Environment start is interrupted.");
                    }
                    composeService = environmentHolder.composeEnvironment.getServices().get(machineName);
                }
                // should not happen
                if (composeService == null) {
                    LOG.error("Compose service with name {} is missing in compose environment", machineName);
                    throw new ServerException("Environment of workspace with ID '%s' failed due to internal error");
                }

                MachineImpl machine =
                        MachineImpl.builder()
                                   .setConfig(MachineConfigImpl.builder()
                                                               .setDev(isDev)
                                                               .setLimits(new MachineLimitsImpl(
                                                                       bytesToMB(composeService.getMemLimit())))
                                                               .setType("docker")
                                                               .setName(machineName)
                                                               .build())
                                   .setId(machineId)
                                   .setWorkspaceId(workspaceId)
                                   .setStatus(MachineStatus.CREATING)
                                   .setEnvName(envName)
                                   .setOwner(creator)
                                   .build();

                final String finalMachineName = machineName;
                // needed to reuse startInstance method and
                // create machine instances by different implementation-specific providers
                MachineStarter machineStarter = (machineLogger, machineSource) -> {
                    ComposeServiceImpl serviceWithCorrectSource = getServiceWithCorrectSource(composeService, machineSource);
                    return composeProvider.startService(namespace,
                                                        workspaceId,
                                                        envName,
                                                        machineId,
                                                        finalMachineName,
                                                        isDev,
                                                        networkId,
                                                        serviceWithCorrectSource,
                                                        machineLogger);
                };
                Instance instance = startInstance(recover,
                                                  envLogger,
                                                  machine,
                                                  machineStarter);

                // Machine destroying is an expensive operation which must be
                // performed outside of the lock, this section checks if
                // the environment wasn't stopped while it is starting and sets
                // polled flag to true if the environment wasn't stopped.
                // Also polls the proceeded machine configuration from the queue
                boolean queuePolled = false;
                try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
                    ensurePreDestroyIsNotExecuted();
                    EnvironmentHolder environmentHolder = environments.get(workspaceId);
                    if (environmentHolder != null) {
                        final Queue<String> queue = environmentHolder.startQueue;
                        if (queue != null) {
                            queue.poll();
                            queuePolled = true;
                        }
                    }
                }

                // If machine config is not polled from the queue
                // then environment was stopped and newly created machine
                // must be destroyed
                if (!queuePolled) {
                    try {
                        eventService.publish(newDto(MachineStatusEvent.class)
                                                     .withEventType(MachineStatusEvent.EventType.DESTROYING)
                                                     .withDev(isDev)
                                                     .withMachineName(machineName)
                                                     .withMachineId(instance.getId())
                                                     .withWorkspaceId(workspaceId));

                        instance.destroy();

                        removeMachine(workspaceId, instance.getId());

                        eventService.publish(newDto(MachineStatusEvent.class)
                                                     .withEventType(MachineStatusEvent.EventType.DESTROYED)
                                                     .withDev(isDev)
                                                     .withMachineName(machineName)
                                                     .withMachineId(instance.getId())
                                                     .withWorkspaceId(workspaceId));
                    } catch (MachineException e) {
                        LOG.error(e.getLocalizedMessage(), e);
                    }
                    throw new ServerException("Workspace '" + workspaceId +
                                              "' start interrupted. Workspace stopped before all its machines started");
                }

                machineName = queuePeekOrFail(workspaceId);
            }
        } catch (RuntimeException | ServerException e) {
            EnvironmentHolder env;
            try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
                env = environments.remove(workspaceId);
            }

            try {
                destroyEnvironment(env.networkId, env.machines);
            } catch (Exception remEx) {
                LOG.error(remEx.getLocalizedMessage(), remEx);
            }
            throw new ServerException(e.getLocalizedMessage(), e);
        }
    }

