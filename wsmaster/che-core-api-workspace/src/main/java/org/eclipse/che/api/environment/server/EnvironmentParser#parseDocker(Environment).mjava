    private ComposeEnvironmentImpl parseDocker(Environment environment) {
        checkArgument(environment.getMachines().size() == 1,
                      "Environment of type '%s' doesn't support multiple machines, but contains machines: %s",
                      environment.getRecipe().getType(),
                      Joiner.on(',').join(environment.getMachines().keySet()));

        ComposeEnvironmentImpl composeEnvironment = new ComposeEnvironmentImpl();
        ComposeServiceImpl service = new ComposeServiceImpl();

        composeEnvironment.getServices().put(environment.getMachines()
                                                        .keySet()
                                                        .iterator()
                                                        .next(), service);

        EnvironmentRecipe recipe = environment.getRecipe();

        if ("dockerimage".equals(environment.getRecipe().getType())) {
            service.setImage(recipe.getLocation());
        } else {
            if (!"text/x-dockerfile".equals(recipe.getContentType())) {
                throw new IllegalArgumentException(
                        format("Content type '%s' of recipe of environment is unsupported. Supported values are: text/x-dockerfile",
                               recipe.getContentType()));
            }

            if (recipe.getLocation() != null) {
                service.setBuild(new BuildContextImpl().withContext(recipe.getLocation()));
            } else {
                // workaround: put dockerfile content into field dockerfile.
                // Service launching code must know about that workaround
                service.setBuild(new BuildContextImpl().withDockerfile(recipe.getContent()));
            }
        }

        return composeEnvironment;
    }

