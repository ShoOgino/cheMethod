  // TODO fix error messages: fields mentioning, usage of service term
  public void validate(String envName, Environment env)
      throws IllegalArgumentException, ServerException {
    checkArgument(!isNullOrEmpty(envName), "Environment name should not be neither null nor empty");
    checkNotNull(env.getRecipe(), "Environment recipe should not be null");
    checkArgument(
        environmentParser.getEnvironmentTypes().contains(env.getRecipe().getType()),
        "Type '%s' of environment '%s' is not supported. Supported types: %s",
        env.getRecipe().getType(),
        envName,
        Joiner.on(',').join(environmentParser.getEnvironmentTypes()));
    checkArgument(
        env.getRecipe().getContent() != null || env.getRecipe().getLocation() != null,
        "Recipe of environment '%s' must contain location or content",
        envName);
    checkArgument(
        env.getRecipe().getContent() == null || env.getRecipe().getLocation() == null,
        "Recipe of environment '%s' contains mutually exclusive fields location and content",
        envName);

    CheServicesEnvironmentImpl cheServicesEnvironment;
    try {
      cheServicesEnvironment = environmentParser.parse(env);
    } catch (ServerException e) {
      throw new ServerException(
          format(
              "Parsing of recipe of environment '%s' failed. Error: %s",
              envName, e.getLocalizedMessage()));
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException(
          format(
              "Parsing of recipe of environment '%s' failed. Error: %s",
              envName, e.getLocalizedMessage()));
    }

    checkArgument(
        cheServicesEnvironment.getServices() != null
            && !cheServicesEnvironment.getServices().isEmpty(),
        "Environment '%s' should contain at least 1 machine",
        envName);

    checkArgument(
        env.getMachines() != null && !env.getMachines().isEmpty(),
        "Environment '%s' doesn't contain machine with 'org.eclipse.che.ws-agent' agent",
        envName);

    List<String> missingServices =
        env.getMachines()
            .keySet()
            .stream()
            .filter(machineName -> !cheServicesEnvironment.getServices().containsKey(machineName))
            .collect(toList());
    checkArgument(
        missingServices.isEmpty(),
        "Environment '%s' contains machines that are missing in environment recipe: %s",
        envName,
        Joiner.on(", ").join(missingServices));

    List<String> devMachines =
        env.getMachines()
            .entrySet()
            .stream()
            .filter(
                entry ->
                    entry.getValue().getAgents() != null
                        && entry.getValue().getAgents().contains("org.eclipse.che.ws-agent"))
            .map(Map.Entry::getKey)
            .collect(toList());

    checkArgument(
        devMachines.size() == 1,
        "Environment '%s' should contain exactly 1 machine with agent 'org.eclipse.che.ws-agent', but contains '%s'. "
            + "All machines with this agent: %s",
        envName,
        devMachines.size(),
        Joiner.on(", ").join(devMachines));

    // needed to validate different kinds of dependencies in services to other services
    Set<String> servicesNames = cheServicesEnvironment.getServices().keySet();

    cheServicesEnvironment
        .getServices()
        .forEach(
            (serviceName, service) ->
                validateMachine(
                    serviceName,
                    env.getMachines().get(serviceName),
                    service,
                    envName,
                    servicesNames));

    // check that order can be resolved
    try {
      startStrategy.order(cheServicesEnvironment);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException(
          format(
              "Start order of machine in environment '%s' is not resolvable. Error: %s",
              envName, e.getLocalizedMessage()));
    }
  }

