    public void validate(String envName, Environment env) throws IllegalArgumentException,
                                                                 ServerException {
        checkArgument(!isNullOrEmpty(envName),
                      "Environment name should not be neither null nor empty");
        checkNotNull(env.getRecipe(), "Environment recipe should not be null");
        checkArgument(environmentParser.getEnvironmentTypes().contains(env.getRecipe().getType()),
                      "Type '%s' of environment '%s' is not supported. Supported types: %s",
                      env.getRecipe().getType(),
                      envName,
                      Joiner.on(',').join(environmentParser.getEnvironmentTypes()));
        checkArgument(env.getRecipe().getContent() != null || env.getRecipe().getLocation() != null,
                      "Recipe of environment '%s' must contain location or content", envName);
        checkArgument(env.getRecipe().getContent() == null || env.getRecipe().getLocation() == null,
                      "Recipe of environment '%s' contains mutually exclusive fields location and content",
                      envName);

        ComposeEnvironmentImpl composeEnvironment;
        try {
            composeEnvironment = environmentParser.parse(env);
        } catch (ServerException e) {
            throw new ServerException(format("Parsing of recipe of environment '%s' failed. Error: %s",
                                             envName, e.getLocalizedMessage()));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(format("Parsing of recipe of environment '%s' failed. Error: %s",
                                                      envName, e.getLocalizedMessage()));
        }

        checkArgument(composeEnvironment.getServices() != null && !composeEnvironment.getServices().isEmpty(),
                      "Environment '%s' should contain at least 1 machine",
                      envName);

        checkArgument(env.getMachines() != null && !env.getMachines().isEmpty(),
                      "Environment '%s' doesn't contain machine with 'ws-agent' agent",
                      envName);

        List<String> missingServices = env.getMachines()
                                          .keySet()
                                          .stream()
                                          .filter(machineName -> !composeEnvironment.getServices()
                                                                                    .containsKey(machineName))
                                          .collect(toList());
        checkArgument(missingServices.isEmpty(),
                      "Environment '%s' contains machines that are missing in environment recipe: %s",
                      envName, Joiner.on(", ").join(missingServices));

        List<String> devMachines = env.getMachines()
                                      .entrySet()
                                      .stream()
                                      .filter(entry -> entry.getValue()
                                                            .getAgents()
                                                            .contains("ws-agent"))
                                      .map(Map.Entry::getKey)
                                      .collect(toList());

        checkArgument(devMachines.size() == 1,
                      "Environment '%s' should contain exactly 1 machine with ws-agent, but contains '%s'. " +
                      "All machines with this agent: %s",
                      envName, devMachines.size(), Joiner.on(", ").join(devMachines));

        // needed to validate different kinds of dependencies in services to other services
        Set<String> servicesNames = composeEnvironment.getServices().keySet();

        composeEnvironment.getServices()
                          .forEach((serviceName, service) -> validateMachine(serviceName,
                                                                             env.getMachines().get(serviceName),
                                                                             service,
                                                                             envName,
                                                                             servicesNames));

        // check that order can be resolved
        try {
            startStrategy.order(composeEnvironment);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(
                    format("Start order of machine in environment '%s' is not resolvable. Error: %s",
                           envName, e.getLocalizedMessage()));
        }
    }

