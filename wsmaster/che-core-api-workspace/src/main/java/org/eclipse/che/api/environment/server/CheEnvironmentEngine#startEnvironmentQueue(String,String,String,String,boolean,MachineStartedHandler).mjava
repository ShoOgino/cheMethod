    /**
     * Starts all machine from machine queue of environment.
     */
    private void startEnvironmentQueue(String namespace,
                                       String workspaceId,
                                       String devMachineName,
                                       String networkId,
                                       boolean recover,
                                       MachineStartedHandler startedHandler)
            throws ServerException,
                   AgentException,
                   EnvironmentException {
        // Starting all machines in environment one by one by getting configs
        // from the corresponding starting queue.
        // Config will be null only if there are no machines left in the queue
        String envName;
        MessageConsumer<MachineLogMessage> envLogger;
        String creator = EnvironmentContext.getCurrent().getSubject().getUserId();
        try (@SuppressWarnings("unused") Unlocker u = stripedLocks.readLock(workspaceId)) {
            EnvironmentHolder environmentHolder = environments.get(workspaceId);
            if (environmentHolder == null) {
                throw new ServerException("Environment start is interrupted.");
            }
            envName = environmentHolder.name;
            envLogger = environmentHolder.logger;
        }

        try {
            machineProvider.createNetwork(networkId);

            String machineName = queuePeekOrFail(workspaceId);
            while (machineName != null) {
                boolean isDev = devMachineName.equals(machineName);
                // Environment start is failed when any machine start is failed, so if any error
                // occurs during machine creation then environment start fail is reported and
                // start resources such as queue and descriptor must be cleaned up

                CheServiceImpl service;
                @Nullable ExtendedMachine extendedMachine;
                try (@SuppressWarnings("unused") Unlocker u = stripedLocks.readLock(workspaceId)) {
                    EnvironmentHolder environmentHolder = environments.get(workspaceId);
                    if (environmentHolder == null) {
                        throw new EnvironmentStartInterruptedException(workspaceId, envName);
                    }
                    service = environmentHolder.environment.getServices().get(machineName);
                    extendedMachine = environmentHolder.environmentConfig.getMachines().get(machineName);
                }
                // should not happen
                if (service == null) {
                    LOG.error("Start of machine with name {} in workspace {} failed. Machine not found in start queue",
                              machineName, workspaceId);
                    throw new ServerException(
                            format("Environment of workspace with ID '%s' failed due to internal error", workspaceId));
                }

                final String finalMachineName = machineName;
                // needed to reuse startInstance method and
                // create machine instances by different implementation-specific providers
                MachineStarter machineStarter = (machineLogger, machineSource) -> {
                    CheServiceImpl serviceWithNormalizedSource = normalizeServiceSource(service, machineSource);
                    return machineProvider.startService(namespace,
                                                        workspaceId,
                                                        envName,
                                                        finalMachineName,
                                                        isDev,
                                                        networkId,
                                                        serviceWithNormalizedSource,
                                                        machineLogger);
                };

                MachineImpl machine =
                        MachineImpl.builder()
                                   .setConfig(MachineConfigImpl.builder()
                                                               .setDev(isDev)
                                                               .setLimits(new MachineLimitsImpl(
                                                                       bytesToMB(service.getMemLimit())))
                                                               .setType("docker")
                                                               .setName(machineName)
                                                               .setEnvVariables(service.getEnvironment())
                                                               .build())
                                   .setId(service.getId())
                                   .setWorkspaceId(workspaceId)
                                   .setStatus(MachineStatus.CREATING)
                                   .setEnvName(envName)
                                   .setOwner(creator)
                                   .build();

                checkInterruption(workspaceId, envName);
                Instance instance = startInstance(recover,
                                                  envLogger,
                                                  machine,
                                                  machineStarter);
                checkInterruption(workspaceId, envName);

                startedHandler.started(instance, extendedMachine);
                checkInterruption(workspaceId, envName);

                // Machine destroying is an expensive operation which must be
                // performed outside of the lock, this section checks if
                // the environment wasn't stopped while it is starting and sets
                // polled flag to true if the environment wasn't stopped.
                // Also polls the proceeded machine configuration from the queue
                boolean queuePolled = false;
                try (@SuppressWarnings("unused") Unlocker u = stripedLocks.writeLock(workspaceId)) {
                    ensurePreDestroyIsNotExecuted();
                    EnvironmentHolder environmentHolder = environments.get(workspaceId);
                    if (environmentHolder != null) {
                        final Queue<String> queue = environmentHolder.startQueue;
                        if (queue != null) {
                            queue.poll();
                            queuePolled = true;
                        }
                    }
                }

                // If machine config is not polled from the queue
                // then environment was stopped and newly created machine
                // must be destroyed
                if (!queuePolled) {
                    try {
                        eventService.publish(newDto(MachineStatusEvent.class)
                                                     .withEventType(MachineStatusEvent.EventType.DESTROYING)
                                                     .withDev(isDev)
                                                     .withMachineName(machineName)
                                                     .withMachineId(instance.getId())
                                                     .withWorkspaceId(workspaceId));

                        instance.destroy();

                        removeMachine(workspaceId, instance.getId());

                        eventService.publish(newDto(MachineStatusEvent.class)
                                                     .withEventType(MachineStatusEvent.EventType.DESTROYED)
                                                     .withDev(isDev)
                                                     .withMachineName(machineName)
                                                     .withMachineId(instance.getId())
                                                     .withWorkspaceId(workspaceId));
                    } catch (MachineException e) {
                        LOG.error(e.getLocalizedMessage(), e);
                    }
                    throw new ServerException("Workspace '" + workspaceId +
                                              "' start interrupted. Workspace stopped before all its machines started");
                }

                machineName = queuePeekOrFail(workspaceId);
            }
        } catch (Exception e) {
            boolean interrupted = Thread.interrupted();
            EnvironmentHolder env;
            try (@SuppressWarnings("unused") Unlocker u = stripedLocks.writeLock(workspaceId)) {
                env = environments.remove(workspaceId);
            }

            try {
                destroyEnvironment(env.networkId, env.machines);
            } catch (Exception remEx) {
                LOG.error(remEx.getLocalizedMessage(), remEx);
            }

            if (interrupted) {
                throw new EnvironmentStartInterruptedException(workspaceId, envName);
            }
            try {
                throw e;
            } catch (ServerException | EnvironmentException | AgentException rethrow) {
                throw rethrow;
            } catch (Exception wrap) {
                throw new ServerException(wrap.getMessage(), wrap);
            }
        }
    }

