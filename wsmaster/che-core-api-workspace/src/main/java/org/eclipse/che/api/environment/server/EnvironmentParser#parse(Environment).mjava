  /**
   * Parses {@link Environment} into {@link CheServicesEnvironmentImpl}.
   *
   * @param environment environment to parse
   * @return environment representation as compose environment
   * @throws IllegalArgumentException if provided environment is illegal
   * @throws ServerException if fetching of environment recipe content fails
   */
  public CheServicesEnvironmentImpl parse(Environment environment)
      throws IllegalArgumentException, ServerException {

    checkNotNull(environment, "Environment should not be null");
    EnvironmentRecipe recipe = environment.getRecipe();
    checkNotNull(recipe, "Environment recipe should not be null");
    checkNotNull(recipe.getType(), "Environment recipe type should not be null");
    checkArgument(
        recipe.getContent() != null || recipe.getLocation() != null,
        "Recipe of environment must contain location or content");

    String envType = recipe.getType();
    Set<String> envTypes = getEnvironmentTypes();

    if (!envTypes.contains(envType)) {
      throw new IllegalArgumentException(
          format(
              "Environment type '%s' is not supported. " + "Supported environment types: %s",
              envType, Joiner.on(", ").join(envTypes)));
    }

    TypeSpecificEnvironmentParser parser = environmentParsers.get(envType);
    CheServicesEnvironmentImpl cheServicesEnvironment = parser.parse(environment);

    cheServicesEnvironment
        .getServices()
        .forEach(
            (name, service) -> {
              ExtendedMachine extendedMachine = environment.getMachines().get(name);
              if (extendedMachine != null) {
                normalizeMachine(name, service, extendedMachine);
              }
            });

    return cheServicesEnvironment;
  }

