    /**
     * Starts all machines from specified workspace environment,
     * creates workspace runtime instance based on that environment.
     *
     * <p>During the start of the workspace its
     * runtime is visible with {@link WorkspaceStatus#STARTING} status.
     *
     * @param workspace
     *         workspace which environment should be started
     * @param envName
     *         the name of the environment to start
     * @param recover
     *         whether machines should be recovered(true) or not(false)
     * @return the workspace runtime instance with machines set.
     * @throws ConflictException
     *         when workspace is already running
     * @throws ConflictException
     *         when start is interrupted
     * @throws NotFoundException
     *         when any not found exception occurs during environment start
     * @throws ServerException
     *         when component {@link #isPreDestroyInvoked is stopped}
     * @throws ServerException
     *         other error occurs during environment start
     * @see CheEnvironmentEngine#start(String, Environment, boolean, MessageConsumer)
     * @see WorkspaceStatus#STARTING
     * @see WorkspaceStatus#RUNNING
     */
    public RuntimeDescriptor start(WorkspaceImpl workspace,
                                   String envName,
                                   boolean recover) throws ServerException,
                                                           ConflictException,
                                                           NotFoundException {
        String workspaceId = workspace.getId();

        Optional<EnvironmentImpl> environmentOpt = workspace.getConfig().getEnvironment(envName);
        if (!environmentOpt.isPresent()) {
            throw new IllegalArgumentException(format("Workspace '%s' doesn't contain environment '%s'",
                                                      workspaceId,
                                                      envName));
        }

        // Environment copy constructor makes deep copy of objects graph
        // in this way machine configs also copied from incoming values
        // which means that original values won't affect the values in starting queue
        EnvironmentImpl environmentCopy = new EnvironmentImpl(environmentOpt.get());

        // This check allows to exit with an appropriate exception before blocking on lock.
        // The double check is required as it is still possible to get unlucky timing
        // between locking and starting workspace.
        ensurePreDestroyIsNotExecuted();
        try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
            ensurePreDestroyIsNotExecuted();
            WorkspaceState workspaceState = workspaces.get(workspaceId);
            if (workspaceState != null) {
                throw new ConflictException(format("Could not start workspace '%s' because its status is '%s'",
                                                   workspace.getConfig().getName(),
                                                   workspaceState.status));
            }

            // Create a new workspace state and save it with 'STARTING' status
            workspaces.put(workspaceId, new WorkspaceState(WorkspaceStatus.STARTING, envName));
        }

        ensurePreDestroyIsNotExecuted();
        publishWorkspaceEvent(EventType.STARTING, workspaceId, null);

        try {
            List<Instance> machines = environmentEngine.start(workspaceId,
                                                              environmentCopy,
                                                              recover,
                                                              getEnvironmentLogger(workspaceId));
            Instance devMachine = getDevMachine(machines);

            wsAgentLauncher.startWsAgent(devMachine);

            try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
                WorkspaceState workspaceState = workspaces.get(workspaceId);
                workspaceState.status = WorkspaceStatus.RUNNING;
            }
            // Event publication should be performed outside of the lock
            // as it may take some time to notify subscribers
            publishWorkspaceEvent(EventType.RUNNING, workspaceId, null);
            return get(workspaceId);
        } catch (ApiException e) {
            try {
                environmentEngine.stop(workspaceId);
            } catch (Exception ex) {
                LOG.error(ex.getLocalizedMessage(), ex);
            }
            String environmentStartError = "Start of environment " + envName +
                                           " failed. Error: " + e.getLocalizedMessage();
            try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
                workspaces.remove(workspaceId);
            }
            publishWorkspaceEvent(EventType.ERROR,
                                  workspaceId,
                                  environmentStartError);

            throw new ServerException(environmentStartError);
        }
    }

