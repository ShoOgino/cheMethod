    /**
     * Starts all machines from specified workspace environment,
     * creates workspace runtime instance based on that environment.
     *
     * <p>Dev-machine always starts before the other machines.
     * If dev-machine start failed then method will throw appropriate
     * {@link ServerException}. During the start of the workspace its
     * runtime is visible with {@link WorkspaceStatus#STARTING} status.
     *
     * <p>If {@link #stop} method executed after dev machine is started but
     * another machines haven't been started yet then {@link ConflictException}
     * will be thrown and start process will be interrupted.
     *
     * <p>Note that it doesn't provide any events for
     * machines start, Machine API is responsible for it.
     *
     * @param workspace
     *         workspace which environment should be started
     * @param envName
     *         the name of the environment to start
     * @param recover
     *         whether machines should be recovered(true) or not(false)
     * @return the workspace runtime instance with machines set.
     * @throws ConflictException
     *         when workspace is already running
     * @throws ConflictException
     *         when start is interrupted
     * @throws NotFoundException
     *         when any not found exception occurs during environment start
     * @throws ServerException
     *         when component {@link #isPreDestroyInvoked is stopped} or any
     *         other error occurs during environment start
     * @see MachineManager#createMachineSync(MachineConfig, String, String, org.eclipse.che.api.core.util.LineConsumer)
     * @see WorkspaceStatus#STARTING
     * @see WorkspaceStatus#RUNNING
     */
    public RuntimeDescriptor start(WorkspaceImpl workspace,
                                   String envName,
                                   boolean recover) throws ServerException,
                                                           ConflictException,
                                                           NotFoundException {
        final Optional<EnvironmentImpl> environmentOpt = workspace.getConfig().getEnvironment(envName);
        if (!environmentOpt.isPresent()) {
            throw new IllegalArgumentException(format("Workspace '%s' doesn't contain environment '%s'",
                                                      workspace.getId(),
                                                      envName));
        }

        // Environment copy constructor makes deep copy of objects graph
        // in this way machine configs also copied from incoming values
        // which means that original values won't affect the values in starting queue
        final EnvironmentImpl environmentCopy = new EnvironmentImpl(environmentOpt.get());

        // This check allows to exit with an appropriate exception before blocking on lock.
        // The double check is required as it is still possible to get unlucky timing
        // between locking and starting workspace.
        ensurePreDestroyIsNotExecuted();
        acquireWriteLock(workspace.getId());
        try {
            ensurePreDestroyIsNotExecuted();
            final RuntimeDescriptor existingDescriptor = descriptors.get(workspace.getId());
            if (existingDescriptor != null) {
                throw new ConflictException(format("Could not start workspace '%s' because its status is '%s'",
                                                   workspace.getConfig().getName(),
                                                   existingDescriptor.getRuntimeStatus()));
            }

            // Create a new runtime descriptor and save it with 'STARTING' status
            final RuntimeDescriptor descriptor = new RuntimeDescriptor(new WorkspaceRuntimeImpl(envName));
            descriptor.setRuntimeStatus(WorkspaceStatus.STARTING);
            descriptors.put(workspace.getId(), descriptor);

            // Create a new start queue with a dev machine in the queue head
            final List<MachineConfigImpl> startConfigs = environmentCopy.getMachineConfigs();
            final MachineConfigImpl devCfg = removeFirstMatching(startConfigs, MachineConfig::isDev);
            startConfigs.add(0, devCfg);
            startQueues.put(workspace.getId(), new ArrayDeque<>(startConfigs));
        } finally {
            releaseWriteLock(workspace.getId());
        }

        startQueue(workspace.getId(), environmentCopy.getName(), recover);

        return get(workspace.getId());
    }

