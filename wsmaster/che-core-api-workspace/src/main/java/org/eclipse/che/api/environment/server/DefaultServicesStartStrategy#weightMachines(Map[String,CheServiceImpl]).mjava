  /**
   * Returns mapping of names of machines to its weights in dependency graph.
   *
   * @throws IllegalArgumentException if weights of machines can not be calculated
   */
  private Map<String, Integer> weightMachines(Map<String, CheServiceImpl> services)
      throws IllegalArgumentException {

    HashMap<String, Integer> weights = new HashMap<>();

    // create machines dependency graph
    Map<String, Set<String>> dependencies = new HashMap<>(services.size());
    for (Map.Entry<String, CheServiceImpl> serviceEntry : services.entrySet()) {
      CheServiceImpl service = serviceEntry.getValue();

      Set<String> machineDependencies =
          Sets.newHashSetWithExpectedSize(
              service.getDependsOn().size()
                  + service.getLinks().size()
                  + service.getVolumesFrom().size());

      for (String dependsOn : service.getDependsOn()) {
        checkDependency(
            dependsOn, serviceEntry.getKey(), services, "A machine can not depend on itself");
        machineDependencies.add(dependsOn);
      }

      // links also counts as dependencies
      for (String link : service.getLinks()) {
        String dependency = getServiceFromLink(link);
        checkDependency(
            dependency, serviceEntry.getKey(), services, "A machine can not link to itself");
        machineDependencies.add(dependency);
      }
      // volumesFrom also counts as dependencies
      for (String volumesFrom : service.getVolumesFrom()) {
        String dependency = getServiceFromVolumesFrom(volumesFrom);
        checkDependency(
            dependency,
            serviceEntry.getKey(),
            services,
            "A machine can not contain 'volumes_from' to itself");
        machineDependencies.add(dependency);
      }
      dependencies.put(serviceEntry.getKey(), machineDependencies);
    }

    // Find weight of each machine in graph.
    // Weight of machine is calculated as sum of all weights of machines it depends on.
    // Nodes with no dependencies gets weight 0
    while (!dependencies.isEmpty()) {
      int previousSize = dependencies.size();
      for (Iterator<Map.Entry<String, Set<String>>> it = dependencies.entrySet().iterator();
          it.hasNext();
          ) {
        // process not yet processed machines only
        Map.Entry<String, Set<String>> serviceEntry = it.next();
        String service = serviceEntry.getKey();
        Set<String> serviceDependencies = serviceEntry.getValue();

        if (serviceDependencies.isEmpty()) {
          // no links - smallest weight 0
          weights.put(service, 0);
          it.remove();
        } else {
          // machine has dependencies - check if it has not weighted dependencies
          if (weights.keySet().containsAll(serviceDependencies)) {
            // all connections are weighted - lets evaluate current machine
            Optional<String> maxWeight =
                serviceDependencies
                    .stream()
                    .max((o1, o2) -> weights.get(o1).compareTo(weights.get(o2)));
            // optional can't be empty because size of the list is checked above
            //noinspection OptionalGetWithoutIsPresent
            weights.put(service, weights.get(maxWeight.get()) + 1);
            it.remove();
          }
        }
      }
      if (dependencies.size() == previousSize) {
        throw new IllegalArgumentException(
            "Launch order of machines '"
                + Joiner.on(", ").join(dependencies.keySet())
                + "' can't be evaluated. Circular dependency.");
      }
    }

    return weights;
  }

