    /**
     * Terminates this pool, may be called multiple times,
     * waits until pool is terminated or timeout is reached.
     *
     * <p>Note that the method is not designed to be used from
     * different threads, but the other components may use it in their
     * post construct methods to ensure that all the tasks finished their execution.
     *
     * @return true if executor successfully terminated and false if not
     * terminated(either await termination timeout is reached or thread was interrupted)
     */
    @PostConstruct
    public boolean terminateAndWait() {
        if (executor.isShutdown()) {
            return true;
        }
        Logger logger = LoggerFactory.getLogger(getClass());
        executor.shutdown();
        try {
            logger.info("Shutdown workspace threads pool, wait 30s to stop normally");
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                logger.info("Interrupt workspace threads pool, wait 60s to stop");
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    logger.error("Couldn't terminate workspace threads pool");
                    return false;
                }
            }
        } catch (InterruptedException x) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
            return false;
        }
        return true;
    }

