    /**
     * Starts provided environment.
     * <p/>
     * Environment starts if and only all machines in environment definition start successfully.<br/>
     * Otherwise exception is thrown by this method.<br/>
     * It is not defined whether environment start fails right after first failure or in the end of the process.<br/>
     * Starting order of machines is not guarantied. Machines can start sequentially or in parallel.
     *
     * @param workspaceId
     *         ID of workspace that owns provided environment
     * @param env
     *         environment to start
     * @param recover
     *         whether machines from environment should be recovered or not
     * @param messageConsumer
     *         consumer of log messages from machines in the environment
     * @return list of running machines of this environment
     * @throws ServerException
     *         if other error occurs
     */
    public List<Instance> start(String workspaceId,
                                Environment env,
                                boolean recover,
                                MessageConsumer<MachineLogMessage> messageConsumer) throws ServerException,
                                                                                           ConflictException {

        // Create a new start queue with a dev machine in the queue head
        List<MachineConfigImpl> startConfigs = env.getMachineConfigs()
                                                  .stream()
                                                  .map(MachineConfigImpl::new)
                                                  .collect(Collectors.toList());
        final MachineConfigImpl devCfg = removeFirstMatching(startConfigs, MachineConfig::isDev);
        startConfigs.add(0, devCfg);

        EnvironmentHolder environmentHolder = new EnvironmentHolder(new ArrayDeque<>(startConfigs),
                                                                    new CopyOnWriteArrayList<>(),
                                                                    messageConsumer,
                                                                    EnvStatus.STARTING,
                                                                    env.getName());

        try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
            if (environments.putIfAbsent(workspaceId, environmentHolder) != null) {
                throw new ConflictException(format("Environment of workspace '%s' already exists", workspaceId));
            }
        }

        startQueue(workspaceId, env.getName(), recover, messageConsumer);

        try (StripedLocks.WriteLock lock = stripedLocks.acquireWriteLock(workspaceId)) {
            environmentHolder = environments.get(workspaceId);
            // possible only if environment was stopped during its start
            if (environmentHolder == null) {
                throw new ServerException("Environment start was interrupted by environment stopping");
            }
            environmentHolder.status = EnvStatus.RUNNING;
            return new ArrayList<>(environmentHolder.machines);
        }
    }

