    @Test
    public void shouldBeAbleToStartNonDockerMachine() throws Exception {
        // given
        ServerConf2 serverConf2 = mock(ServerConf2.class);
        when(serverConf2.getPort()).thenReturn("1111/tcp");
        when(serverConf2.getProtocol()).thenReturn("http");
        when(serverConf2.getProperties()).thenReturn(singletonMap("path", "some path"));
        when(agent.getServers()).thenAnswer(invocation -> singletonMap("ssh", serverConf2));

        List<Instance> instances = startEnv();
        String workspaceId = instances.get(0).getWorkspaceId();

        when(engine.generateMachineId()).thenReturn("newMachineId");
        Instance newMachine = mock(Instance.class);
        when(newMachine.getId()).thenReturn("newMachineId");
        when(newMachine.getWorkspaceId()).thenReturn(workspaceId);
        when(machineInstanceProviders.getProvider("anotherType")).thenReturn(instanceProvider);
        doReturn(newMachine).when(instanceProvider).createInstance(any(Machine.class), any(LineConsumer.class));

        MachineConfigImpl config = MachineConfigImpl.builder()
                                                    .fromConfig(createConfig(false))
                                                    .setType("anotherType")
                                                    .build();

        // when
        Instance actualInstance = engine.startMachine(workspaceId, config, singletonList("agent"));

        // then
        assertEquals(actualInstance, newMachine);
        ArgumentCaptor<Machine> argumentCaptor = ArgumentCaptor.forClass(Machine.class);
        verify(instanceProvider).createInstance(argumentCaptor.capture(), any(LineConsumer.class));

        MachineConfigImpl newConfig = new MachineConfigImpl(config);
        newConfig.setServers(singletonList(new ServerConfImpl("ssh", "1111/tcp", "http", "some path")));
        assertEquals(argumentCaptor.getValue().getConfig(), newConfig);
    }

