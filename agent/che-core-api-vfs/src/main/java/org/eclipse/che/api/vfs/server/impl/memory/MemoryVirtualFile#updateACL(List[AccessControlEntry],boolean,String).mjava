    public VirtualFile updateACL(List<AccessControlEntry> acl, boolean override, String lockToken) throws ForbiddenException {
        checkExist();
        if (!hasPermission(BasicPermissions.UPDATE_ACL.value(), true)) {
            throw new ForbiddenException(String.format("Unable update ACL for '%s'. Operation not permitted. ", getPath()));
        }
        if (isFile() && !validateLockTokenIfLocked(lockToken)) {
            throw new ForbiddenException(String.format("Unable update ACL of item '%s'. Item is locked. ", getPath()));
        }
        if (acl.isEmpty() && !override) {
            return this;
        }
        final Map<Principal, Set<String>> update = override ? new HashMap<Principal, Set<String>>(acl.size()) : getPermissions();
        for (AccessControlEntry ace : acl) {
            final Principal principal = ace.getPrincipal();
            // Do not use 'transport' object directly, copy it instead.
            final Principal copyPrincipal = DtoFactory.getInstance().clone(principal);
            final List<String> acePermissions = ace.getPermissions();
            if (acePermissions == null || acePermissions.isEmpty()) {
                update.remove(copyPrincipal);
            } else {
                Set<String> permissions = update.get(copyPrincipal);
                if (permissions == null) {
                    update.put(copyPrincipal, permissions = new HashSet<>(4));
                } else {
                    permissions.clear();
                }
                permissions.addAll(acePermissions);
            }
        }

        permissionsMap = update;
        lastModificationDate = System.currentTimeMillis();
        mountPoint.getEventService().publish(new UpdateACLEvent(mountPoint.getWorkspaceId(), getPath(), isFolder()));
        return this;
    }

