    // For usage from Project API.
    protected static ContentStream exportZip(VirtualFile folder, InputStream in, List<String> deleted)
            throws ForbiddenException, ServerException {
        final List<Pair<String, String>> remote = new LinkedList<>();
        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        String line;
        try {
            while ((line = reader.readLine()) != null) {
                String hash = line.substring(0, 32); // 32 is length of MD-5 hash sum
                int startPath = 33;
                int l = line.length();
                while (startPath < l && Character.isWhitespace(line.charAt(startPath))) {
                    startPath++;
                }
                String relPath = line.substring(startPath);
                remote.add(Pair.of(hash, relPath));
            }
        } catch (IOException e) {
            throw new ServerException(e.getMessage(), e);
        }
        if (remote.isEmpty()) {
            return folder.zip(VirtualFileFilter.ALL);
        }
        final LazyIterator<Pair<String, String>> md5Sums = folder.countMd5Sums();
        final int size = md5Sums.size();
        final List<Pair<String, String>> local =
                size > 0 ? new ArrayList<Pair<String, String>>(size) : new ArrayList<Pair<String, String>>();
        while (md5Sums.hasNext()) {
            local.add(md5Sums.next());
        }
        final Comparator<Pair<String, String>> comp = new Comparator<Pair<String, String>>() {
            @Override
            public int compare(Pair<String, String> o1, Pair<String, String> o2) {
                return o1.second.compareTo(o2.second);
            }
        };
        Collections.sort(remote, comp);
        Collections.sort(local, comp);
        int remoteIndex = 0;
        int localIndex = 0;
        final List<Pair<String, org.eclipse.che.api.vfs.server.Path>> diff = new LinkedList<>();
        while (remoteIndex < remote.size() && localIndex < local.size()) {
            final Pair<String, String> remoteItem = remote.get(remoteIndex);
            final Pair<String, String> localItem = local.get(localIndex);
            // compare path
            int r = remoteItem.second.compareTo(localItem.second);
            if (r == 0) {
                // remote and local file exist, compare md5sum
                if (!remoteItem.first.equals(localItem.first)) {
                    diff.add(Pair.of(remoteItem.second, folder.getVirtualFilePath().newPath(localItem.second)));
                }
                remoteIndex++;
                localIndex++;
            } else if (r > 0) {
                // new file
                diff.add(Pair.of((String)null, folder.getVirtualFilePath().newPath(localItem.second)));
                localIndex++;
            } else {
                // deleted file
                diff.add(Pair.of(remoteItem.second, (org.eclipse.che.api.vfs.server.Path)null));
                remoteIndex++;
            }
        }
        while (remoteIndex < remote.size()) {
            diff.add(Pair.of(remote.get(remoteIndex++).second, (org.eclipse.che.api.vfs.server.Path)null));
        }
        while (localIndex < local.size()) {
            diff.add(Pair.of((String)null, folder.getVirtualFilePath().newPath(local.get(localIndex++).second)));
        }

        if (diff.isEmpty()) {
            return null;
        }

        final ContentStream zip = folder.zip(new VirtualFileFilter() {
            @Override
            public boolean accept(VirtualFile file) {
                for (Pair<String, org.eclipse.che.api.vfs.server.Path> pair : diff) {
                    if (pair.second != null
                        && (pair.second.equals(file.getVirtualFilePath()) || pair.second.isChild(file.getVirtualFilePath()))) {
                        return true;
                    }
                }
                return false;
            }
        });

        deleted.clear();
        for (Pair<String, org.eclipse.che.api.vfs.server.Path> pair : diff) {
            if (pair.first != null && pair.second == null) {
                deleted.add(pair.first);
            }
        }
        return zip;
    }

