    /**
     * Move a VirtualFileImpl to a given location
     *
     * @param source the VirtualFileImpl instance to move
     * @param parent the VirtualFileImpl (must be a folder) which will become
     * the parent of the source
     * @param name a new name for the moved source, can be left {@code null} or
     * empty {@code String} for current source name
     * @param overWrite should the destination be overwritten, set to true to
     * overwrite, false otherwise
     * @return an instance of VirtualFileImpl, source under parent
     * @throws ForbiddenException
     * @throws ConflictException
     * @throws ServerException
     */
    @Beta
    VirtualFileImpl move(VirtualFileImpl source, VirtualFileImpl parent, String name, boolean overWrite, String lockToken)
            throws ForbiddenException, ConflictException, ServerException {
        final String sourcePath = source.getPath();
        final String parentPath = parent.getPath();
        if (source.isRoot()) {
            throw new ForbiddenException("Unable move root folder. ");
        }
        if (source.getVirtualFilePath().equals(parent.getVirtualFilePath())) {
            throw new ForbiddenException("Item cannot be moved to itself. ");
        }
        if (!parent.isFolder()) {
            throw new ForbiddenException("Unable move. Item specified as parent is not a folder. ");
        }
        if (source.isFolder() && parent.getVirtualFilePath().isChild(source.getVirtualFilePath())) {
            throw new ForbiddenException(String.format("Unable move item '%s' to '%s'. Item may not have itself as parent. ",
                                                       sourcePath, parentPath));
        }

        if (!(hasPermission(source, BasicPermissions.WRITE.value(), true)
              && hasPermission(parent, BasicPermissions.WRITE.value(), true))) {
            throw new ForbiddenException(
                    String.format("Unable move item '%s' to %s. Operation not permitted. ", sourcePath, parentPath));
        }
        // Even we check lock before delete original file check it here also to have better behaviour.
        // Prevent even copy original file if we already know it is locked.
        if (source.isFile() && !validateLockTokenIfLocked(source, lockToken)) {
            throw new ForbiddenException(String.format("Unable move file '%s'. File is locked. ", sourcePath));
        }

        String newName = nullToEmpty(name).trim().isEmpty() ? source.getName() : name;
        final Path newPath = parent.getVirtualFilePath().newPath(newName);
        VirtualFileImpl destination
                = new VirtualFileImpl(new java.io.File(ioRoot, toIoPath(newPath)), newPath, pathToId(newPath), this);

        // checking override
        if (destination.exists()) {
            doOverWrite(overWrite, destination, newPath);
        }

        // use copy and delete
        doCopy(source, destination);
        doDelete(source, lockToken);
        eventService.publish(new MoveEvent(workspaceId, destination.getPath(), sourcePath, destination.isFolder()));
        return destination;
    }

