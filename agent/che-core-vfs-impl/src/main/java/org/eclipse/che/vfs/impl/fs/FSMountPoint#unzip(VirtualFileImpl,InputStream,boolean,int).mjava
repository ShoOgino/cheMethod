    void unzip(VirtualFileImpl parent, InputStream zipped, boolean overwrite, int stripNumber)
            throws ForbiddenException, ConflictException, ServerException {
        if (!parent.isFolder()) {
            throw new ForbiddenException(String.format("Unable import zip content. Item '%s' is not a folder. ", parent.getPath()));
        }
        final ZipContent zipContent;
        try {
            zipContent = ZipContent.newInstance(zipped);
        } catch (IOException e) {
            throw new ServerException(e.getMessage(), e);
        }
        if (!hasPermission(parent, BasicPermissions.WRITE.value(), true)) {
            throw new ForbiddenException(String.format("Unable import from zip to '%s'. Operation not permitted. ", parent.getPath()));
        }

        ZipInputStream zip = null;
        try {
            zip = new ZipInputStream(zipContent.zippedData);
            // Wrap zip stream to prevent close it. We can pass stream to other method and it can read content of current
            // ZipEntry but not able to close original stream of ZIPed data.
            InputStream noCloseZip = new NotClosableInputStream(zip);
            ZipEntry zipEntry;
            while ((zipEntry = zip.getNextEntry()) != null) {
                VirtualFileImpl current = parent;
                Path relPath = Path.fromString(zipEntry.getName());

                if (stripNumber > 0) {
                    int currentLevel = relPath.elements().length;
                    if (currentLevel <= stripNumber) {
                        continue;
                    }
                    relPath = relPath.subPath(stripNumber);
                }

                final String name = relPath.getName();
                if (relPath.length() > 1) {
                    // create all required parent directories
                    final Path parentPath = parent.getVirtualFilePath().newPath(relPath.subPath(0, relPath.length() - 1));
                    current = new VirtualFileImpl(new java.io.File(ioRoot, toIoPath(parentPath)), parentPath, pathToId(parentPath), this);
                    if (!(current.exists() || current.getIoFile().mkdirs())) {
                        throw new ServerException(String.format("Unable create directory '%s' ", parentPath));
                    }
                }
                final Path newPath = current.getVirtualFilePath().newPath(name);
                if (zipEntry.isDirectory()) {
                    final java.io.File dir = new java.io.File(current.getIoFile(), name);
                    if (!dir.exists()) {
                        if (dir.mkdir()) {
                            eventService.publish(new CreateEvent(workspaceId, newPath.toString(), true));
                        } else {
                            throw new ServerException(String.format("Unable create directory '%s' ", newPath));
                        }
                    }
                } else {
                    final VirtualFileImpl file =
                            new VirtualFileImpl(new java.io.File(current.getIoFile(), name), newPath, pathToId(newPath), this);
                    if (file.exists()) {
                        if (isLocked(file)) {
                            throw new ForbiddenException(String.format("File '%s' already exists and locked. ", file.getPath()));
                        }
                        if (!hasPermission(file, BasicPermissions.WRITE.value(), true)) {
                            throw new ForbiddenException(
                                    String.format("Unable update file '%s'. Operation not permitted. ", file.getPath()));
                        }
                    }

                    boolean newFile;
                    try {
                        if (!(newFile = file.getIoFile().createNewFile())) { // atomic
                            if (!overwrite) {
                                throw new ConflictException(String.format("File '%s' already exists. ", file.getPath()));
                            }
                        }
                    } catch (IOException e) {
                        String msg = String.format("Unable create new file '%s'. ", newPath);
                        LOG.error(msg + e.getMessage(), e); // More details in log but do not show internal error to caller.
                        throw new ServerException(msg);
                    }

                    doUpdateContent(file, noCloseZip);
                    if (newFile) {
                        eventService.publish(new CreateEvent(workspaceId, newPath.toString(), false));
                    } else {
                        eventService.publish(new UpdateContentEvent(workspaceId, newPath.toString()));
                    }
                }
                zip.closeEntry();
            }
            if (searcherProvider != null) {
                try {
                    searcherProvider.getSearcher(this, true).add(parent);
                } catch (ServerException e) {
                    LOG.error(e.getMessage(), e);
                }
            }
        } catch (IOException e) {
            throw new ServerException(e.getMessage(), e);
        } finally {
            closeQuietly(zip);
        }
    }

